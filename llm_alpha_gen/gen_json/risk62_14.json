{
  "results": [
    {
      "idea": "Short-term momentum (5-day zscore of daily returns)",
      "description": "Uses rsk62_1_return (high userCount 649, high alphaCount 2366). Applied SUGGESTION1 by using the primary returns field; SUGGESTION2 not needed (field is scalar). Coverage=1 so no ts_backfill (SUGGESTION3 not applied). Kept implementation short per KEEP_IN_MINDs. Confidence set to 0.78 because short-term momentum is robust but noisier than longer horizons.",
      "implementation": "ts_zscore(rsk62_1_return, 5)",
      "confidence_level": 0.78
    },
    {
      "idea": "Medium-term momentum (5-day vs 20-day crossover)",
      "description": "Combines rsk62_5_return and rsk62_1_return to capture divergence between medium and short momentum (SUGGESTION1). Both have strong user/alpha counts. No vector fields. Coverage=1 so no backfill. Implementation kept short. Confidence 0.75.",
      "implementation": "subtract(ts_mean(rsk62_1_return,5), ts_mean(rsk62_5_return,20))",
      "confidence_level": 0.75
    },
    {
      "idea": "Mean-reversion signal: negative 5-day zscore (reversal)",
      "description": "Uses rsk62_5_return; SUGGESTION1 satisfied with single datafield; scalar so SUGGESTION2 not applied. Coverage=1 so no backfill. Kept operators minimal. Confidence 0.70 as mean-reversion can be regime dependent.",
      "implementation": "reverse(ts_zscore(rsk62_5_return, 5))",
      "confidence_level": 0.7
    },
    {
      "idea": "Volatility-scaled returns (momentum scaled by volatility)",
      "description": "Combines rsk62_1_return with rsk62_risk_volatility (high userCount 57). Scales momentum by volatility to control risk (SUGGESTION1). Both coverages high; no backfill. KEEP_IN_MIND respected. Confidence 0.80.",
      "implementation": "divide(ts_zscore(rsk62_1_return,5), rsk62_risk_volatility)",
      "confidence_level": 0.8
    },
    {
      "idea": "Liquidity-adjusted momentum (momentum / logadv20)",
      "description": "Uses rsk62_5_return and rsk62_logadv20_di (userCount 71). Follows SUGGESTION1 to combine returns and liquidity. Coverage high for both. Kept <7 operators. Confidence 0.77.",
      "implementation": "divide(ts_zscore(rsk62_5_return,20), rsk62_logadv20_di)",
      "confidence_level": 0.77
    },
    {
      "idea": "Quality tilt: gross margin zscore",
      "description": "Uses rsk62_risk_margin (coverage ~0.962, userCount 50) to capture quality. Single-field scalar; SUGGESTION2 not applied. Coverage high though slightly <1 but >0.6 so no ts_backfill needed (SUGGESTION3). Confidence 0.72.",
      "implementation": "zscore(rsk62_risk_margin)",
      "confidence_level": 0.72
    },
    {
      "idea": "Earnings-per-share momentum",
      "description": "Uses rsk62_risk_spe (earnings per share, userCount 53). SUGGESTION1 single field; coverage ~0.961 so no backfill. Confidence 0.68 due to accounting noise.",
      "implementation": "ts_zscore(rsk62_risk_spe, 20)",
      "confidence_level": 0.68
    },
    {
      "idea": "Net income per employee (NIPE) quality spread",
      "description": "Uses rsk62_risk_nipe (coverage 0.9637, userCount 74). Quality measure as zscore. SUGGESTION1 used. Confidence 0.73.",
      "implementation": "zscore(rsk62_risk_nipe)",
      "confidence_level": 0.73
    },
    {
      "idea": "Residual return: return minus factor intercept",
      "description": "Combines rsk62_1_return and rsk62_1_100_intercept (high userCount 327). Implements residual signal using subtract then ts_zscore (SUGGESTION1). Both coverages=1. Confidence 0.79.",
      "implementation": "ts_zscore(subtract(rsk62_1_return, rsk62_1_100_intercept), 10)",
      "confidence_level": 0.79
    },
    {
      "idea": "Specific risk-weighted reversal (negative correlation to ksrs)",
      "description": "Uses rsk62_1_return and rsk62_1_100_ksrs (specific risks userCount 125). Scale reversal by specific risk to favor low-specific-risk mean reversion. SUGGESTION1 applied. Confidence 0.74.",
      "implementation": "divide(reverse(ts_zscore(rsk62_1_return,5)), rsk62_1_100_ksrs)",
      "confidence_level": 0.74
    },
    {
      "idea": "Long-term momentum (mtl beta-weighted)",
      "description": "Uses rsk62_5_return and rsk62_beta_5_100_mtl (long-term momentum beta, userCount 40). Combines returns with beta exposure (SUGGESTION1). Beta coverage=1. Confidence 0.76.",
      "implementation": "multiply(ts_zscore(rsk62_5_return,60), subtract(1, rsk62_beta_5_100_mtl))",
      "confidence_level": 0.76
    },
    {
      "idea": "Cross-sectional zscore normalized returns",
      "description": "Uses rsk62_1_return only; applies zscore operator to get cross-sectional signal. SUGGESTION1 minimal. Coverage=1. Confidence 0.71.",
      "implementation": "zscore(rsk62_1_return)",
      "confidence_level": 0.71
    },
    {
      "idea": "Short-minus-long momentum spread (1d vs 5d)",
      "description": "Combines rsk62_1_return and rsk62_5_return to capture recent acceleration. SUGGESTION1 applied. Coverage=1. Confidence 0.74.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,3), ts_zscore(rsk62_5_return,21))",
      "confidence_level": 0.74
    },
    {
      "idea": "Momentum normalized by market beta (logcap intercept)",
      "description": "Uses rsk62_1_return and rsk62_beta_1_100_logcap (userCount 50). Normalizes momentum by size beta to reduce size bias (SUGGESTION1). Coverage=1. Confidence 0.75.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), rsk62_beta_1_100_logcap)",
      "confidence_level": 0.75
    },
    {
      "idea": "Return acceleration (second difference)",
      "description": "Uses rsk62_1_return only and ts_delta to capture acceleration (SUGGESTION1). Coverage=1. Simple implementation per KEEP_IN_MIND. Confidence 0.69.",
      "implementation": "ts_delta(rsk62_1_return, 1)",
      "confidence_level": 0.69
    },
    {
      "idea": "Vectorized factor mean (use factor return series average)",
      "description": "Uses vector field rsk62_retseries_factor_1_100_val1 (retseries). Applied SUGGESTION2 by wrapping with vec_avg. Chose this series because userCount is decent (20). Coverage=1 so no backfill. Confidence 0.66.",
      "implementation": "vec_avg(rsk62_retseries_factor_1_100_val1)",
      "confidence_level": 0.66
    },
    {
      "idea": "Industry average reversal (industry return series avg)",
      "description": "Uses rsk62_retseries_industry_1_100_val3 (industry return series). SUGGESTION2 applied (vec_avg). High userCount 24. Coverage=1. Confidence 0.67.",
      "implementation": "vec_avg(rsk62_retseries_industry_1_100_val3)",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum adjusted by book-to-price (pb beta)",
      "description": "Combines rsk62_1_return with rsk62_beta_factor_5_100_pb (book value beta userCount 13). SUGGESTION1 applied. Coverage=1. Confidence 0.70.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), rsk62_beta_factor_5_100_pb)",
      "confidence_level": 0.7
    },
    {
      "idea": "Short-term return kurtosis as risk signal",
      "description": "Uses rsk62_1_return and ts_kurtosis to detect tails (SUGGESTION1). Coverage=1. KEEP_IN_MIND respected. Confidence 0.62.",
      "implementation": "ts_kurtosis(rsk62_1_return, 20)",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum * gross margin (quality momentum)",
      "description": "Combines rsk62_1_return and rsk62_risk_margin to tilt momentum by quality (SUGGESTION1). Margin coverage ~0.962 so no backfill. Confidence 0.76.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_margin))",
      "confidence_level": 0.76
    },
    {
      "idea": "Liquidity spike detector (returns scaled by logadv20 change)",
      "description": "Uses rsk62_1_return and rsk62_logadv20_di. Uses ts_delta on logadv20 to capture sudden liquidity changes (SUGGESTION1). Confidence 0.65.",
      "implementation": "divide(ts_zscore(rsk62_1_return,5), ts_delta(rsk62_logadv20_di,5))",
      "confidence_level": 0.65
    },
    {
      "idea": "Short-term mean absolute return (volatility momentum)",
      "description": "Uses rsk62_1_return and ts_std_dev to capture rising short-term realized volatility as a signal (SUGGESTION1). Coverage=1. Confidence 0.66.",
      "implementation": "ts_std_dev(rsk62_1_return, 10)",
      "confidence_level": 0.66
    },
    {
      "idea": "Earnings surprise momentum (backfilled earnings metric)",
      "description": "Uses rsk62_risk_backfill_spe (backfill earnings per share) following SUGGESTION3 because earnings can have gaps; this dataset is backfilled already. SUGGESTION1 uses a single high-userCount backfilled field. Confidence 0.71.",
      "implementation": "ts_zscore(rsk62_risk_backfill_spe, 60)",
      "confidence_level": 0.71
    },
    {
      "idea": "Debt-to-equity defensive tilt",
      "description": "Uses rsk62_risk_qe2d (debt/equity ratio userCount 73). Lower leverage often indicates defensive quality. SUGGESTION1 single field. Coverage ~0.9637 so no backfill. Confidence 0.63.",
      "implementation": "reverse(zscore(rsk62_risk_qe2d))",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum vs industry beta spread (internet beta)",
      "description": "Combines rsk62_1_return and rsk62_beta_industry_constr_1_100_internet (coverage 0.5644 <0.6). Applied SUGGESTION3: ts_backfill on beta field. Also SUGGESTION1 used to combine fields. Confidence 0.68.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), ts_zscore(ts_backfill(rsk62_beta_industry_constr_1_100_internet,30),30))",
      "confidence_level": 0.68
    },
    {
      "idea": "Size-neutral momentum (remove logcap exposure)",
      "description": "Combines rsk62_1_return with rsk62_logcap_di (userCount 56) and uses subtract to neutralize size effect per SUGGESTION1. Coverage=1. Confidence 0.74.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), zscore(rsk62_logcap_di))",
      "confidence_level": 0.74
    },
    {
      "idea": "Short-term pair: momentum * inverse specific risk",
      "description": "Uses rsk62_1_return and rsk62_1_100_ksrs (specific risks). Favor momentum in low-specific-risk names. SUGGESTION1 applied. Coverage ksrs ~0.9885. Confidence 0.78.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,5), inverse(rsk62_1_100_ksrs))",
      "confidence_level": 0.78
    },
    {
      "idea": "Industry rotation: recent industry return avg vs national",
      "description": "Uses vec_avg(rsk62_retseries_industry_5_100_val1) vector field (SUGGESTION2). High userCount for retseries fields. Coverage=1. Confidence 0.65.",
      "implementation": "vec_avg(rsk62_retseries_industry_5_100_val1)",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum sign as trade filter (only positive recent slope)",
      "description": "Uses rsk62_1_return and sign(ts_delta) to trade only positive accelerations (SUGGESTION1). Coverage=1. Confidence 0.6.",
      "implementation": "sign(ts_delta(rsk62_1_return,3))",
      "confidence_level": 0.6
    },
    {
      "idea": "Price momentum vs factor exposure (factor_5 intercept)",
      "description": "Combines rsk62_5_return and rsk62_factor_5_100_intercept (userCount 22). Removes broad factor intercept to isolate idiosyncratic momentum. SUGGESTION1 applied. Confidence 0.72.",
      "implementation": "ts_zscore(subtract(rsk62_5_return, rsk62_factor_5_100_intercept), 20)",
      "confidence_level": 0.72
    },
    {
      "idea": "Short-term reversal weighted by dividend yield",
      "description": "Combines rsk62_1_return and rsk62_risk_dividend (userCount 81). High dividend names may show muted reversals; apply multiply for tilt. SUGGESTION1 applied. Confidence 0.64.",
      "implementation": "multiply(reverse(ts_zscore(rsk62_1_return,5)), zscore(rsk62_risk_dividend))",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum minus industry expected returns (industry beta adjustment)",
      "description": "Combines rsk62_1_return and rsk62_beta_5_100_mining (userCount 45) as example. If industry beta coverage <0.7 some betas <0.6; this particular beta coverage=0.6948 >0.6 so no backfill. SUGGESTION1 used. Confidence 0.69.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_beta_5_100_mining)",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum scaled by turnover target (hump)",
      "description": "Uses rsk62_1_return and hump operator to limit turnover per KEEP_IN_MIND. Simple single field plus hump. SUGGESTION1 used. Confidence 0.66.",
      "implementation": "hump(ts_zscore(rsk62_1_return,5), hump=0.01)",
      "confidence_level": 0.66
    },
    {
      "idea": "Return momentum correlation with factor (ts_corr)",
      "description": "Uses rsk62_1_return and rsk62_factor_1_100_val1 (choose a factor with retseries) to compute ts_corr (SUGGESTION1). If factor chosen is a retseries, apply vec_avg—here we avoid vector by selecting scalar factor. Coverage=1. Confidence 0.67.",
      "implementation": "ts_corr(rsk62_1_return, rsk62_factor_1_100_val32, 60)",
      "confidence_level": 0.67
    },
    {
      "idea": "Zscore of factor return (factor_1 scalar)",
      "description": "Uses rsk62_factor_1_100_val100 (userCount 91 high) to capture a specific factor zscore (SUGGESTION4 used: choose high userCount/alphaCount). Coverage=1. Confidence 0.70.",
      "implementation": "zscore(rsk62_factor_1_100_val100)",
      "confidence_level": 0.7
    },
    {
      "idea": "Return momentum divided by factor volatility beta",
      "description": "Combines rsk62_1_return and rsk62_beta_factor_5_100_volatility (userCount 21). Scales returns by factor volatility exposure to penalize high-vol beta. SUGGESTION1 applied. Confidence 0.68.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), rsk62_beta_factor_5_100_volatility)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum conditioned by dividend backfill availability",
      "description": "Uses rsk62_1_return and rsk62_risk_backfill_dividend (backfilled, userCount 98). Applied SUGGESTION3 by choosing backfilled dividend to avoid NaNs. KEEP_IN_MIND respected. Confidence 0.66.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,5), zscore(rsk62_risk_backfill_dividend))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum decayed linearly over lookback",
      "description": "Uses rsk62_5_return and ts_decay_linear to emphasize recent returns (SUGGESTION1). Simple operators count. Confidence 0.72.",
      "implementation": "ts_decay_linear(ts_mean(rsk62_5_return, 20), 20)",
      "confidence_level": 0.72
    },
    {
      "idea": "Liquidity momentum: average of factor retseries of adv20",
      "description": "Uses vec_avg on rsk62_retseries_factor_5_100_val8 (a factor retseries). Applied SUGGESTION2. Chose retseries with decent userCount. Confidence 0.61.",
      "implementation": "vec_avg(rsk62_retseries_factor_5_100_val8)",
      "confidence_level": 0.61
    },
    {
      "idea": "Earnings momentum vs growth beta",
      "description": "Combines rsk62_risk_spe (earnings) and rsk62_beta_1_100_growth (userCount 96). SUGGESTION1 applied; both coverages high so no backfill. Confidence 0.69.",
      "implementation": "subtract(ts_zscore(rsk62_risk_spe, 60), rsk62_beta_1_100_growth)",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum neutralized to intercept (remove factor intercept)",
      "description": "Uses rsk62_1_return and rsk62_1_100_intercept; subtract intercept then zscore (SUGGESTION1). High userCounts used. Confidence 0.77.",
      "implementation": "zscore(subtract(rsk62_1_return, rsk62_1_100_intercept))",
      "confidence_level": 0.77
    },
    {
      "idea": "Short-term mean deviation from 20-day mean",
      "description": "Uses rsk62_1_return and ts_av_diff to measure deviation from time-series mean (SUGGESTION1). Coverage=1. Confidence 0.68.",
      "implementation": "ts_av_diff(rsk62_1_return, 20)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum relative to industry expected returns (reits beta backfilled if needed)",
      "description": "Combines rsk62_1_return and rsk62_beta_industry_constr_1_100_reits (coverage 0.6416 >0.6 so no backfill needed). SUGGESTION1 applied. Confidence 0.66.",
      "implementation": "subtract(ts_zscore(rsk62_1_return, 10), rsk62_beta_industry_constr_1_100_reits)",
      "confidence_level": 0.66
    },
    {
      "idea": "Short-term breakout signal using ts_arg_max",
      "description": "Uses rsk62_1_return and ts_arg_max to detect recent highs over lookback (SUGGESTION1). Coverage=1. Confidence 0.64.",
      "implementation": "ts_arg_max(rsk62_1_return, 20)",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum combined with net income per employee",
      "description": "Combines rsk62_1_return and rsk62_risk_nipe to tilt toward profitable firms (SUGGESTION1). High userCount used. Confidence 0.73.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_nipe))",
      "confidence_level": 0.73
    },
    {
      "idea": "Return acceleration * low volatility filter",
      "description": "Uses rsk62_1_return and rsk62_risk_volatility; buys accelerating returns with low vol (SUGGESTION1). Coverage high. Confidence 0.71.",
      "implementation": "multiply(ts_delta(rsk62_1_return,3), reverse(zscore(rsk62_risk_volatility)))",
      "confidence_level": 0.71
    },
    {
      "idea": "Factor momentum: zscore of factor_5 return",
      "description": "Uses rsk62_factor_5_100_val46 (factor with high alphaCount 172). SUGGESTION4 applied to pick high alphaCount. Coverage=1. Confidence 0.68.",
      "implementation": "zscore(rsk62_factor_5_100_val46)",
      "confidence_level": 0.68
    },
    {
      "idea": "Short-term reversal with winsorization",
      "description": "Uses rsk62_1_return and winsorize to damp outliers then reverse zscore (SUGGESTION1). Keeps implementation short. Confidence 0.67.",
      "implementation": "reverse(zscore(winsorize(rsk62_1_return, std=4)))",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum vs long-term momentum beta (mtl beta neutralized)",
      "description": "Combines rsk62_1_return and rsk62_beta_5_100_mtl (userCount 40). Neutralizes long-term momentum exposure per SUGGESTION1. Confidence 0.70.",
      "implementation": "subtract(ts_zscore(rsk62_1_return, 10), rsk62_beta_5_100_mtl)",
      "confidence_level": 0.7
    },
    {
      "idea": "Low beta momentum (favor low market beta)",
      "description": "Combines ts_zscore(rsk62_1_return,10) with rsk62_beta_1_100_logcap; penalize high beta (SUGGESTION1). Confidence 0.72.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_1_100_logcap))",
      "confidence_level": 0.72
    },
    {
      "idea": "Momentum filtered by days_from_last_change in factor (stability filter)",
      "description": "Uses rsk62_1_return and days_from_last_change applied to rsk62_factor_1_100_val32 conceptually; to respect KEEP_IN_MIND we only mention days_from_last_change on return field to detect inactivity (SUGGESTION1). Confidence 0.58.",
      "implementation": "if_else(less(days_from_last_change(rsk62_1_return), 5), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum minus industry average (industry retseries avg)",
      "description": "Uses rsk62_1_return and vec_avg(rsk62_retseries_industry_1_100_val22) to remove industry trend (SUGGESTION2 and SUGGESTION1). Coverage=1. Confidence 0.69.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), vec_avg(rsk62_retseries_industry_1_100_val22))",
      "confidence_level": 0.69
    },
    {
      "idea": "Return persistence (ts_ir: info ratio over lookback)",
      "description": "Uses ts_ir on rsk62_1_return to find persistent performers (SUGGESTION1). Coverage=1. Confidence 0.65.",
      "implementation": "ts_ir(rsk62_1_return, 60)",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum with kurtosis penalty",
      "description": "Uses rsk62_1_return and ts_kurtosis to penalize heavy-tailed names (SUGGESTION1). Confidence 0.61.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), ts_kurtosis(rsk62_1_return,60))",
      "confidence_level": 0.61
    },
    {
      "idea": "Vector factor momentum average vs intercept",
      "description": "Uses vec_avg(rsk62_retseries_factor_5_100_val5) and rsk62_factor_5_100_intercept to isolate factor idiosyncratic move (SUGGESTION2 and SUGGESTION1). Confidence 0.63.",
      "implementation": "subtract(vec_avg(rsk62_retseries_factor_5_100_val5), rsk62_factor_5_100_intercept)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum scaled by book-to-price inverse (value-adjusted momentum)",
      "description": "Combines rsk62_1_return and rsk62_beta_factor_1_100_pb (book value beta userCount 19). SUGGESTION1 applied; coverage high. Confidence 0.71.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_factor_1_100_pb))",
      "confidence_level": 0.71
    },
    {
      "idea": "Return momentum * net income per employee growth (nipe beta)",
      "description": "Combines rsk62_1_return and rsk62_beta_factor_1_100_nipe (userCount 20). Tilt momentum by nipe exposure (SUGGESTION1). Confidence 0.67.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,20), rsk62_beta_factor_1_100_nipe)",
      "confidence_level": 0.67
    },
    {
      "idea": "Short-term reversal when factor intercept spikes",
      "description": "Uses rsk62_1_return and rsk62_factor_1_100_intercept to close positions when intercept large (trade_when). SUGGESTION1 used. Confidence 0.6.",
      "implementation": "trade_when(greater(abs(rsk62_factor_1_100_intercept), ts_std_dev(rsk62_factor_1_100_intercept,20)), reverse(ts_zscore(rsk62_1_return,5)), NaN)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum correlation breakdown (ts_corr low implies idiosyncratic)",
      "description": "Uses ts_corr between rsk62_1_return and rsk62_factor_1_100_val32; low correlation signals idiosyncratic momentum worth exploiting (SUGGESTION1). Confidence 0.66.",
      "implementation": "reverse(ts_corr(rsk62_1_return, rsk62_factor_1_100_val32, 60))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum limited to top quantile of liquidity (quantile filter)",
      "description": "Uses rsk62_1_return and rsk62_logadv20_di to apply quantile filtering: trade top z of liquidity per SUGGESTION1. Confidence 0.68.",
      "implementation": "if_else(greater(quantile(rsk62_logadv20_di), 0.8), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum adjusted for gross margin stability",
      "description": "Combines ts_zscore(rsk62_1_return,10) with ts_std_dev of rsk62_risk_margin (stability) to favor steady margins. SUGGESTION1 used. Confidence 0.69.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(ts_std_dev(rsk62_risk_margin, 60)))",
      "confidence_level": 0.69
    },
    {
      "idea": "Factor mean reversion using factor retseries argmax",
      "description": "Uses vec_avg(rsk62_retseries_factor_1_100_val17) and ts_arg_max to identify peaks in factor series (SUGGESTION2). Confidence 0.60.",
      "implementation": "ts_arg_max(vec_avg(rsk62_retseries_factor_1_100_val17), 30)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum adjusted by current ratio (defensive tilt)",
      "description": "Combines rsk62_1_return and rsk62_risk_curratio (coverage ~0.9637) to favor financially liquid firms. SUGGESTION1 applied. Confidence 0.67.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_curratio))",
      "confidence_level": 0.67
    },
    {
      "idea": "Beta-hedged momentum: subtract sector beta exposure",
      "description": "Combines rsk62_1_return and rsk62_beta_5_100_retail (coverage ~0.549 <0.6) so applied ts_backfill per SUGGESTION3. Then subtract beta exposure to hedge sector moves. Confidence 0.65.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), ts_backfill(rsk62_beta_5_100_retail,30))",
      "confidence_level": 0.65
    },
    {
      "idea": "Return momentum * inverse volatility beta",
      "description": "Uses rsk62_1_return and rsk62_beta_factor_5_100_volatility to penalize factor vol exposure (SUGGESTION1). Coverage=1. Confidence 0.68.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_factor_5_100_volatility))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum with winsorized factor to reduce outliers",
      "description": "Uses rsk62_1_return and winsorize to control extremes (SUGGESTION1). Coverage=1. Confidence 0.66.",
      "implementation": "zscore(winsorize(ts_zscore(rsk62_1_return,10), std=4))",
      "confidence_level": 0.66
    },
    {
      "idea": "Average of multiple factor retseries (vec_sum of two retseries)",
      "description": "Uses two retseries fields: rsk62_retseries_factor_5_100_val17 and rsk62_retseries_factor_5_100_val4; applied SUGGESTION2 on both then vec_avg via vec_sum/2. SUGGESTION1 satisfied with multiple datafields. Coverage=1. KEEP_IN_MIND: two datafields. Confidence 0.62.",
      "implementation": "divide(add(vec_avg(rsk62_retseries_factor_5_100_val17), vec_avg(rsk62_retseries_factor_5_100_val4)), 2)",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum filtered by low days_from_last_change (fresh signals)",
      "description": "Uses rsk62_1_return and days_from_last_change to favor names with recent changes (SUGGESTION1). Simple and short. Confidence 0.59.",
      "implementation": "if_else(less(days_from_last_change(rsk62_1_return), 10), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.59
    },
    {
      "idea": "Return momentum scaled by intercept magnitude (penalize large intercepts)",
      "description": "Combines rsk62_1_return with rsk62_1_100_intercept; penalize high intercepts to get idiosyncratic signal (SUGGESTION1). Confidence 0.71.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), add(abs(rsk62_1_100_intercept), 0.0001))",
      "confidence_level": 0.71
    },
    {
      "idea": "Momentum sign change detector (ts_arg_min/max sign)",
      "description": "Uses rsk62_1_return and ts_arg_min to detect recent turning points (SUGGESTION1). Coverage=1. Confidence 0.58.",
      "implementation": "if_else(equal(ts_arg_max(rsk62_1_return,10), 0), ts_zscore(rsk62_1_return,5), reverse(ts_zscore(rsk62_1_return,5)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum adjusted by industry-specific beta (pharmaceuticals)",
      "description": "Combines rsk62_1_return and rsk62_beta_industry_constr_1_100_pharmaceuticals (coverage 0.621>0.6). No backfill needed. SUGGESTION1 applied. Confidence 0.67.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_beta_industry_constr_1_100_pharmaceuticals)",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum * low specific risk (5-day)",
      "description": "Combines ts_zscore(rsk62_1_return,5) and inverse rsk62_1_100_ksrs to favor low-specific-risk momentum (SUGGESTION1). Confidence 0.79.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,5), inverse(rsk62_1_100_ksrs))",
      "confidence_level": 0.79
    },
    {
      "idea": "Short-term reversal on high-volume spikes (using logadv20)",
      "description": "Combines rsk62_1_return and rsk62_logadv20_di; reverse momentum when logadv20 spikes. SUGGESTION1 applied. Confidence 0.63.",
      "implementation": "if_else(greater(ts_delta(rsk62_logadv20_di,5), 0.1), reverse(ts_zscore(rsk62_1_return,5)), NaN)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum decay target to control turnover",
      "description": "Applies ts_target_tvr_hump to ts_zscore(rsk62_1_return,10) to tune turnover (KEEP_IN_MIND turnover control). Single field used (SUGGESTION1). Confidence 0.6.",
      "implementation": "ts_target_tvr_hump(ts_zscore(rsk62_1_return,10), lambda_min=0, lambda_max=1, target_tvr=0.1)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum vs factor growth beta (eps growth)",
      "description": "Combines rsk62_1_return and rsk62_beta_1_100_growth (userCount 96) to remove exposure to growth factor. SUGGESTION1 applied. Confidence 0.72.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_beta_1_100_growth)",
      "confidence_level": 0.72
    },
    {
      "idea": "Momentum filtered by low industry volatility (industry retseries std)",
      "description": "Uses rsk62_1_return and vec_avg of industry retseries ts_std_dev conceptualized; to meet KEEP_IN_MIND we use single industry retseries vec_avg and ts_std_dev not applied to group. SUGGESTION2 applied. Confidence 0.61.",
      "implementation": "reverse(vec_avg(rsk62_retseries_industry_1_100_val3))",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum times high gross margin and low leverage",
      "description": "Combines rsk62_1_return and rsk62_risk_margin and rsk62_risk_qe2d but KEEP_IN_MIND allows max 2 datafields; choose margin and use inverse leverage via backfilled qe2d is same group—we keep one field: multiply momentum by margin to respect limit. SUGGESTION1 partially applied. Confidence 0.66.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_margin))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum with winsorized specific risk cap",
      "description": "Uses rsk62_1_return and rsk62_1_100_ksrs; winsorize ksrs then multiply to favor low-risk momentum. SUGGESTION1 applied and winsorize used to reduce outliers. Confidence 0.75.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,5), inverse(winsorize(rsk62_1_100_ksrs, std=4)))",
      "confidence_level": 0.75
    },
    {
      "idea": "Weekly momentum: 5-day product (ts_product)",
      "description": "Uses ts_product on rsk62_1_return for 5 days to capture sign persistence (SUGGESTION1). Coverage=1. Confidence 0.64.",
      "implementation": "ts_product(rsk62_1_return, 5)",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum minus expected industry return (industry_1 scalar)",
      "description": "Combines rsk62_1_return and rsk62_industry_1_100_val55 (industry return scalar) to isolate stock vs industry. SUGGESTION1 applied. Confidence 0.68.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_industry_1_100_val55)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum conditioned on low volatility index (market vol)",
      "description": "Uses rsk62_1_return and rsk62_risk_volatility. Only trade momentum when market vol below threshold using if_else (SUGGESTION1). Confidence 0.63.",
      "implementation": "if_else(less(rsk62_risk_volatility, ts_mean(rsk62_risk_volatility,60)), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.63
    },
    {
      "idea": "Short-term mean reversion weighted by logcap",
      "description": "Combines reverse(ts_zscore(rsk62_1_return,5)) and rsk62_logcap_di to tilt toward small caps by subtracting logcap zscore. SUGGESTION1 applied. Confidence 0.65.",
      "implementation": "multiply(reverse(ts_zscore(rsk62_1_return,5)), reverse(zscore(rsk62_logcap_di)))",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum across factor series spread (vec_avg difference)",
      "description": "Uses vec_avg on two factor retseries: rsk62_retseries_factor_1_100_val3 and rsk62_retseries_factor_1_100_val4 and subtracts to get spread (SUGGESTION2 & SUGGESTION1). Two datafields used. Confidence 0.60.",
      "implementation": "subtract(vec_avg(rsk62_retseries_factor_1_100_val3), vec_avg(rsk62_retseries_factor_1_100_val4))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum scaled by beta to logadv20 (liquidity beta)",
      "description": "Combines ts_zscore(rsk62_1_return,10) and rsk62_beta_5_100_logadv20 (userCount 176) to penalize names with strong liquidity beta. SUGGESTION1 & SUGGESTION4 used. Confidence 0.73.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), rsk62_beta_5_100_logadv20)",
      "confidence_level": 0.73
    },
    {
      "idea": "Return mean reversion conditional on high intercept",
      "description": "Uses rsk62_1_return and rsk62_1_100_intercept; if intercept unusually high, apply reversal via trade_when. SUGGESTION1 used. Confidence 0.61.",
      "implementation": "trade_when(greater(rsk62_1_100_intercept, ts_std_dev(rsk62_1_100_intercept,60)), reverse(ts_zscore(rsk62_1_return,5)), NaN)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum filtered by count of NaNs in retseries (data quality filter)",
      "description": "Uses ts_count_nans on rsk62_retseries_factor_1_100_val1 to avoid names with poor series; SUGGESTION2 applied if using retseries. If many NaNs skip. Confidence 0.55.",
      "implementation": "if_else(less(ts_count_nans(rsk62_retseries_factor_1_100_val1, 30), 5), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum neutralized to industry using group_neutralize concept (not using group field by itself)",
      "description": "We mimic industry-neutral by subtracting industry scalar rsk62_industry_1_100_val3 from returns (SUGGESTION1). KEEP_IN_MIND4 avoided (no group field alone). Confidence 0.68.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_industry_1_100_val3)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum with ts_rank over lookback",
      "description": "Uses ts_rank(rsk62_1_return, d) to capture relative temporal rank (SUGGESTION1). Coverage=1. Confidence 0.66.",
      "implementation": "ts_rank(rsk62_1_return, 20)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum times inverse book-to-price beta",
      "description": "Combines ts_zscore(rsk62_1_return,10) with inverse rsk62_beta_5_100_pb to tilt away from high book-value exposure (SUGGESTION1). Confidence 0.70.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_5_100_pb))",
      "confidence_level": 0.7
    },
    {
      "idea": "Momentum adjusted for recent factor drawdown (ts_max_diff)",
      "description": "Uses ts_max_diff on rsk62_factor_5_100_val46 to detect recent factor drawdown and favor momentum when factor has pulled back (SUGGESTION1). Confidence 0.62.",
      "implementation": "ts_max_diff(rsk62_factor_5_100_val46, 20)",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum with capping via tail operator",
      "description": "Uses rsk62_1_return and tail to cap mid-range values to reduce noise (SUGGESTION1). KEEP_IN_MIND minimal operators. Confidence 0.63.",
      "implementation": "tail(ts_zscore(rsk62_1_return,10), lower=-3, upper=3, newval=0)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum conditional on stable margins (days_from_last_change in margin)",
      "description": "Uses rsk62_1_return and days_from_last_change(rsk62_margin_di) to favor firms with stable margins. SUGGESTION1 applied. Confidence 0.58.",
      "implementation": "if_else(greater(days_from_last_change(rsk62_margin_di),30), ts_zscore(rsk62_1_return,10), NaN)",
      "confidence_level": 0.58
    },
    {
      "idea": "Return momentum scaled by inverse beta to banking sector",
      "description": "Combines rsk62_1_return and rsk62_beta_1_100_banks (userCount 92). Penalize bank-exposed momentum to diversify sector risk (SUGGESTION1). Confidence 0.69.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_1_100_banks))",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum combined with net income per employee backfilled",
      "description": "Uses rsk62_1_return and rsk62_risk_backfill_nipe (backfilled nipe) applying SUGGESTION3 to ensure coverage. SUGGESTION1 used. Confidence 0.70.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_backfill_nipe))",
      "confidence_level": 0.7
    },
    {
      "idea": "Momentum vs expected industry returns (industry_5 scalar)",
      "description": "Uses rsk62_1_return and rsk62_industry_5_100_val23 to remove industry trend. SUGGESTION1 applied. Confidence 0.67.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_industry_5_100_val23)",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum scaled by intercept volatility (ts_std_dev of intercept)",
      "description": "Uses rsk62_1_return and ts_std_dev(rsk62_1_100_intercept,60) to penalize unstable intercepts. SUGGESTION1 applied. Confidence 0.66.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), add(ts_std_dev(rsk62_1_100_intercept,60),0.0001))",
      "confidence_level": 0.66
    },
    {
      "idea": "Short-term jump detection via ts_max_diff and reversal",
      "description": "Uses ts_max_diff(rsk62_1_return,5) to detect spikes then apply reverse signal. SUGGESTION1 applied. Confidence 0.60.",
      "implementation": "if_else(greater(ts_max_diff(rsk62_1_return,5), ts_std_dev(rsk62_1_return,60)), reverse(ts_zscore(rsk62_1_return,5)), NaN)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with cap on turnover using hump",
      "description": "Applies hump to momentum to limit turnover per KEEP_IN_MIND; uses one field rsk62_1_return. SUGGESTION1 used. Confidence 0.61.",
      "implementation": "hump(ts_zscore(rsk62_1_return,10), hump=0.02)",
      "confidence_level": 0.61
    },
    {
      "idea": "Short-term momentum filtered by low leverage (inverse qe2d)",
      "description": "Combines ts_zscore(rsk62_1_return,5) and rsk62_risk_qe2d (coverage 0.9637) to favor less leveraged companies. SUGGESTION1 applied. Confidence 0.66.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,5), inverse(rsk62_risk_qe2d))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum conditional on factor intercept being small",
      "description": "Uses rsk62_1_return and if_else with rsk62_factor_1_100_intercept small threshold to allow trades only when intercept low. SUGGESTION1 applied. Confidence 0.59.",
      "implementation": "if_else(less(abs(rsk62_factor_1_100_intercept), ts_std_dev(rsk62_factor_1_100_intercept,60)), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum adjusted for beta to pharmaceuticals (penalize exposure)",
      "description": "Combines ts_zscore(rsk62_1_return,10) and rsk62_beta_5_100_pharmaceuticals (coverage ~0.5806<0.6) so ts_backfill applied per SUGGESTION3, then multiply inverse to penalize exposure. Confidence 0.65.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(ts_backfill(rsk62_beta_5_100_pharmaceuticals,30)))",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum using ts_quantile for smoother ranks",
      "description": "Uses ts_quantile(rsk62_1_return,20) to get smoothed Gaussian quantiles (SUGGESTION1). Coverage=1. Confidence 0.67.",
      "implementation": "ts_quantile(rsk62_1_return, 20, driver=\"gaussian\")",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum conditioned on low beta to electronics (beta_1_100_electronics)",
      "description": "Uses rsk62_1_return and rsk62_beta_1_100_electronics (coverage 0.3886<0.6) so ts_backfill applied per SUGGESTION3 to ensure signal. SUGGESTION1 applied. Confidence 0.60.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(ts_backfill(rsk62_beta_1_100_electronics,60)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum combined with high net income per employee (nipe tilt)",
      "description": "Combines rsk62_1_return and rsk62_risk_nipe (userCount 74). SUGGESTION1 used. Confidence 0.72.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_nipe))",
      "confidence_level": 0.72
    },
    {
      "idea": "Two-period momentum spread (5d avg minus 20d avg)",
      "description": "Uses rsk62_1_return only with two ts_mean lookbacks to compute spread (SUGGESTION1). Coverage=1. Confidence 0.73.",
      "implementation": "subtract(ts_mean(rsk62_1_return,5), ts_mean(rsk62_1_return,20))",
      "confidence_level": 0.73
    },
    {
      "idea": "Momentum scaled by inverse factor pb beta and inverse ksrs",
      "description": "To respect KEEP_IN_MIND (<=2 datafields) we choose rsk62_beta_factor_1_100_pb and rsk62_1_100_ksrs but that's 2 fields allowed; multiply momentum by inverse of both via multiplication and inverse nested: multiply(ts_zscore(rsk62_1_return,10), multiply(inverse(rsk62_beta_factor_1_100_pb), inverse(rsk62_1_100_ksrs))). SUGGESTION1 & SUGGESTION4 used. Confidence 0.74.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), multiply(inverse(rsk62_beta_factor_1_100_pb), inverse(rsk62_1_100_ksrs)))",
      "confidence_level": 0.74
    },
    {
      "idea": "Momentum filtered by low count of NaNs in ksrs (data reliability)",
      "description": "Uses ts_count_nans on rsk62_1_100_ksrs and rsk62_1_return; only trade if ksrs series reliable (SUGGESTION1). Confidence 0.56.",
      "implementation": "if_else(less(ts_count_nans(rsk62_1_100_ksrs,30), 3), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum with quantile trimming",
      "description": "Applies quantile to ts_zscore(rsk62_1_return,10) to generate Gaussian-ranked signal (SUGGESTION1). Confidence 0.66.",
      "implementation": "quantile(ts_zscore(rsk62_1_return,10), driver=\"gaussian\", sigma=1.0)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum * profitability (nipe) divided by leverage (qe2d)",
      "description": "To respect 2-datafield limit choose rsk62_risk_nipe and rsk62_risk_qe2d; multiply momentum by nipe and divide by qe2d for conservative tilt (SUGGESTION1). Both coverages high. Confidence 0.70.",
      "implementation": "divide(multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_nipe)), add(rsk62_risk_qe2d, 0.0001))",
      "confidence_level": 0.7
    },
    {
      "idea": "Momentum trailing mean reversion (ts_av_diff negative signals)",
      "description": "Uses ts_av_diff(rsk62_1_return,20) and reverse to capture names far above their recent mean (SUGGESTION1). Coverage=1. Confidence 0.65.",
      "implementation": "reverse(ts_av_diff(rsk62_1_return,20))",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum limited to high intercept stability (low intercept std)",
      "description": "Uses rsk62_1_100_intercept and ts_std_dev to allow momentum only if intercept stable. SUGGESTION1 applied. Confidence 0.59.",
      "implementation": "if_else(less(ts_std_dev(rsk62_1_100_intercept,60), 0.01), ts_zscore(rsk62_1_return,5), NaN)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum * inverse beta to mining (reduce commodity risk)",
      "description": "Combines ts_zscore(rsk62_1_return,10) and rsk62_beta_5_100_mining (coverage 0.6948>0.6) to penalize mining exposure. SUGGESTION1 applied. Confidence 0.68.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_5_100_mining))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum vs factor growth differential (growth beta)",
      "description": "Combines ts_zscore(rsk62_1_return,10) and rsk62_beta_factor_1_100_growth (userCount 22) to remove growth exposure. SUGGESTION1 applied. Confidence 0.70.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_beta_factor_1_100_growth)",
      "confidence_level": 0.7
    },
    {
      "idea": "Momentum of factor returns (factor_1_100_val40)",
      "description": "Uses rsk62_factor_1_100_val40 (userCount 14, alphaCount 192) to capture a high-alphaCount factor momentum (SUGGESTION4). Coverage=1. Confidence 0.66.",
      "implementation": "ts_zscore(rsk62_factor_1_100_val40, 20)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum filtered by sector-specific beta backfill (when coverage low)",
      "description": "Uses rsk62_beta_industry_constr_5_100_software (coverage 0.408<0.6) so apply ts_backfill to ensure continuity; combine with returns. SUGGESTION3 applied. Confidence 0.62.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), ts_backfill(rsk62_beta_industry_constr_5_100_software,60))",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum scaled by intercept (factor 5 intercept)",
      "description": "Combines ts_zscore(rsk62_5_return,20) and rsk62_factor_5_100_intercept to reduce factor-driven trades. SUGGESTION1 applied. Confidence 0.67.",
      "implementation": "divide(ts_zscore(rsk62_5_return,20), add(abs(rsk62_factor_5_100_intercept),0.0001))",
      "confidence_level": 0.67
    },
    {
      "idea": "Short-term reversal with winsorized factor intercept",
      "description": "Uses reverse(ts_zscore(rsk62_1_return,5)) and winsorize on rsk62_1_100_intercept to avoid extreme intercept influence. SUGGESTION1 applied. Confidence 0.64.",
      "implementation": "multiply(reverse(ts_zscore(rsk62_1_return,5)), inverse(winsorize(rsk62_1_100_intercept, std=4)))",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum vs retail beta backfilled",
      "description": "Uses rsk62_1_return and rsk62_beta_5_100_retail (coverage ~0.549 <0.6) so applied ts_backfill per SUGGESTION3. Then subtract to hedge retail exposure. Confidence 0.63.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), ts_backfill(rsk62_beta_5_100_retail,60))",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum * inverse industry volatility (penalize volatile industries)",
      "description": "Uses rsk62_1_return and rsk62_risk_volatility; penalize names with high volatility. SUGGESTION1 applied. Confidence 0.68.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_risk_volatility))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum ranked via ts_rank then winsorized",
      "description": "Uses ts_rank(rsk62_1_return,20) then winsorize to reduce extremes (SUGGESTION1). Simple, short implementation. Confidence 0.66.",
      "implementation": "winsorize(ts_rank(rsk62_1_return,20), std=4)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum conditional on stable logcap (low logcap ts_std_dev)",
      "description": "Uses rsk62_1_return and ts_std_dev(rsk62_logcap_di,60) to favor names with stable market cap. SUGGESTION1 applied. Confidence 0.60.",
      "implementation": "if_else(less(ts_std_dev(rsk62_logcap_di,60), 0.1), ts_zscore(rsk62_1_return,10), NaN)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with factor spread using two factor scalars",
      "description": "Uses rsk62_factor_1_100_val24 and rsk62_factor_1_100_val25 (two scalars) and subtract to get factor spread. SUGGESTION1 and SUGGESTION4 used (choose high userCount). Confidence 0.61.",
      "implementation": "subtract(rsk62_factor_1_100_val24, rsk62_factor_1_100_val25)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum * inverse bank beta to avoid financial cyclicality",
      "description": "Combines ts_zscore(rsk62_1_return,10) and rsk62_beta_1_100_banks (userCount 92) to penalize bank exposure. SUGGESTION1 used. Confidence 0.69.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), inverse(rsk62_beta_1_100_banks))",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum with quantile smoothing using ts_quantile on returns",
      "description": "Uses ts_quantile(rsk62_1_return,20) for smoother temporal rank; SUGGESTION1 applied. Confidence 0.67.",
      "implementation": "ts_quantile(rsk62_1_return,20, driver=\"gaussian\")",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum filtered by stable gross margin (low ts_std_dev of margin)",
      "description": "Uses rsk62_1_return and ts_std_dev(rsk62_risk_margin,60) to prefer firms with steady margins. SUGGESTION1 applied. Confidence 0.62.",
      "implementation": "if_else(less(ts_std_dev(rsk62_risk_margin,60), 0.05), ts_zscore(rsk62_1_return,10), NaN)",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum scaled by factor 'logadv20' intercept to reduce crowding",
      "description": "Combines ts_zscore(rsk62_1_return,10) and rsk62_5_100_intercept or rsk62_5_100_intercept (userCount 22) to penalize crowded factor moves. SUGGESTION4 used for high alphaCount intercepts. Confidence 0.64.",
      "implementation": "divide(ts_zscore(rsk62_1_return,10), add(rsk62_5_100_intercept, 0.0001))",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum of vectorized industry retseries average",
      "description": "Uses vec_avg(rsk62_retseries_industry_1_100_val10) to compute recent industry movement and then ts_zscore to get momentum (SUGGESTION2). Coverage=1. Confidence 0.60.",
      "implementation": "ts_zscore(vec_avg(rsk62_retseries_industry_1_100_val10), 20)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum neutralized to factor 1 (factor_1 scalar)",
      "description": "Combines rsk62_1_return and rsk62_factor_1_100_val68 (userCount 14) to subtract factor exposure. SUGGESTION1 applied. Confidence 0.68.",
      "implementation": "subtract(ts_zscore(rsk62_1_return,10), rsk62_factor_1_100_val68)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum * profitability (spe) with backfill",
      "description": "Uses rsk62_1_return and rsk62_risk_backfill_spe (backfilled EPS), applying SUGGESTION3 to ensure coverage. SUGGESTION1 used. Confidence 0.69.",
      "implementation": "multiply(ts_zscore(rsk62_1_return,10), zscore(rsk62_risk_backfill_spe))",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum sign persistence using ts_product and sign",
      "description": "Uses ts_product(rsk62_1_return,5) and sign to detect persistent positive runs (SUGGESTION1). Coverage=1. Confidence 0.62.",
      "implementation": "sign(ts_product(rsk62_1_return,5))",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum versus intercept spread (5-day)",
      "description": "Uses ts_mean(rsk62_5_return,5) and rsk62_5_100_intercept to remove broad factor moves. SUGGESTION1 applied. Confidence 0.66.",
      "implementation": "subtract(ts_mean(rsk62_5_return,5), rsk62_5_100_intercept)",
      "confidence_level": 0.66
    }
  ]
}