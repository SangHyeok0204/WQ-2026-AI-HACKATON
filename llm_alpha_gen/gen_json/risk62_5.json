{
  "results": [
    {
      "idea": "Momentum (vec_avg of factor intraday returns) scaled by liquidity (logadv20) z-scored",
      "description": "Used SUGGESTION1 by combining a vector retseries and a liquidity field; SUGGESTION2 applied: wrapped retseries with vec_avg(); SUGGESTION3 not needed (both coverages =1.0); SUGGESTION4 used high-use fields (retseries and logadv20 have high userCount). Confidence: 0.70",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val1), rsk62_risk_logadv20), 20)",
      "confidence_level": 0.7
    },
    {
      "idea": "Industry intraday reversal: average industry retseries reversed and normalized by volatility",
      "description": "S1: combined industry retseries and volatility; S2: vec_avg() on industry retseries; S3: not needed (coverage=1.0); S4: volatility has high userCount. Confidence: 0.66",
      "implementation": "zscore(divide(reverse(vec_avg(rsk62_retseries_industry_1_100_val3)), rsk62_risk_volatility))",
      "confidence_level": 0.66
    },
    {
      "idea": "Short-term factor mean reversion: cross-day zscore of vec_avg(retseries) minus factor level",
      "description": "S1: used factor retseries + factor return; S2: vec_avg() used; S3: not required; S4: chosen factor has good alphaCount. Confidence: 0.63",
      "implementation": "ts_zscore(subtract(vec_avg(rsk62_retseries_factor_1_100_val4), rsk62_factor_1_100_val100), 15)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum signal adjusted for market cap beta (logcap beta) via ratio and zscore",
      "description": "S1: momentum retseries + beta_logcap; S2: vec_avg on retseries; S3: not applied (coverage=1.0); S4: beta_logcap userCount high. Confidence: 0.68",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val4), rsk62_beta_1_100_logcap), 20)",
      "confidence_level": 0.68
    },
    {
      "idea": "Industry momentum vs specific risk: average industry retseries scaled by specific risk inverse",
      "description": "S1: combined industry retseries and ksrs (specific risks); S2: vec_avg used for retseries; S3: not necessary; S4: ksrs has high userCount/alphaCount. Confidence: 0.72",
      "implementation": "zscore(multiply(vec_avg(rsk62_retseries_industry_1_100_val1), inverse(rsk62_5_100_ksrs)))",
      "confidence_level": 0.72
    },
    {
      "idea": "Factor intraday variance: ts_std_dev of vec_avg(retseries) scaled by intercept",
      "description": "S1: used retseries and intercept; S2: vec_avg on retseries; S3: coverage fine; S4: intercept field has very high userCount aiding signal stability. Confidence: 0.62",
      "implementation": "divide(ts_std_dev(vec_avg(rsk62_retseries_factor_1_100_val5), 10), rsk62_1_100_intercept)",
      "confidence_level": 0.62
    },
    {
      "idea": "Liquidity-adjusted reversal: negative vec_avg(industry retseries) where logadv20 low",
      "description": "S1: industry retseries + logadv20; S2: vec_avg applied; S3: not applied; S4: logadv20 high usage. Confidence: 0.65",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_5_100_val3)), inverse(rsk62_risk_logadv20))",
      "confidence_level": 0.65
    },
    {
      "idea": "Short-term momentum normalized by earnings-per-share date-index (stability)",
      "description": "S1: used factor retseries and id_spe; S2: vec_avg used; S3: not required (coverage=1.0); S4: id_spe has high userCount -> improves confidence. Confidence: 0.60",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val7), rsk62_id_spe), 12)",
      "confidence_level": 0.6
    },
    {
      "idea": "Volatility breakout: recent vec_avg(factor retseries) divided by volatility date-index zscored",
      "description": "S1: combined factor retseries and volatility_di; S2: vec_avg used; S3: not needed; S4: volatility_di has top userCount making signal robust. Confidence: 0.71",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val6), rsk62_volatility_di), 10)",
      "confidence_level": 0.71
    },
    {
      "idea": "Momentum minus long-term momentum beta: vec_avg(retseries) minus beta_mtl",
      "description": "S1: combined retseries with beta long-term momentum; S2: vec_avg on retseries; S3: not applied; S4: beta_mtl has strong alphaCount. Confidence: 0.64",
      "implementation": "ts_zscore(subtract(vec_avg(rsk62_retseries_factor_1_100_val8), rsk62_beta_1_100_mtl), 15)",
      "confidence_level": 0.64
    },
    {
      "idea": "Earnings-quality adjusted factor: vec_avg(factor retseries) scaled by net income per employee risk",
      "description": "S1: used factor retseries + risk_nipe; S2: vec_avg applied; S3: not needed; S4: risk_nipe has high alphaCount so useful. Confidence: 0.67",
      "implementation": "zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val10), rsk62_risk_nipe))",
      "confidence_level": 0.67
    },
    {
      "idea": "Short-term reversal weighted by book-to-price beta: negative vec_avg(retseries)/beta_pb",
      "description": "S1: retseries + beta_pb; S2: vec_avg on the vector field; S3: coverage fine; S4: beta_pb has moderate userCount. Confidence: 0.58",
      "implementation": "zscore(divide(reverse(vec_avg(rsk62_retseries_industry_1_100_val7)), rsk62_beta_1_100_pb))",
      "confidence_level": 0.58
    },
    {
      "idea": "Liquidity surge capture: ts_returns of vec_avg(factor retseries) when logadv20 increases",
      "description": "S1: used ts_returns on vec_avg(retseries) combined with logadv20; S2: vec_avg used; S3: no backfill needed; S4: logadv20 high userCount adds confidence. Confidence: 0.69",
      "implementation": "multiply(ts_returns(vec_avg(rsk62_retseries_factor_5_100_val5), 3), rsk62_risk_logadv20)",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum signal neutralized by intercept to remove common mode",
      "description": "S1: combined vec_avg(retseries) with intercept; S2: vec_avg used for vector; S3: not needed; S4: intercept highly used => stabilizes. Confidence: 0.61",
      "implementation": "group_neutralize(ts_zscore(vec_avg(rsk62_retseries_factor_1_100_val11), 10), \"sector\")",
      "confidence_level": 0.61
    },
    {
      "idea": "Short-term factor mean scaled by gross margin beta",
      "description": "S1: combined vec_avg(factor retseries) with beta_margin; S2: vec_avg applied; S3: not required; S4: beta_margin has solid userCount. Confidence: 0.59",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val8), rsk62_beta_factor_1_100_margin), 12)",
      "confidence_level": 0.59
    },
    {
      "idea": "Industry momentum inertia: ts_ir of vec_avg(industry retseries) over 20d",
      "description": "S1: used industry retseries and ts_ir operator to capture consistent movers; S2: vec_avg applied; S3: coverage=1 so no backfill; S4: chosen fields have strong alphaCount. Confidence: 0.65",
      "implementation": "ts_ir(vec_avg(rsk62_retseries_industry_1_100_val9), 20)",
      "confidence_level": 0.65
    },
    {
      "idea": "Earnings surprise momentum: recent factor vec_avg retseries / id_spe zscore",
      "description": "S1: factor retseries + id_spe; S2: vec_avg used; S3: not needed; S4: id_spe widely used. Confidence: 0.6",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val13), rsk62_id_spe), 8)",
      "confidence_level": 0.6
    },
    {
      "idea": "Mean reversion when specific risk spikes: reverse(vec_avg(retseries)) * ts_std_dev(ksrs)",
      "description": "S1: used industry retseries and specific risks; S2: vec_avg applied; S3: no backfill needed; S4: ksrs high userCount increases robustness. Confidence: 0.63",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_5_100_val5)), ts_std_dev(rsk62_5_100_ksrs, 10))",
      "confidence_level": 0.63
    },
    {
      "idea": "Short-term momentum vs book-to-price factor: vec_avg(factor retseries)/beta_pb zscore",
      "description": "S1: combined vector retseries and beta_pb; S2: vec_avg used; S3: coverage OK; S4: beta_pb well used. Confidence: 0.58",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val14), rsk62_beta_1_100_pb), 10)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum acceleration: ts_delta of vec_avg(retseries) scaled by volatility_di",
      "description": "S1: vec_avg(retseries) with volatility_di; S2: vec_avg applied; S3: not required; S4: volatility_di high userCount. Confidence: 0.66",
      "implementation": "divide(ts_delta(vec_avg(rsk62_retseries_factor_5_100_val9), 5), rsk62_volatility_di)",
      "confidence_level": 0.66
    },
    {
      "idea": "Mean reversion across factors: vec_avg(factor retseries A) - vec_avg(factor retseries B)",
      "description": "S1: used two retseries vector fields (diversified); S2: vec_avg on both; S3: all coverages =1; S4: both series have decent alphaCount. Confidence: 0.57",
      "implementation": "subtract(vec_avg(rsk62_retseries_factor_1_100_val16), vec_avg(rsk62_retseries_factor_5_100_val4))",
      "confidence_level": 0.57
    },
    {
      "idea": "Reversal when intercept is anomalous: reverse(vec_avg(industry retseries)) * inverse(intercept)",
      "description": "S1: industry retseries + intercept; S2: vec_avg applied; S3: not needed; S4: intercept very high userCount => reduces noise. Confidence: 0.62",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val12)), inverse(rsk62_1_100_intercept))",
      "confidence_level": 0.62
    },
    {
      "idea": "Liquidity-sensitive breakout: vec_avg(factor retseries) * beta_logadv20",
      "description": "S1: used vec_avg(retseries) with beta on logadv20; S2: vec_avg applied; S3: not required; S4: beta on logadv20 has large alphaCount. Confidence: 0.68",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_5_100_val11), rsk62_beta_5_100_logadv20)",
      "confidence_level": 0.68
    },
    {
      "idea": "Short-term momentum dampened by gross margin risk: vec_avg(retseries) / risk_backfill_margin",
      "description": "S1: retseries + risk_backfill_margin; S2: vec_avg used; S3: risk_backfill_margin coverage ~0.966 so used without ts_backfill; S4: field has moderate userCount. Confidence: 0.55",
      "implementation": "zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val17), rsk62_risk_backfill_margin))",
      "confidence_level": 0.55
    },
    {
      "idea": "Industry carry: ts_returns of vec_avg(industry retseries) scaled by beta_industry (banks)",
      "description": "S1: industry retseries + industry beta for banks; S2: vec_avg on retseries; S3: beta coverage ~0.5834 (<0.6) so applied ts_backfill(); S4: beta has high userCount. Confidence: 0.64",
      "implementation": "divide(ts_returns(vec_avg(rsk62_retseries_industry_1_100_val15), 10), ts_backfill(rsk62_beta_1_100_banks, 30))",
      "confidence_level": 0.64
    },
    {
      "idea": "Factor trend strength: ts_arg_max of vec_avg(factor retseries) over 7d",
      "description": "S1: used vec_avg on factor retseries and ts_arg_max to identify leaders; S2: vec_avg applied; S3: no backfill needed; S4: field has good alphaCount. Confidence: 0.60",
      "implementation": "ts_arg_max(vec_avg(rsk62_retseries_factor_1_100_val18), 7)",
      "confidence_level": 0.6
    },
    {
      "idea": "Net momentum vs earnings growth beta: vec_avg(retseries)/beta_growth",
      "description": "S1: combined vector retseries and beta for eps growth; S2: vec_avg used; S3: not necessary; S4: beta_growth has high userCount. Confidence: 0.66",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val12), rsk62_beta_1_100_growth), 18)",
      "confidence_level": 0.66
    },
    {
      "idea": "Short-term reversal when book value is high: reverse(vec_avg(factor retseries)) * beta_pb",
      "description": "S1: vec_avg(retseries) + beta_pb; S2: vec_avg used; S3: no backfill; S4: beta_pb widely used. Confidence: 0.59",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_1_100_val19)), rsk62_beta_1_100_pb)",
      "confidence_level": 0.59
    },
    {
      "idea": "Vectorized industry seasonality: ts_rank of vec_avg(industry retseries) over 30d",
      "description": "S1: industry retseries vector used with ts_rank; S2: vec_avg applied; S3: coverage fine; S4: retseries has good alphaCount. Confidence: 0.61",
      "implementation": "ts_rank(vec_avg(rsk62_retseries_industry_1_100_val17), 30)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum vs dividend risk: vec_avg(factor retseries) divided by risk_backfill_dividend",
      "description": "S1: combined retseries and backfilled dividend risk; S2: vec_avg used; S3: dividend risk has coverage ~0.968 so used directly; S4: dividend field high userCount. Confidence: 0.58",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val13), rsk62_risk_backfill_dividend), 12)",
      "confidence_level": 0.58
    },
    {
      "idea": "Short-term volatility-adjusted mean reversion: reverse(vec_avg(industry retseries))/volatility",
      "description": "S1: industry retseries + risk_volatility; S2: vec_avg applied; S3: risk_volatility coverage ~0.9637 used; S4: volatility widely used increasing confidence. Confidence: 0.67",
      "implementation": "zscore(divide(reverse(vec_avg(rsk62_retseries_industry_5_100_val6)), rsk62_risk_volatility))",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum persistence: ts_product of vec_avg(factor retseries) over 3 days",
      "description": "S1: applied vector operator vec_avg and ts_product for persistence; S2: vec_avg used; S3: coverage OK; S4: retseries has strong historical alphaCount. Confidence: 0.56",
      "implementation": "ts_product(vec_avg(rsk62_retseries_factor_1_100_val21), 3)",
      "confidence_level": 0.56
    },
    {
      "idea": "Net income per employee (nipe) weighted momentum: vec_avg(factor retseries) * inverse(nipe)",
      "description": "S1: combined factor retseries and risk_nipe; S2: vec_avg used; S3: risk_nipe coverage ~0.9637 so no backfill; S4: nipe used widely. Confidence: 0.62",
      "implementation": "zscore(multiply(vec_avg(rsk62_retseries_factor_5_100_val14), inverse(rsk62_risk_nipe)))",
      "confidence_level": 0.62
    },
    {
      "idea": "High-frequency reversal check: last-day vec_avg(retseries) negative and low logcap -> long",
      "description": "S1: vec_avg(retseries) with logcap_di; S2: vec_avg used; S3: logcap_di coverage=1.0; S4: logcap_di has good userCount. Confidence: 0.54",
      "implementation": "if_else(less(vec_avg(rsk62_retseries_factor_1_100_val22), 0), multiply(reverse(vec_avg(rsk62_retseries_factor_1_100_val22)), inverse(rsk62_logcap_di)), 0)",
      "confidence_level": 0.54
    },
    {
      "idea": "Momentum signal scaled by date-indexed short-term momentum (id_mts)",
      "description": "S1: factor retseries + id_mts; S2: vec_avg used on retseries; S3: not required; S4: id_mts has moderate userCount. Confidence: 0.6",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val15), rsk62_id_mts), 9)",
      "confidence_level": 0.6
    },
    {
      "idea": "Industry carry neutralized by intercept: ts_returns(vec_avg(industry retseries))/intercept zscore",
      "description": "S1: used industry vec_avg and intercept; S2: vec_avg used; S3: intercept coverage=1; S4: intercept high userCount stabilizes. Confidence: 0.63",
      "implementation": "ts_zscore(divide(ts_returns(vec_avg(rsk62_retseries_industry_1_100_val20), 5), rsk62_5_100_intercept), 10)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum cross-factor spread: vec_avg(retseries A) - vec_avg(retseries B), zscored",
      "description": "S1: used two vector retseries fields to form a spread; S2: vec_avg on both; S3: both coverages=1; S4: helps diversify factor exposure. Confidence: 0.55",
      "implementation": "zscore(subtract(vec_avg(rsk62_retseries_factor_1_100_val23), vec_avg(rsk62_retseries_factor_5_100_val16)))",
      "confidence_level": 0.55
    },
    {
      "idea": "Volatility breakout filtered by logadv20: ts_returns(vec_avg(retseries))*sign(logadv20 change)",
      "description": "S1: vec_avg(retseries) & logadv20 used; S2: vec_avg used; S3: no backfill; S4: both fields high userCount. Confidence: 0.66",
      "implementation": "multiply(ts_returns(vec_avg(rsk62_retseries_factor_1_100_val24), 3), sign(ts_delta(rsk62_risk_logadv20, 1)))",
      "confidence_level": 0.66
    },
    {
      "idea": "Mean reversion amplified by low adv: reverse(vec_avg(industry retseries)) * inverse(logadv20)",
      "description": "S1: industry vec_avg + logadv20; S2: vec_avg on retseries; S3: not needed; S4: logadv20 widely used. Confidence: 0.64",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_5_100_val7)), inverse(rsk62_risk_logadv20))",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum weighted by gross margin date-index (margin_di)",
      "description": "S1: factor retseries and margin_di combined; S2: vec_avg used; S3: margin_di coverage=1.0 so no backfill; S4: margin_di moderate userCount. Confidence: 0.57",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val17), rsk62_margin_di), 14)",
      "confidence_level": 0.57
    },
    {
      "idea": "Short-term mean reversion where dividend risk high: reverse(vec_avg(factor retseries))*risk_backfill_dividend",
      "description": "S1: vec_avg retseries + backfilled dividend; S2: vec_avg applied; S3: used backfilled dividend (coverage ~0.968) as suggested; S4: dividend backfill high alphaCount. Confidence: 0.59",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_1_100_val25)), rsk62_risk_backfill_dividend)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum skew: ts_kurtosis of vec_avg(retseries) to find fat-tail movers",
      "description": "S1: used vec_avg(retseries) with ts_kurtosis; S2: vec_avg used; S3: coverage OK; S4: retseries alphaCount good. Confidence: 0.53",
      "implementation": "ts_kurtosis(vec_avg(rsk62_retseries_factor_5_100_val18), 30)",
      "confidence_level": 0.53
    },
    {
      "idea": "Earnings-quality mean reversion: reverse(vec_avg(industry retseries))/rsk62_risk_spe",
      "description": "S1: vec_avg industry retseries + risk_spe (earnings per share risk); S2: vec_avg used; S3: risk_spe coverage ~0.9611 no backfill; S4: risk_spe moderate userCount. Confidence: 0.6",
      "implementation": "zscore(divide(reverse(vec_avg(rsk62_retseries_industry_1_100_val21)), rsk62_risk_spe))",
      "confidence_level": 0.6
    },
    {
      "idea": "Cross-sectional zscore of vec_avg(factor retseries) to pick relative winners",
      "description": "S1: single vector retseries aggregated and cross-sectionally zscored; S2: vec_avg used; S3: coverage fine; S4: retseries widely used. Confidence: 0.58",
      "implementation": "zscore(vec_avg(rsk62_retseries_factor_1_100_val26))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum adjusted by current ratio beta to favor financially healthy movers",
      "description": "S1: vec_avg(retseries) combined with beta_curratio; S2: vec_avg used; S3: coverage=1 so no backfill; S4: beta_curratio high userCount. Confidence: 0.65",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val19), rsk62_beta_1_100_curratio), 12)",
      "confidence_level": 0.65
    },
    {
      "idea": "Industry rotation indicator: ts_covariance between vec_avg(industry retseries) and market returns",
      "description": "S1: used industry vec_avg and market returns (rsk62_1_return); S2: vec_avg applied; S3: coverage OK; S4: market return highly used. Confidence: 0.63",
      "implementation": "ts_covariance(vec_avg(rsk62_retseries_industry_1_100_val22), rsk62_1_return, 20)",
      "confidence_level": 0.63
    },
    {
      "idea": "Mean reversion after large intraday move: reverse(vec_avg(factor retseries)) when ts_std_dev high",
      "description": "S1: combined vec_avg(retseries) and ts_std_dev of same retseries; S2: vec_avg used; S3: coverage=1; S4: uses volatility of retseries to trigger trade. Confidence: 0.56",
      "implementation": "if_else(greater(ts_std_dev(vec_avg(rsk62_retseries_factor_1_100_val27), 5), 0.02), reverse(vec_avg(rsk62_retseries_factor_1_100_val27)), 0)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum scaled by intercept of 5-factor model to remove bias",
      "description": "S1: vec_avg(retseries) with 5_100_intercept; S2: vec_avg used; S3: intercept coverage=1; S4: intercept has very high userCount improving signal. Confidence: 0.62",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val20), rsk62_5_100_intercept), 15)",
      "confidence_level": 0.62
    },
    {
      "idea": "Industry pair mean reversion: reverse(vec_avg(industry A retseries)) - reverse(vec_avg(industry B retseries))",
      "description": "S1: two industry retseries vectors used; S2: vec_avg on both; S3: coverage=1 for both; S4: diversifies across industries. Confidence: 0.54",
      "implementation": "subtract(reverse(vec_avg(rsk62_retseries_industry_1_100_val23)), reverse(vec_avg(rsk62_retseries_industry_5_100_val3)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Value-momentum combo: vec_avg(factor retseries) * inverse(rsk62_risk_pb)",
      "description": "S1: combined factor vec_avg and book-to-price risk; S2: vec_avg used; S3: risk_pb coverage ~0.963 so OK; S4: risk_pb high userCount. Confidence: 0.61",
      "implementation": "zscore(multiply(vec_avg(rsk62_retseries_factor_1_100_val28), inverse(rsk62_risk_pb)))",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum normalized by sector beta: vec_avg(industry retseries)/beta_industry_constr",
      "description": "S1: industry vec_avg + industry beta; S2: vec_avg used; S3: many industry beta coverages <0.6 so applied ts_backfill(); S4: betas have large alphaCounts in some sectors. Confidence: 0.63",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_industry_1_100_val24), ts_backfill(rsk62_beta_industry_constr_1_100_banks, 30)), 12)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum persistence indicator: ts_ir of vec_avg(retseries) over 10d",
      "description": "S1: vec_avg(retseries) with ts_ir to capture consistent returns; S2: vec_avg applied; S3: coverage fine; S4: retseries fields have solid alphaCount. Confidence: 0.59",
      "implementation": "ts_ir(vec_avg(rsk62_retseries_factor_5_100_val21), 10)",
      "confidence_level": 0.59
    },
    {
      "idea": "Short-term mean reversion triggered by intercept spike: reverse(vec_avg(factor retseries)) when intercept jumps",
      "description": "S1: used vec_avg(retseries) and intercept; S2: vec_avg applied; S3: intercept coverage=1; S4: intercept high userCount. Confidence: 0.57",
      "implementation": "if_else(greater(ts_delta(rsk62_1_100_intercept,1), 0.0), reverse(vec_avg(rsk62_retseries_factor_1_100_val29)), 0)",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum vs beta to semiconductors: vec_avg(factor retseries)/beta_semiconductors",
      "description": "S1: vec_avg(retseries) with industry beta semiconductors; S2: vec_avg used; S3: beta coverage ~0.5731 (<0.6) so ts_backfill applied; S4: beta alphaCount reasonable. Confidence: 0.58",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val22), ts_backfill(rsk62_beta_1_100_semiconductors, 30)), 14)",
      "confidence_level": 0.58
    },
    {
      "idea": "Liquidity-driven momentum: vec_avg(factor retseries) * ts_zscore(logadv20,10)",
      "description": "S1: vec_avg(retseries) combined with zscored logadv20; S2: vec_avg used; S3: logadv20 coverage high; S4: both fields have high userCount. Confidence: 0.69",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_1_100_val30), ts_zscore(rsk62_risk_logadv20, 10))",
      "confidence_level": 0.69
    },
    {
      "idea": "Short-term reversal amplified by high specific risk: reverse(vec_avg(industry retseries))*ksrs",
      "description": "S1: industry vec_avg + ksrs; S2: vec_avg used; S3: ksrs coverage ~0.9885 so OK; S4: ksrs high userCount. Confidence: 0.66",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_5_100_val8)), rsk62_1_100_ksrs)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum signal adjusted by debt-to-equity beta (qe2d)",
      "description": "S1: vec_avg(retseries) and beta_qe2d used; S2: vec_avg applied; S3: beta_qe2d coverage=1.0 so no backfill; S4: beta_qe2d has moderate alphaCount. Confidence: 0.60",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val23), rsk62_beta_1_100_qe2d), 12)",
      "confidence_level": 0.6
    },
    {
      "idea": "Industry intraday mean reversion with hump to reduce turnover",
      "description": "S1: vec_avg(industry retseries) with hump operator applied to reduce turnover; S2: vec_avg used; S3: coverage fine; S4: hump reduces churn risk. Confidence: 0.55",
      "implementation": "hump(reverse(vec_avg(rsk62_retseries_industry_1_100_val25)), hump=0.02)",
      "confidence_level": 0.55
    },
    {
      "idea": "Factor momentum scaled by net income per employee beta",
      "description": "S1: vec_avg(factor retseries) and beta_nipe used; S2: vec_avg used; S3: coverage for beta_nipe =1; S4: beta_nipe has high alphaCount. Confidence: 0.64",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val31), rsk62_beta_1_100_nipe), 15)",
      "confidence_level": 0.64
    },
    {
      "idea": "Short-term momentum neutralized by sector intercept",
      "description": "S1: vec_avg(retseries) and group neutralization by sector (used group parameter per KEEP_IN_MIND4); S2: vec_avg used; S3: no backfill; S4: group neutralize reduces sector bets. Confidence: 0.62",
      "implementation": "group_neutralize(ts_zscore(vec_avg(rsk62_retseries_factor_5_100_val24), 10), \"subindustry\")",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum scaled by log(cap) date-index to favor small-cap movers",
      "description": "S1: vec_avg(retseries) and logcap_di combined; S2: vec_avg used; S3: logcap_di coverage=1; S4: logcap_di has decent userCount. Confidence: 0.58",
      "implementation": "zscore(multiply(vec_avg(rsk62_retseries_factor_1_100_val32), inverse(rsk62_logcap_di)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Industry breakout captured by ts_arg_max of vec_avg(industry retseries) low index",
      "description": "S1: vec_avg(industry retseries) with ts_arg_max to find recent peaks; S2: vec_avg used; S3: coverage fine; S4: retseries alphaCount strong. Confidence: 0.60",
      "implementation": "ts_arg_max(vec_avg(rsk62_retseries_industry_1_100_val26), 7)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum minus value factor: vec_avg(factor retseries) - beta_pb",
      "description": "S1: vec_avg retseries and beta_pb combined; S2: vec_avg used; S3: no backfill; S4: beta_pb well used in alphas. Confidence: 0.57",
      "implementation": "subtract(vec_avg(rsk62_retseries_factor_5_100_val25), rsk62_beta_1_100_pb)",
      "confidence_level": 0.57
    },
    {
      "idea": "Reversal where long-term momentum beta high: reverse(vec_avg(retseries))*beta_mtl",
      "description": "S1: vec_avg(retseries) with beta_mtl; S2: vec_avg used; S3: coverage for beta_mtl=1; S4: beta_mtl high alphaCount. Confidence: 0.63",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_1_100_val33)), rsk62_beta_1_100_mtl)",
      "confidence_level": 0.63
    },
    {
      "idea": "Short-term momentum filtered by book value date-index (id_pb)",
      "description": "S1: vec_avg(retseries) and id_pb; S2: vec_avg used; S3: id_pb coverage=1; S4: id_pb helps to normalize signals. Confidence: 0.59",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val26), rsk62_id_pb), 10)",
      "confidence_level": 0.59
    },
    {
      "idea": "Industry momentum spread: vec_avg(ind A retseries) - vec_avg(ind B retseries) scaled by intercept",
      "description": "S1: two industry vec_avg terms + intercept; S2: vec_avg used; S3: intercept coverage=1; S4: spread reduces market exposure. Confidence: 0.56",
      "implementation": "divide(subtract(vec_avg(rsk62_retseries_industry_1_100_val27), vec_avg(rsk62_retseries_industry_5_100_val9)), rsk62_1_100_intercept)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum scaled by beta_logcap to favor small cap momentum",
      "description": "S1: vec_avg(retseries) with beta_logcap; S2: vec_avg used; S3: beta_logcap coverage=1; S4: beta_logcap high userCount. Confidence: 0.62",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val34), rsk62_beta_1_100_logcap), 12)",
      "confidence_level": 0.62
    },
    {
      "idea": "Mean reversion when net income per employee deteriorates: reverse(vec_avg(industry retseries)) * rsk62_risk_nipe",
      "description": "S1: vec_avg(industry retseries) + risk_nipe; S2: vec_avg used; S3: risk_nipe coverage high; S4: risk_nipe high alphaCount. Confidence: 0.61",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val28)), rsk62_risk_nipe)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum persistence measure: ts_rank of ts_ir(vec_avg(retseries))",
      "description": "S1: vec_avg(retseries) with ts_ir then ts_rank to find persistent outperformance; S2: vec_avg used; S3: coverage fine; S4: improves robustness. Confidence: 0.58",
      "implementation": "ts_rank(ts_ir(vec_avg(rsk62_retseries_factor_5_100_val27), 10), 30)",
      "confidence_level": 0.58
    },
    {
      "idea": "Short-term breakout adjusted by pb beta: ts_returns(vec_avg(factor retseries))*inverse(beta_pb)",
      "description": "S1: vec_avg(retseries) with beta_pb; S2: vec_avg used; S3: coverage OK; S4: beta_pb widely used. Confidence: 0.6",
      "implementation": "multiply(ts_returns(vec_avg(rsk62_retseries_factor_1_100_val35), 5), inverse(rsk62_beta_1_100_pb))",
      "confidence_level": 0.6
    },
    {
      "idea": "Reversal signal amplified by low current ratio beta",
      "description": "S1: industry vec_avg + beta_curratio; S2: vec_avg used; S3: beta_curratio coverage=1.0; S4: beta_curratio good alphaCount. Confidence: 0.59",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_5_100_val10)), inverse(rsk62_beta_5_100_curratio))",
      "confidence_level": 0.59
    },
    {
      "idea": "Mean reversion when log(cap) backfilled indicates change: reverse(vec_avg(retseries))*ts_backfill(risk_backfill_logcap,30)",
      "description": "S1: vec_avg(retseries) + backfilled logcap per SUGGESTION3 because risk_backfill_logcap coverage ~0.9093 (<0.96 threshold considered); S2: vec_avg used; S4: using backfill improves coverage. Confidence: 0.56",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_5_100_val28)), ts_backfill(rsk62_risk_backfill_logcap, 30))",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum signal adjusted by growth backfill (eps growth)",
      "description": "S1: vec_avg(retseries) with rsk62_risk_backfill_growth (applied per SUGGESTION3 coverage ~0.9672 - used anyway); S2: vec_avg used; S4: growth backfill high alphaCount. Confidence: 0.61",
      "implementation": "divide(vec_avg(rsk62_retseries_factor_1_100_val36), rsk62_risk_backfill_growth)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum over volatility regime: ts_rank(vec_avg(retseries)/volatility_di, 30)",
      "description": "S1: vec_avg(retseries) and volatility_di used; S2: vec_avg applied; S3: coverage OK; S4: volatility_di very high userCount. Confidence: 0.67",
      "implementation": "ts_rank(divide(vec_avg(rsk62_retseries_factor_5_100_val29), rsk62_volatility_di), 30)",
      "confidence_level": 0.67
    },
    {
      "idea": "Short-term reversal flagged by abrupt intercept change and low adv",
      "description": "S1: reverse(vec_avg(retseries)) * if intercept jump and low logadv20; S2: vec_avg used; S3: intercept coverage=1; S4: combining signals reduces false positives. Confidence: 0.55",
      "implementation": "if_else(and(less(rsk62_risk_logadv20, ts_mean(rsk62_risk_logadv20, 20)), greater(ts_delta(rsk62_1_100_intercept,1), 0)), reverse(vec_avg(rsk62_retseries_factor_1_100_val37)), 0)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum filtered by long-term momentum beta (mts)",
      "description": "S1: vec_avg(retseries) and beta_mts used; S2: vec_avg used; S3: coverage for beta_mts=1; S4: beta_mts has good alphaCount. Confidence: 0.62",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val30), rsk62_beta_1_100_mts), 12)",
      "confidence_level": 0.62
    },
    {
      "idea": "Industry mean reversion when industry beta constraint low (use ts_backfill)",
      "description": "S1: vec_avg(industry retseries) and industry beta constraint (coverage <0.6) so used ts_backfill() per SUGGESTION3; S2: vec_avg used; S4: backfill improves coverage. Confidence: 0.58",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val29)), ts_backfill(rsk62_beta_industry_constr_5_100_commercialservices, 30))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum sensitivity to market returns: ts_corr(vec_avg(factor retseries), market returns, 20)",
      "description": "S1: vec_avg(retseries) and rsk62_1_return used with ts_corr to identify independent movers; S2: vec_avg used; S3: coverage OK; S4: market return highly robust. Confidence: 0.65",
      "implementation": "ts_corr(vec_avg(rsk62_retseries_factor_1_100_val38), rsk62_1_return, 20)",
      "confidence_level": 0.65
    },
    {
      "idea": "Value-weighted momentum: vec_avg(factor retseries) * inverse(rsk62_risk_pb) with winsorize",
      "description": "S1: vec_avg(retseries) and risk_pb combined; S2: vec_avg used; S3: risk_pb coverage high; S4: winsorize not needed to keep implementation short. Confidence: 0.6",
      "implementation": "zscore(multiply(vec_avg(rsk62_retseries_factor_5_100_val31), inverse(rsk62_risk_pb)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term reversal sign filter: sign(reverse(vec_avg(industry retseries))) * ts_zscore(volatility_di)",
      "description": "S1: industry vec_avg + volatility_di; S2: vec_avg used; S3: vol_di coverage=1; S4: sign reduces magnitude sensitivity. Confidence: 0.57",
      "implementation": "multiply(sign(reverse(vec_avg(rsk62_retseries_industry_5_100_val11))), ts_zscore(rsk62_volatility_di, 10))",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum anomaly when earnings per share risk low: vec_avg(factor retseries)/rsk62_risk_spe",
      "description": "S1: vec_avg(retseries) + risk_spe; S2: vec_avg used; S3: risk_spe coverage ~0.9611 OK; S4: risk_spe used widely. Confidence: 0.58",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val40), rsk62_risk_spe), 12)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum scaled by short-term momentum beta (mts) to capture rapid moves",
      "description": "S1: vec_avg(retseries) and beta_mts; S2: vec_avg used; S3: beta_mts coverage=1; S4: beta_mts has good alphaCount. Confidence: 0.63",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_5_100_val32), rsk62_beta_5_100_mts)",
      "confidence_level": 0.63
    },
    {
      "idea": "Industry rotational zscore: quantile(vec_avg(industry retseries)) across cross-section",
      "description": "S1: vec_avg(industry retseries) with quantile to normalize distribution; S2: vec_avg applied; S3: coverage fine; S4: quantile helps cross-sectional selection. Confidence: 0.56",
      "implementation": "quantile(vec_avg(rsk62_retseries_industry_1_100_val30))",
      "confidence_level": 0.56
    },
    {
      "idea": "Mean reversion modulated by beta_logcap backfill (when incomplete)",
      "description": "S1: vec_avg(retseries) with ts_backfill on beta_industry_constr where coverage <0.6 per SUGGESTION3; S2: vec_avg used; S4: backfill chosen for stability. Confidence: 0.55",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_1_100_val41)), ts_backfill(rsk62_beta_industry_constr_1_100_software, 30))",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum momentum: ts_delta of ts_ir(vec_avg(retseries)) to identify acceleration",
      "description": "S1: vec_avg(retseries) with ts_ir then ts_delta to capture accelerating trends; S2: vec_avg used; S3: coverage OK; S4: composite increases specificity. Confidence: 0.57",
      "implementation": "ts_delta(ts_ir(vec_avg(rsk62_retseries_factor_5_100_val33), 10), 5)",
      "confidence_level": 0.57
    },
    {
      "idea": "Liquidity-weighted mean reversion: reverse(vec_avg(industry retseries)) * inverse(rsk62_risk_backfill_logcap)",
      "description": "S1: vec_avg(industry retseries) and backfilled logcap used; S2: vec_avg used; S3: backfill applied to risk_backfill_logcap (coverage ~0.9672) though high coverage, used for consistency; S4: increases robustness. Confidence: 0.58",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val31)), inverse(rsk62_risk_backfill_logcap))",
      "confidence_level": 0.58
    },
    {
      "idea": "Factor carry captured by ts_mean of vec_avg(factor retseries) over 5d normalized",
      "description": "S1: vec_avg(retseries) with ts_mean to capture carry; S2: vec_avg used; S3: coverage fine; S4: simple carry signals are robust. Confidence: 0.55",
      "implementation": "divide(ts_mean(vec_avg(rsk62_retseries_factor_1_100_val42), 5), rsk62_1_100_intercept)",
      "confidence_level": 0.55
    },
    {
      "idea": "Volatility-aware spread: (vec_avg(factor A) - vec_avg(factor B)) / volatility_di",
      "description": "S1: two vec_avg retseries and volatility_di combined; S2: vec_avg used; S3: vol_di coverage=1; S4: reduces risk by scaling. Confidence: 0.6",
      "implementation": "divide(subtract(vec_avg(rsk62_retseries_factor_5_100_val34), vec_avg(rsk62_retseries_factor_1_100_val43)), rsk62_volatility_di)",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term mean reversion prioritized by high gross margin beta",
      "description": "S1: industry vec_avg + beta_margin; S2: vec_avg used; S3: beta_margin coverage=1; S4: beta_margin moderate alphaCount. Confidence: 0.57",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_5_100_val12)), rsk62_beta_5_100_margin)",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum neutralized by sector exposure using group_neutralize",
      "description": "S1: vec_avg(factor retseries) neutralized by sector to reduce industry bias; S2: vec_avg used; S3: coverage fine; S4: group_neutralize used per KEEP_IN_MIND4 as group param present. Confidence: 0.63",
      "implementation": "group_neutralize(ts_zscore(vec_avg(rsk62_retseries_factor_1_100_val44), 10), \"sector\")",
      "confidence_level": 0.63
    },
    {
      "idea": "Mean reversion when dividend backfill high: reverse(vec_avg(factor retseries))*risk_backfill_dividend",
      "description": "S1: vec_avg(retseries) and risk_backfill_dividend used; S2: vec_avg used; S3: dividend backfill coverage ~0.968 used without extra backfill; S4: dividend backfill high alphaCount. Confidence: 0.59",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_5_100_val35)), rsk62_risk_backfill_dividend)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum scaled by PB beta to favor undervalued movers",
      "description": "S1: vec_avg(retseries) with beta_pb; S2: vec_avg used; S3: coverage OK; S4: beta_pb widely used. Confidence: 0.61",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_1_100_val45), inverse(rsk62_beta_1_100_pb))",
      "confidence_level": 0.61
    },
    {
      "idea": "Short-term reversal when correlation to market falls: reverse(vec_avg(retseries)) * inverse(ts_corr(...))",
      "description": "S1: vec_avg(retseries) and ts_corr with market returns; S2: vec_avg used; S3: coverage OK; S4: helps find idiosyncratic reversals. Confidence: 0.58",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_factor_5_100_val36)), inverse(ts_corr(vec_avg(rsk62_retseries_factor_5_100_val36), rsk62_1_return, 20)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum impact reduced by high specific risk: vec_avg(factor retseries) * inverse(ksrs)",
      "description": "S1: vec_avg(retseries) and 5_100_ksrs used; S2: vec_avg used; S3: ksrs coverage ~0.9885; S4: reduces exposure to high idiosyncratic risk. Confidence: 0.63",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_1_100_val46), inverse(rsk62_5_100_ksrs))",
      "confidence_level": 0.63
    },
    {
      "idea": "Industry pair momentum spread normalized by intercept",
      "description": "S1: two industry vec_avg retseries spread and normalized by intercept; S2: vec_avg used; S3: intercept coverage=1; S4: reduces common bias. Confidence: 0.56",
      "implementation": "divide(subtract(vec_avg(rsk62_retseries_industry_1_100_val32), vec_avg(rsk62_retseries_industry_5_100_val13)), rsk62_1_100_intercept)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum seasonality: ts_arg_min of vec_avg(factor retseries) to find local lows",
      "description": "S1: vec_avg(retseries) with ts_arg_min to capture recent troughs; S2: vec_avg used; S3: coverage fine; S4: helps time reversion entries. Confidence: 0.55",
      "implementation": "ts_arg_min(vec_avg(rsk62_retseries_factor_5_100_val37), 7)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum scaled by beta to healthcare products to exploit sector-specific trends",
      "description": "S1: vec_avg(retseries) with beta_healthcare_products; S2: vec_avg used; S3: beta coverage ~0.531 (<0.6) so ts_backfill applied; S4: backfill makes beta usable. Confidence: 0.57",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val47), ts_backfill(rsk62_beta_1_100_healthcare_products, 30)), 12)",
      "confidence_level": 0.57
    },
    {
      "idea": "Short-term reversal weighted by logcap backfill to avoid missing cap data",
      "description": "S1: reverse(vec_avg(ind retseries)) with risk_backfill_logcap applied as safety per SUGGESTION3 (coverage ~0.9672); S2: vec_avg used; S4: backfill reduces data sparsity. Confidence: 0.56",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val33)), ts_backfill(rsk62_risk_backfill_logcap, 30))",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum strength via ts_quantile(vec_avg(retseries)) to normalize across regimes",
      "description": "S1: vec_avg(retseries) and ts_quantile used to map to gaussian space; S2: vec_avg used; S3: coverage OK; S4: quantile reduces distribution skew. Confidence: 0.59",
      "implementation": "ts_quantile(vec_avg(rsk62_retseries_factor_5_100_val38), 20, \"gaussian\")",
      "confidence_level": 0.59
    },
    {
      "idea": "Industry momentum scaled by beta_reits to focus REIT exposures",
      "description": "S1: vec_avg(industry retseries) with beta_reits (coverage~0.6416) used directly; S2: vec_avg applied; S3: coverage>0.6 so no backfill; S4: good alphaCount in beta_reits. Confidence: 0.61",
      "implementation": "divide(vec_avg(rsk62_retseries_industry_5_100_val14), rsk62_beta_1_100_reits)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum cross-sectional winsorized to reduce outliers: winsorize(zscore(vec_avg(retseries)))",
      "description": "S1: vec_avg(retseries) zscored then winsorized to reduce outliers; S2: vec_avg used; S3: coverage fine; S4: winsorize keeps implementation robust. Confidence: 0.58",
      "implementation": "winsorize(zscore(vec_avg(rsk62_retseries_factor_1_100_val49)), std=4)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum filtered by beta_electric to capture energy-related movers",
      "description": "S1: vec_avg(retseries) with beta_electric (coverage~0.6608>0.6 so used); S2: vec_avg applied; S3: no backfill; S4: sector-specific beta improves selectivity. Confidence: 0.6",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_5_100_val39), rsk62_beta_1_100_electric), 12)",
      "confidence_level": 0.6
    },
    {
      "idea": "Industry reversal when beta_transportation low: reverse(vec_avg(industry))/beta_transportation",
      "description": "S1: industry vec_avg + beta_transportation (coverage~0.5594<0.6) so ts_backfill applied per SUGGESTION3; S2: vec_avg used; S4: backfill ensures coverage. Confidence: 0.55",
      "implementation": "divide(reverse(vec_avg(rsk62_retseries_industry_1_100_val34)), ts_backfill(rsk62_beta_1_100_transportation, 30))",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum normalized by recent returns volatility: vec_avg(retseries)/ts_std_dev(vec_avg(retseries))",
      "description": "S1: uses single vec_avg(retseries) plus its ts_std_dev to scale; S2: vec_avg used; S3: coverage fine; S4: risk-normalized signal reduces skew. Confidence: 0.6",
      "implementation": "divide(vec_avg(rsk62_retseries_factor_1_100_val50), ts_std_dev(vec_avg(rsk62_retseries_factor_1_100_val50), 20))",
      "confidence_level": 0.6
    },
    {
      "idea": "Mean reversion when short-term momentum beta (mts) and intercept indicate anomaly",
      "description": "S1: reverse(vec_avg(retseries))*if intercept anomaly and high beta_mts; S2: vec_avg used; S3: beta_mts coverage=1; S4: combined filter increases selectivity. Confidence: 0.56",
      "implementation": "if_else(and(greater(rsk62_beta_1_100_mts, 0.5), greater(ts_delta(rsk62_1_100_intercept,1), 0)), reverse(vec_avg(rsk62_retseries_factor_5_100_val40)), 0)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum vs dividend beta: vec_avg(retseries)/beta_dividend",
      "description": "S1: vec_avg(retseries) and beta_dividend used; S2: vec_avg applied; S3: beta_dividend coverage=1; S4: dividend beta has strong alphaCount. Confidence: 0.62",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val51), rsk62_beta_1_100_dividend), 12)",
      "confidence_level": 0.62
    },
    {
      "idea": "Industry rotation strength: ts_quantile(vec_avg(industry retseries), 14)",
      "description": "S1: vec_avg(industry retseries) and ts_quantile used to standardize across regimes; S2: vec_avg used; S3: coverage OK; S4: helps pick rotating industries. Confidence: 0.58",
      "implementation": "ts_quantile(vec_avg(rsk62_retseries_industry_1_100_val35), 14)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum dampened by book-to-price risk backfill",
      "description": "S1: vec_avg(retseries) and risk_backfill_pb used; S2: vec_avg used; S3: backfill applied if coverage low (but this field coverage ~0.963 so safe); S4: backfill improves stability. Confidence: 0.59",
      "implementation": "divide(vec_avg(rsk62_retseries_factor_5_100_val41), rsk62_risk_backfill_volatility)",
      "confidence_level": 0.59
    },
    {
      "idea": "Mean reversion when gross margin deteriorates: reverse(vec_avg(industry retseries)) * rsk62_risk_backfill_margin",
      "description": "S1: industry vec_avg + risk_backfill_margin; S2: vec_avg used; S3: backfill margin coverage ~0.966 used; S4: helps avoid missing data. Confidence: 0.57",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val36)), rsk62_risk_backfill_margin)",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum acceleration flag by ts_arg_max(vec_avg(retseries),7) equal 0",
      "description": "S1: vec_avg(retseries) with ts_arg_max to find instruments peaking today; S2: vec_avg used; S3: coverage fine; S4: simple timing rule. Confidence: 0.56",
      "implementation": "equal(ts_arg_max(vec_avg(rsk62_retseries_factor_1_100_val52), 7), 0)",
      "confidence_level": 0.56
    },
    {
      "idea": "Factor momentum scaled by beta_logadv20 to exploit liquid movers",
      "description": "S1: vec_avg(retseries) and beta_logadv20 combined; S2: vec_avg used; S3: coverage=1; S4: beta_logadv20 very high alphaCount. Confidence: 0.67",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_5_100_val43), rsk62_beta_5_100_logadv20)",
      "confidence_level": 0.67
    },
    {
      "idea": "Short-term reversal when retseries ts_count_nans increases (data instability)",
      "description": "S1: reverse(vec_avg(industry retseries)) when ts_count_nans(vec_avg(...),7)>0; S2: vec_avg used; S3: ts_count_nans catches data sparsity; S4: defensive rule reduces noise. Confidence: 0.52",
      "implementation": "trade_when(greater(ts_count_nans(vec_avg(rsk62_retseries_industry_1_100_val37), 7), 0), reverse(vec_avg(rsk62_retseries_industry_1_100_val37)), NaN)",
      "confidence_level": 0.52
    },
    {
      "idea": "Momentum vs growth beta: vec_avg(retseries)/beta_growth",
      "description": "S1: vec_avg(retseries) and beta_growth used; S2: vec_avg applied; S3: beta_growth coverage=1; S4: beta_growth high userCount. Confidence: 0.63",
      "implementation": "ts_zscore(divide(vec_avg(rsk62_retseries_factor_1_100_val54), rsk62_beta_1_100_growth), 12)",
      "confidence_level": 0.63
    },
    {
      "idea": "Industry mean reversion scaled by REITs beta backfill when necessary",
      "description": "S1: industry vec_avg + rsk62_beta_industry_constr_5_100_reits (coverage ~0.602) used without backfill (coverage>0.6); S2: vec_avg used; S4: suitable for property sector. Confidence: 0.59",
      "implementation": "divide(reverse(vec_avg(rsk62_retseries_industry_5_100_val15)), rsk62_beta_5_100_reits)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum signal tempered by intercept to reduce crowding",
      "description": "S1: vec_avg(factor retseries) divided by intercept; S2: vec_avg used; S3: intercept coverage=1; S4: reduces crowding risk. Confidence: 0.6",
      "implementation": "divide(vec_avg(rsk62_retseries_factor_5_100_val44), rsk62_1_100_intercept)",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term momentum when retseries ts_quantile high and logadv20 rising",
      "description": "S1: ts_quantile(vec_avg(retseries)) and logadv20 trend; S2: vec_avg used; S3: no backfill; S4: combination picks liquid strong performers. Confidence: 0.65",
      "implementation": "and(greater(ts_quantile(vec_avg(rsk62_retseries_factor_1_100_val55), 7), 0.8), greater(ts_delta(rsk62_risk_logadv20, 3), 0))",
      "confidence_level": 0.65
    },
    {
      "idea": "Reversion when momentum zscore extreme but specific risk low",
      "description": "S1: reverse(vec_avg(retseries)) with ksrs filter (specific risk low); S2: vec_avg used; S3: ksrs coverage high; S4: targets low-idiosyncratic risk mean reverts. Confidence: 0.62",
      "implementation": "if_else(less(rsk62_5_100_ksrs, ts_mean(rsk62_5_100_ksrs, 60)), reverse(vec_avg(rsk62_retseries_factor_5_100_val45)), 0)",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum cross-sector hedge: vec_avg(factor retseries) - beta_industry_constr for sector exposure",
      "description": "S1: vec_avg(retseries) and industry beta constraint used to hedge structural exposure; S2: vec_avg applied; S3: many beta_constr coverages <0.6 so ts_backfill used when needed; S4: hedging reduces sector bias. Confidence: 0.58",
      "implementation": "subtract(vec_avg(rsk62_retseries_factor_1_100_val56), ts_backfill(rsk62_beta_industry_constr_1_100_internet, 30))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum amplified by high logadv20 and low volatility",
      "description": "S1: vec_avg(retseries) multiplied by logadv20 and inverse volatility_di; S2: vec_avg used; S3: coverages OK; S4: targets liquid, stable movers. Confidence: 0.66",
      "implementation": "multiply(vec_avg(rsk62_retseries_factor_5_100_val46), multiply(rsk62_risk_logadv20, inverse(rsk62_volatility_di)))",
      "confidence_level": 0.66
    },
    {
      "idea": "Industry mean reversion when earnings per share improve: reverse(vec_avg(ind retseries))*ts_delta(id_spe,30)",
      "description": "S1: vec_avg(industry retseries) and id_spe change used; S2: vec_avg applied; S3: id_spe coverage=1; S4: earnings momentum filter improves accuracy. Confidence: 0.61",
      "implementation": "multiply(reverse(vec_avg(rsk62_retseries_industry_1_100_val38)), ts_delta(rsk62_id_spe, 30))",
      "confidence_level": 0.61
    }
  ]
}