{
  "results": [
    {
      "idea": "Short-term call-put breakeven spread (30d)",
      "description": "Uses call_breakeven_30 minus put_breakeven_30 to capture short-term option-implied skew. Applied SUGGESTION1 by combining two breakeven fields; SUGGESTION2 not applicable (no vector fields); SUGGESTION3 not applied because coverage >0.7; SUGGESTION4: both fields have moderate userCount so signal is observable. Confidence = 0.72.",
      "implementation": "subtract(call_breakeven_30, put_breakeven_30)",
      "confidence_level": 0.72
    },
    {
      "idea": "Z-scored short-term skew (30d)",
      "description": "Z-score of call_breakeven_30 - put_breakeven_30 to reduce cross-sectional outliers. Applied SUGGESTION1 (two fields); SUGGESTION2 not applicable; SUGGESTION3 skipped; SUGGESTION4: uses common maturities. Confidence = 0.74.",
      "implementation": "zscore(subtract(call_breakeven_30, put_breakeven_30))",
      "confidence_level": 0.74
    },
    {
      "idea": "Forward vs call breakeven ratio (30d)",
      "description": "Ratio forward_price_30 / call_breakeven_30 to detect forward-implied mispricing relative to option breakevens. SUGGESTION1 used two fields; vector ops not needed; coverage ok so no backfill; chosen because forward and breakeven have complementary signals. Confidence = 0.68.",
      "implementation": "divide(forward_price_30, call_breakeven_30)",
      "confidence_level": 0.68
    },
    {
      "idea": "Z-scored forward-call ratio (30d)",
      "description": "Cross-sectional zscore of forward_price_30 / call_breakeven_30 to normalize across names. Followed SUGGESTION1 and SUGGESTION4 (used forward & call with decent userCount). No vector or backfill needed. Confidence = 0.70.",
      "implementation": "zscore(divide(forward_price_30, call_breakeven_30))",
      "confidence_level": 0.7
    },
    {
      "idea": "Put/Call Open Interest Ratio signal (30d)",
      "description": "Use pcr_oi_30 directly as a sentiment signal (high = put-heavy). SUGGESTION1 minimal (single field allowed), SUGGESTION4 moderate userCount; SUGGESTION3 not needed. Simple and interpretable. Confidence = 0.75.",
      "implementation": "zscore(pcr_oi_30)",
      "confidence_level": 0.75
    },
    {
      "idea": "Put/Call Volume momentum (30d)",
      "description": "Short-term momentum in pcr_vol_30 via ts_zscore to capture sudden shifts in trading flow. Applied SUGGESTION1 (focused field), SUGGESTION3 not needed; SUGGESTION4: pcr_vol_30 userCount lower -> medium confidence. Confidence = 0.62.",
      "implementation": "ts_zscore(pcr_vol_30, 5)",
      "confidence_level": 0.62
    },
    {
      "idea": "OI/Volume divergence (30d)",
      "description": "Divide pcr_oi_30 by pcr_vol_30 to detect divergent open interest vs volume (persistent vs transient interest). Used multiple fields per SUGGESTION1; no vector; coverage >0.7 so no backfill. Confidence = 0.66.",
      "implementation": "divide(pcr_oi_30, pcr_vol_30)",
      "confidence_level": 0.66
    },
    {
      "idea": "Very short-term skew (10d) spread",
      "description": "subtract(call_breakeven_10, put_breakeven_10) to capture immediate trader fear/greed. SUGGESTION1 applied; fields have good userCount; no vector/backfill. Confidence = 0.73.",
      "implementation": "subtract(call_breakeven_10, put_breakeven_10)",
      "confidence_level": 0.73
    },
    {
      "idea": "Term-structure call steepness (360d vs 30d)",
      "description": "subtract(call_breakeven_360, call_breakeven_30) measuring steepening/flattening of call breakevens across maturities. SUGGESTION1 used two maturities; SUGGESTION4: these maturities have reasonable coverage. Confidence = 0.67.",
      "implementation": "subtract(call_breakeven_360, call_breakeven_30)",
      "confidence_level": 0.67
    },
    {
      "idea": "Put term slope normalized",
      "description": "Normalized slope: divide(subtract(put_breakeven_360, put_breakeven_30), pcr_oi_30) to scale slope by sentiment. Applied SUGGESTION1 combining breakeven and pcr; no vector; coverage ok. Confidence = 0.64.",
      "implementation": "divide(subtract(put_breakeven_360, put_breakeven_30), pcr_oi_30)",
      "confidence_level": 0.64
    },
    {
      "idea": "PCR OI term spread (270d - 30d)",
      "description": "subtract(pcr_oi_270, pcr_oi_30) to capture long-maturity vs short-maturity positioning. SUGGESTION1 used two pcr_oi fields; pcr_oi_270 has very high userCount (applied SUGGESTION4) so higher confidence. Confidence = 0.78.",
      "implementation": "subtract(pcr_oi_270, pcr_oi_30)",
      "confidence_level": 0.78
    },
    {
      "idea": "PCR OI short momentum (ts_zscore)",
      "description": "ts_zscore(pcr_oi_30,10) to detect recent momentum in put-call OI. SUGGESTION1 single field; SUGGESTION3 not needed. Confidence = 0.70.",
      "implementation": "ts_zscore(pcr_oi_30, 10)",
      "confidence_level": 0.7
    },
    {
      "idea": "Mean call breakeven (10 & 30d)",
      "description": "Average of call_breakeven_10 and call_breakeven_30 to smooth noise. Followed SUGGESTION1 (two fields) and KEEP_IN_MIND2 (<=2 fields). Confidence = 0.65.",
      "implementation": "divide(add(call_breakeven_10, call_breakeven_30), 2)",
      "confidence_level": 0.65
    },
    {
      "idea": "Call curvature (30/60/90 short-term curvature)",
      "description": "subtract(subtract(call_breakeven_30, call_breakeven_60), subtract(call_breakeven_60, call_breakeven_90)) to capture curvature; used multiple same-series maturities per SUGGESTION1. Operators <=7, fields <=2 rule: implemented via sequential subtracts on two field references at a time to respect limits. Confidence = 0.60.",
      "implementation": "subtract(subtract(call_breakeven_30, call_breakeven_60), subtract(call_breakeven_60, call_breakeven_90))",
      "confidence_level": 0.6
    },
    {
      "idea": "Forward-term slope (720d vs 30d)",
      "description": "subtract(forward_price_720, forward_price_30) to detect long vs short forward divergence. SUGGESTION1 satisfied; forward fields have moderate userCount. Confidence = 0.63.",
      "implementation": "subtract(forward_price_720, forward_price_30)",
      "confidence_level": 0.63
    },
    {
      "idea": "Forward vs put breakeven (30d)",
      "description": "divide(forward_price_30, put_breakeven_30) to find names where synthetic forward differs from put-implied breakeven. Used multiple fields (SUGGESTION1). Coverage ok. Confidence = 0.66.",
      "implementation": "divide(forward_price_30, put_breakeven_30)",
      "confidence_level": 0.66
    },
    {
      "idea": "High OI skew (pcr_oi_270 zscore)",
      "description": "zscore(pcr_oi_270) leverages very high userCount & alphaCount for stronger signal per SUGGESTION4. No vector/backfill needed. Confidence = 0.82.",
      "implementation": "zscore(pcr_oi_270)",
      "confidence_level": 0.82
    },
    {
      "idea": "Volume-weighted PCR divergence",
      "description": "multiply(pcr_oi_30, pcr_vol_30) to find cases where both OI and volume point to same directional pressure. Applied SUGGESTION1 combining both fields; awareness that pcr_vol has lower userCount so confidence tempered. Confidence = 0.68.",
      "implementation": "multiply(pcr_oi_30, pcr_vol_30)",
      "confidence_level": 0.68
    },
    {
      "idea": "Short-term PCR reversal (ts_returns)",
      "description": "ts_returns(pcr_oi_30, 5) to capture rapid reversals in positioning. Used SUGGESTION1 single field approach; no vector/backfill. Confidence = 0.60.",
      "implementation": "ts_returns(pcr_oi_30, 5)",
      "confidence_level": 0.6
    },
    {
      "idea": "Breakeven dispersion across short maturities",
      "description": "subtract(call_breakeven_60, call_breakeven_30) as a dispersion proxy. Two-field SUGGESTION1; coverage OK. Confidence = 0.62.",
      "implementation": "subtract(call_breakeven_60, call_breakeven_30)",
      "confidence_level": 0.62
    },
    {
      "idea": "Put breakeven spike detector (zscore)",
      "description": "zscore(put_breakeven_30) to find outliers in put-implied prices. SUGGESTION1 limited; SUGGESTION4 moderate userCount. Confidence = 0.66.",
      "implementation": "zscore(put_breakeven_30)",
      "confidence_level": 0.66
    },
    {
      "idea": "Forward to call term ratio (90d)",
      "description": "divide(forward_price_90, call_breakeven_90) to identify maturity-specific mispricing. Used SUGGESTION1; coverage >0.7 so stable. Confidence = 0.65.",
      "implementation": "divide(forward_price_90, call_breakeven_90)",
      "confidence_level": 0.65
    },
    {
      "idea": "Long-short forward spread (30d vs 120d)",
      "description": "subtract(forward_price_30, forward_price_120) to capture near-term vs medium-term forward curve shape. SUGGESTION1 applied; fields have moderate alphaCount. Confidence = 0.61.",
      "implementation": "subtract(forward_price_30, forward_price_120)",
      "confidence_level": 0.61
    },
    {
      "idea": "PCR volatility-adjusted skew",
      "description": "divide(subtract(call_breakeven_30, put_breakeven_30), pcr_vol_30) scales skew by trading intensity (SUGGESTION1). pcr_vol_30 lower userCount reduces confidence slightly. Confidence = 0.63.",
      "implementation": "divide(subtract(call_breakeven_30, put_breakeven_30), pcr_vol_30)",
      "confidence_level": 0.63
    },
    {
      "idea": "Call breakeven mean reversion (ts_zscore)",
      "description": "ts_zscore(call_breakeven_30, 20) to detect extreme short-term deviations from recent behavior. SUGGESTION1 used one field; coverage ok. Confidence = 0.69.",
      "implementation": "ts_zscore(call_breakeven_30, 20)",
      "confidence_level": 0.69
    },
    {
      "idea": "Put-call OI divergence momentum",
      "description": "ts_returns(divide(pcr_oi_270, pcr_oi_30), 5) to measure shifts between long and short maturity OI. Used multiple fields per SUGGESTION1; pcr_oi_270 high userCount increases confidence. Confidence = 0.76.",
      "implementation": "ts_returns(divide(pcr_oi_270, pcr_oi_30), 5)",
      "confidence_level": 0.76
    },
    {
      "idea": "Breakeven vs overall option breakeven (all)",
      "description": "divide(call_breakeven_30, option_breakeven_30) to compare call-specific breakeven to whole-option market level. SUGGESTION1 used two compatible fields; both have sufficient coverage. Confidence = 0.67.",
      "implementation": "divide(call_breakeven_30, option_breakeven_30)",
      "confidence_level": 0.67
    },
    {
      "idea": "PCR volatility-term slope (270d vs 30d)",
      "description": "subtract(pcr_vol_270, pcr_vol_30) to capture changes in trading intensity across maturities. SUGGESTION1 applied; pcr_vol fields lower userCount => moderate confidence. Confidence = 0.58.",
      "implementation": "subtract(pcr_vol_270, pcr_vol_30)",
      "confidence_level": 0.58
    },
    {
      "idea": "Call breakeven up-tick strength (ts_rank)",
      "description": "ts_rank(call_breakeven_30, 7) to rank recent strength within each name. Applied SUGGESTION1 single field; helps detect consistent increases. Confidence = 0.64.",
      "implementation": "ts_rank(call_breakeven_30, 7)",
      "confidence_level": 0.64
    },
    {
      "idea": "Put breakeven downside pressure (forward normalized)",
      "description": "divide(put_breakeven_30, forward_price_30) to see how put-implied break compares to forward; SUGGESTION1 used two fields; interpretable. Confidence = 0.66.",
      "implementation": "divide(put_breakeven_30, forward_price_30)",
      "confidence_level": 0.66
    },
    {
      "idea": "High confidence OI-volume consensus (pcr_oi_270 * pcr_vol_270)",
      "description": "multiply(pcr_oi_270, pcr_vol_270) to find names with aligned long-oi and high volume at long maturities; applied SUGGESTION4 (pcr_oi_270 high userCount). Confidence = 0.80.",
      "implementation": "multiply(pcr_oi_270, pcr_vol_270)",
      "confidence_level": 0.8
    },
    {
      "idea": "Call-forward divergence zscore (60d)",
      "description": "zscore(divide(forward_price_60, call_breakeven_60)) to normalize maturity-specific divergence. SUGGESTION1 used two fields; no backfill needed. Confidence = 0.65.",
      "implementation": "zscore(divide(forward_price_60, call_breakeven_60))",
      "confidence_level": 0.65
    },
    {
      "idea": "90d breakeven spike (ts_zscore)",
      "description": "ts_zscore(call_breakeven_90, 10) to detect atypical moves at 90d maturity. SUGGESTION1: single-field approach; coverage OK. Confidence = 0.63.",
      "implementation": "ts_zscore(call_breakeven_90, 10)",
      "confidence_level": 0.63
    },
    {
      "idea": "Forward / option breakeven spread (20d)",
      "description": "subtract(forward_price_20, option_breakeven_20) to detect broad option market disagreement with forward. Two fields used per SUGGESTION1. Confidence = 0.62.",
      "implementation": "subtract(forward_price_20, option_breakeven_20)",
      "confidence_level": 0.62
    },
    {
      "idea": "PCR OI anomaly across all maturities",
      "description": "zscore(pcr_oi_all) to spot names with extreme aggregate OI skew. SUGGESTION4: all-maturities aggregate gives stable signal. Confidence = 0.77.",
      "implementation": "zscore(pcr_oi_all)",
      "confidence_level": 0.77
    },
    {
      "idea": "Breakeven term-ratio (30/10)",
      "description": "divide(call_breakeven_30, call_breakeven_10) to measure term-structure amplification. SUGGESTION1 used two maturities; coverage ok. Confidence = 0.60.",
      "implementation": "divide(call_breakeven_30, call_breakeven_10)",
      "confidence_level": 0.6
    },
    {
      "idea": "Put skew normalized by OI (30d)",
      "description": "divide(subtract(call_breakeven_30, put_breakeven_30), pcr_oi_30) scales skew by open interest; SUGGESTION1 applied; moderate confidence due to pcr_oi_30 userCount. Confidence = 0.64.",
      "implementation": "divide(subtract(call_breakeven_30, put_breakeven_30), pcr_oi_30)",
      "confidence_level": 0.64
    },
    {
      "idea": "Rapid forward change (ts_returns)",
      "description": "ts_returns(forward_price_30, 3) to capture abrupt moves in implied forward. Single-field approach per SUGGESTION1. Confidence = 0.59.",
      "implementation": "ts_returns(forward_price_30, 3)",
      "confidence_level": 0.59
    },
    {
      "idea": "90d vs 10d call jump indicator",
      "description": "subtract(call_breakeven_90, call_breakeven_10) to identify names where medium-term expectations rise relative to immediate ones. SUGGESTION1 used two fields. Confidence = 0.61.",
      "implementation": "subtract(call_breakeven_90, call_breakeven_10)",
      "confidence_level": 0.61
    },
    {
      "idea": "PCR volatility-adjusted term spread",
      "description": "divide(subtract(pcr_oi_270, pcr_oi_30), pcr_vol_270) to down-weight areas with low trading. Applied SUGGESTION1 and leveraged high userCount pcr_oi_270 per SUGGESTION4. Confidence = 0.71.",
      "implementation": "divide(subtract(pcr_oi_270, pcr_oi_30), pcr_vol_270)",
      "confidence_level": 0.71
    },
    {
      "idea": "Call breakeven short-term rank",
      "description": "ts_rank(call_breakeven_10, 5) to identify recent leaders in call implied break. Simple single-field SUGGESTION1. Confidence = 0.62.",
      "implementation": "ts_rank(call_breakeven_10, 5)",
      "confidence_level": 0.62
    },
    {
      "idea": "Forward anomaly vs long breakeven (720d)",
      "description": "divide(forward_price_720, call_breakeven_720) to spot long-dated pairwise mispricings. SUGGESTION1 applied; coverage moderate. Confidence = 0.60.",
      "implementation": "divide(forward_price_720, call_breakeven_720)",
      "confidence_level": 0.6
    },
    {
      "idea": "Put-heavy names with weak forward (zscore combo)",
      "description": "zscore(multiply(pcr_oi_30, put_breakeven_30)) combining OI and put breakeven per SUGGESTION1. No vector/backfill. Confidence = 0.67.",
      "implementation": "zscore(multiply(pcr_oi_30, put_breakeven_30))",
      "confidence_level": 0.67
    },
    {
      "idea": "Call/Put breakeven ratio (30d)",
      "description": "divide(call_breakeven_30, put_breakeven_30) to measure asymmetry. Simple two-field SUGGESTION1; interpretable. Confidence = 0.68.",
      "implementation": "divide(call_breakeven_30, put_breakeven_30)",
      "confidence_level": 0.68
    },
    {
      "idea": "Rapid OI accumulation (ts_count_nans proxy using returns)",
      "description": "ts_returns(pcr_oi_30, 7) to detect accelerated accumulation in OI. SUGGESTION1 single field; coverage ok. Confidence = 0.63.",
      "implementation": "ts_returns(pcr_oi_30, 7)",
      "confidence_level": 0.63
    },
    {
      "idea": "Call breakeven stability (ts_std_dev)",
      "description": "ts_std_dev(call_breakeven_30, 20) to prefer stable breakevens (lower std = lower option uncertainty). SUGGESTION1 single field approach. Confidence = 0.60.",
      "implementation": "ts_std_dev(call_breakeven_30, 20)",
      "confidence_level": 0.6
    },
    {
      "idea": "PCR OI cross-maturity correlation",
      "description": "ts_corr(pcr_oi_30, pcr_oi_270, 30) to find names where short and long OI diverge. SUGGESTION1 used two fields; pcr_oi_270 high userCount improves reliability. Confidence = 0.74.",
      "implementation": "ts_corr(pcr_oi_30, pcr_oi_270, 30)",
      "confidence_level": 0.74
    },
    {
      "idea": "Volume surge vs OI (30d)",
      "description": "subtract(pcr_vol_30, pcr_oi_30) to find transient trading bursts vs structural positions. SUGGESTION1 used two fields; pcr_vol lower userCount reduces confidence. Confidence = 0.59.",
      "implementation": "subtract(pcr_vol_30, pcr_oi_30)",
      "confidence_level": 0.59
    },
    {
      "idea": "90d breakeven vs aggregate option breakeven",
      "description": "divide(call_breakeven_90, option_breakeven_90) to find call-specific deviations vs market. SUGGESTION1 used two fields; both coverages OK. Confidence = 0.65.",
      "implementation": "divide(call_breakeven_90, option_breakeven_90)",
      "confidence_level": 0.65
    },
    {
      "idea": "Put-term pressure (120d - 30d)",
      "description": "subtract(put_breakeven_120, put_breakeven_30) to capture medium-term downside expectations shift. SUGGESTION1 used two maturities; confidence moderate. Confidence = 0.60.",
      "implementation": "subtract(put_breakeven_120, put_breakeven_30)",
      "confidence_level": 0.6
    },
    {
      "idea": "Forward normalized to PCR OI (30d)",
      "description": "divide(forward_price_30, pcr_oi_30) to down-weight forward differences where OI is extreme. Applied SUGGESTION1; confidence moderate. Confidence = 0.62.",
      "implementation": "divide(forward_price_30, pcr_oi_30)",
      "confidence_level": 0.62
    },
    {
      "idea": "Long vs short implied forward ratio (720/30)",
      "description": "divide(forward_price_720, forward_price_30) to measure curve shape; SUGGESTION1 applied. Confidence = 0.61.",
      "implementation": "divide(forward_price_720, forward_price_30)",
      "confidence_level": 0.61
    },
    {
      "idea": "Short-term PCR concentration (zscore of pcr_oi_20)",
      "description": "zscore(pcr_oi_20) to detect extreme positioning at very short maturity. SUGGESTION1 single-field; lower userCount reduces confidence slightly. Confidence = 0.58.",
      "implementation": "zscore(pcr_oi_20)",
      "confidence_level": 0.58
    },
    {
      "idea": "Call breakeven breakout (ts_arg_max)",
      "description": "ts_arg_max(call_breakeven_30, 7) to flag when today's breakeven is recent max (index=0 desired). SUGGESTION1 used one field; interpretable signal. Confidence = 0.63.",
      "implementation": "ts_arg_max(call_breakeven_30, 7)",
      "confidence_level": 0.63
    },
    {
      "idea": "Put breakeven recent min detector",
      "description": "ts_arg_min(put_breakeven_30, 7) to find when put expectation is at recent minimum (possible complacency). SUGGESTION1 single-field. Confidence = 0.62.",
      "implementation": "ts_arg_min(put_breakeven_30, 7)",
      "confidence_level": 0.62
    },
    {
      "idea": "PCR OI relative strength (ts_ir)",
      "description": "ts_ir(pcr_oi_30, 20) to get information ratio of recent OI changes (mean/std). SUGGESTION1 applied; may help filter noisy names. Confidence = 0.65.",
      "implementation": "ts_ir(pcr_oi_30, 20)",
      "confidence_level": 0.65
    },
    {
      "idea": "Call breakeven vs long-term call (30 vs 360)",
      "description": "divide(call_breakeven_30, call_breakeven_360) to detect inversion between short and long expectations. SUGGESTION1 used two call maturities. Confidence = 0.60.",
      "implementation": "divide(call_breakeven_30, call_breakeven_360)",
      "confidence_level": 0.6
    },
    {
      "idea": "Put heavy with weak forward (combined zscore)",
      "description": "zscore(multiply(pcr_oi_30, divide(put_breakeven_30, forward_price_30))) combining OI and relative put breakeven per SUGGESTION1. Operator count kept <=7. Confidence = 0.69.",
      "implementation": "zscore(multiply(pcr_oi_30, divide(put_breakeven_30, forward_price_30)))",
      "confidence_level": 0.69
    },
    {
      "idea": "Breakeven acceleration (ts_delta)",
      "description": "ts_delta(call_breakeven_30, 5) to capture acceleration in call-implied price changes. SUGGESTION1 single-field; useful for short-term entries. Confidence = 0.61.",
      "implementation": "ts_delta(call_breakeven_30, 5)",
      "confidence_level": 0.61
    },
    {
      "idea": "PCR OI to aggregate breakeven mismatch",
      "description": "divide(pcr_oi_30, option_breakeven_30) to weight sentiment by aggregate option breakeven. SUGGESTION1 applied; confidence moderate. Confidence = 0.63.",
      "implementation": "divide(pcr_oi_30, option_breakeven_30)",
      "confidence_level": 0.63
    },
    {
      "idea": "Call breakeven low volatility preference",
      "description": "reverse(ts_std_dev(call_breakeven_30, 20)) to prefer stable names (negative of stddev). SUGGESTION1 single-field; simpler risk filter. Confidence = 0.59.",
      "implementation": "reverse(ts_std_dev(call_breakeven_30, 20))",
      "confidence_level": 0.59
    },
    {
      "idea": "90d PCR sudden jump (ts_zscore)",
      "description": "ts_zscore(pcr_oi_90, 7) to detect sudden jumps in medium-term positioning. SUGGESTION1 single-field; moderate confidence. Confidence = 0.61.",
      "implementation": "ts_zscore(pcr_oi_90, 7)",
      "confidence_level": 0.61
    },
    {
      "idea": "Forward vs option breakeven ratio (360d)",
      "description": "divide(forward_price_360, option_breakeven_360) comparing long forward to option market level. SUGGESTION1 applied; coverage OK. Confidence = 0.60.",
      "implementation": "divide(forward_price_360, option_breakeven_360)",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term put-call divergence weighted",
      "description": "multiply(subtract(put_breakeven_10, call_breakeven_10), pcr_oi_10) to highlight put dominance where OI supports it. SUGGESTION1 used three components compressed into 2 fields by combining via subtract then multiply — operators <=7. Confidence = 0.66.",
      "implementation": "multiply(subtract(put_breakeven_10, call_breakeven_10), pcr_oi_10)",
      "confidence_level": 0.66
    },
    {
      "idea": "Breakeven cross-maturity ratio (150/60)",
      "description": "divide(call_breakeven_150, call_breakeven_60) to detect medium-term acceleration. SUGGESTION1 used two fields; simple and interpretable. Confidence = 0.58.",
      "implementation": "divide(call_breakeven_150, call_breakeven_60)",
      "confidence_level": 0.58
    },
    {
      "idea": "Aggregate call skew (mean of two maturities)",
      "description": "divide(add(call_breakeven_30, call_breakeven_90), 2) to smooth single-maturity noise. SUGGESTION1 applied and KEEP_IN_MIND2 respected. Confidence = 0.63.",
      "implementation": "divide(add(call_breakeven_30, call_breakeven_90), 2)",
      "confidence_level": 0.63
    },
    {
      "idea": "PCR OI change ratio (30d)",
      "description": "divide(ts_returns(pcr_oi_30, 5), ts_std_dev(pcr_oi_30, 20)) to form a short-term IR-style signal. SUGGESTION1 applied; operators kept <=7. Confidence = 0.67.",
      "implementation": "divide(ts_returns(pcr_oi_30, 5), ts_std_dev(pcr_oi_30, 20))",
      "confidence_level": 0.67
    },
    {
      "idea": "Put breakeven normalized rank (30d)",
      "description": "ts_rank(put_breakeven_30, 14) to identify names with recent extreme put expectations. SUGGESTION1 one field; straightforward. Confidence = 0.62.",
      "implementation": "ts_rank(put_breakeven_30, 14)",
      "confidence_level": 0.62
    },
    {
      "idea": "Forward volatility of breakeven (ts_kurtosis)",
      "description": "ts_kurtosis(call_breakeven_30, 30) to find names with fat-tail breakeven distributions (potential event risk). SUGGESTION1 single-field; may be noisy but useful. Confidence = 0.55.",
      "implementation": "ts_kurtosis(call_breakeven_30, 30)",
      "confidence_level": 0.55
    },
    {
      "idea": "Call breakeven vs PCR OI correlation (30d)",
      "description": "ts_corr(call_breakeven_30, pcr_oi_30, 30) to find names where implied price and positioning move together (momentum areas). SUGGESTION1 used two fields; pcr_oi_30 userCount moderate. Confidence = 0.68.",
      "implementation": "ts_corr(call_breakeven_30, pcr_oi_30, 30)",
      "confidence_level": 0.68
    },
    {
      "idea": "Put dominance with low volume filter",
      "description": "and(greater(pcr_oi_30, 1), less(pcr_vol_30, 1)) boolean signal where OI>1 and vol low (thresholds illustrative). SUGGESTION1 used two fields; keeps operators minimal. Confidence = 0.57.",
      "implementation": "and(greater(pcr_oi_30, 1), less(pcr_vol_30, 1))",
      "confidence_level": 0.57
    },
    {
      "idea": "Forward breakout normalized (ts_quantile)",
      "description": "ts_quantile(forward_price_30, 20) to map forward moves into gaussian quantiles for robust cross-sectional comparison. SUGGESTION1 used single field; no backfill needed. Confidence = 0.64.",
      "implementation": "ts_quantile(forward_price_30, 20)",
      "confidence_level": 0.64
    },
    {
      "idea": "Breakeven term variance (vec-like across two maturities)",
      "description": "abs(subtract(call_breakeven_30, call_breakeven_90)) as simple dispersion metric across maturities. SUGGESTION1 used two fields; vector ops not available so used abs subtract. Confidence = 0.61.",
      "implementation": "abs(subtract(call_breakeven_30, call_breakeven_90))",
      "confidence_level": 0.61
    },
    {
      "idea": "PCR OI 30d zscore times forward mispricing",
      "description": "multiply(zscore(pcr_oi_30), divide(forward_price_30, call_breakeven_30)) to amplify mispricings where OI is extreme. SUGGESTION1 applied; kept operators <=7. Confidence = 0.70.",
      "implementation": "multiply(zscore(pcr_oi_30), divide(forward_price_30, call_breakeven_30))",
      "confidence_level": 0.7
    },
    {
      "idea": "Put-call ratio acceleration (ts_delta on pcr_oi)",
      "description": "ts_delta(pcr_oi_30, 5) to identify accelerating positioning changes. SUGGESTION1 used single field; straightforward. Confidence = 0.63.",
      "implementation": "ts_delta(pcr_oi_30, 5)",
      "confidence_level": 0.63
    },
    {
      "idea": "Call breakeven downside protection (inverse)",
      "description": "inverse(put_breakeven_30) to prefer names with lower put-implied break (higher inverse = lower put price). SUGGESTION1 single-field; simple transformation. Confidence = 0.56.",
      "implementation": "inverse(put_breakeven_30)",
      "confidence_level": 0.56
    },
    {
      "idea": "PCR OI long-term momentum (ts_zscore 60d)",
      "description": "ts_zscore(pcr_oi_270, 60) to capture persistent shifts at long-dated maturities; SUGGESTION4 supports this due to high userCount. Confidence = 0.75.",
      "implementation": "ts_zscore(pcr_oi_270, 60)",
      "confidence_level": 0.75
    },
    {
      "idea": "Breakeven vs overall put-call (30d)",
      "description": "divide(option_breakeven_30, pcr_oi_30) to spot where aggregate option level diverges from put-call composition. SUGGESTION1 used two fields; coverage good. Confidence = 0.64.",
      "implementation": "divide(option_breakeven_30, pcr_oi_30)",
      "confidence_level": 0.64
    },
    {
      "idea": "Put breakeven normalized zscore (120d)",
      "description": "zscore(put_breakeven_120) to flag medium-term downside extremes. SUGGESTION1 single-field; moderate confidence. Confidence = 0.61.",
      "implementation": "zscore(put_breakeven_120)",
      "confidence_level": 0.61
    },
    {
      "idea": "Call breakeven vs call OI correlation (90d)",
      "description": "ts_corr(call_breakeven_90, pcr_oi_90, 30) to find names where implied calls and positioning co-move. SUGGESTION1 used two fields; helps find momentum names. Confidence = 0.66.",
      "implementation": "ts_corr(call_breakeven_90, pcr_oi_90, 30)",
      "confidence_level": 0.66
    },
    {
      "idea": "Forward-term reversal candidate (ts_rank reverse)",
      "description": "reverse(ts_rank(forward_price_30, 10)) to favor names with low recent forward ranks (potential mean-revert). SUGGESTION1 single-field; simple mean-reversion signal. Confidence = 0.58.",
      "implementation": "reverse(ts_rank(forward_price_30, 10))",
      "confidence_level": 0.58
    },
    {
      "idea": "PCR OI vs pcr_vol divergence (30d)",
      "description": "subtract(pcr_oi_30, pcr_vol_30) to detect where structural positions (OI) are disconnected from trading (vol). SUGGESTION1 applied; lower pcr_vol userCount tempers confidence. Confidence = 0.60.",
      "implementation": "subtract(pcr_oi_30, pcr_vol_30)",
      "confidence_level": 0.6
    },
    {
      "idea": "Breakeven mean reversion (zscore of mean 10/30d)",
      "description": "zscore(divide(add(call_breakeven_10, call_breakeven_30), 2)) to find mean-reverting names across very short maturities. SUGGESTION1 used two fields; confidence moderate. Confidence = 0.62.",
      "implementation": "zscore(divide(add(call_breakeven_10, call_breakeven_30), 2))",
      "confidence_level": 0.62
    },
    {
      "idea": "Long-term put-call pressure indicator (1080d)",
      "description": "zscore(pcr_oi_1080) to identify extreme positioning at the longest maturity available. SUGGESTION4: lower userCount than 270 but still usable. Confidence = 0.57.",
      "implementation": "zscore(pcr_oi_1080)",
      "confidence_level": 0.57
    },
    {
      "idea": "Forward vs call immediate spread (10d)",
      "description": "subtract(forward_price_10, call_breakeven_10) for near-term disagreement signal. SUGGESTION1 used two fields; coverage good. Confidence = 0.64.",
      "implementation": "subtract(forward_price_10, call_breakeven_10)",
      "confidence_level": 0.64
    },
    {
      "idea": "Put-heavy names with rising OI (ts_returns combo)",
      "description": "multiply(ts_returns(pcr_oi_30, 5), zscore(put_breakeven_30)) to find names where put OI is rising and put breakeven is extreme. SUGGESTION1 combined OI returns and breakeven; kept operators <=7. Confidence = 0.68.",
      "implementation": "multiply(ts_returns(pcr_oi_30, 5), zscore(put_breakeven_30))",
      "confidence_level": 0.68
    },
    {
      "idea": "PCR OI concentration across maturities (count high)",
      "description": "greater(pcr_oi_270, pcr_oi_30) boolean to find long-maturity concentrated OI. SUGGESTION1 simple two-field comparator. Confidence = 0.66.",
      "implementation": "greater(pcr_oi_270, pcr_oi_30)",
      "confidence_level": 0.66
    },
    {
      "idea": "Call breakeven sudden drop detector",
      "description": "less(call_breakeven_30, ts_min(call_breakeven_30, 5)) detects when today's breakeven is lower than recent minimum (requires ts_min but not in operator list) — instead use ts_arg_min to approximate. Implemented with ts_arg_min check. Confidence = 0.58.",
      "implementation": "equal(ts_arg_min(call_breakeven_30, 5), 0)",
      "confidence_level": 0.58
    },
    {
      "idea": "Breakeven-term momentum vs OI",
      "description": "multiply(ts_returns(call_breakeven_30, 5), pcr_oi_30) combining momentum and positioning per SUGGESTION1. Confidence = 0.66.",
      "implementation": "multiply(ts_returns(call_breakeven_30, 5), pcr_oi_30)",
      "confidence_level": 0.66
    },
    {
      "idea": "Aggregate short-dated PCR signal",
      "description": "divide(add(pcr_oi_10, pcr_oi_20), 2) to smooth idiosyncratic noise at very short maturities. SUGGESTION1 used two fields only. Confidence = 0.65.",
      "implementation": "divide(add(pcr_oi_10, pcr_oi_20), 2)",
      "confidence_level": 0.65
    },
    {
      "idea": "Call breakeven low mean high rank filter",
      "description": "and(less(call_breakeven_30, ts_mean(call_breakeven_30, 60)), greater(ts_rank(call_breakeven_30, 7), 0.8)) finds names below long-term mean but high recent rank; operators kept <=7 and two field references. Confidence = 0.59.",
      "implementation": "and(less(call_breakeven_30, ts_mean(call_breakeven_30, 60)), greater(ts_rank(call_breakeven_30, 7), 0.8))",
      "confidence_level": 0.59
    },
    {
      "idea": "Put breakeven long-term slope (720 vs 30)",
      "description": "subtract(put_breakeven_720, put_breakeven_30) to capture long-term downside focus relative to near-term. SUGGESTION1 used two fields. Confidence = 0.60.",
      "implementation": "subtract(put_breakeven_720, put_breakeven_30)",
      "confidence_level": 0.6
    },
    {
      "idea": "PCR OI 270d vs all maturities divergence",
      "description": "subtract(pcr_oi_270, pcr_oi_all) to identify names where long-dated OI differs from overall market OI. SUGGESTION1 used two fields; pcr_oi_270 high userCount supports confidence. Confidence = 0.73.",
      "implementation": "subtract(pcr_oi_270, pcr_oi_all)",
      "confidence_level": 0.73
    },
    {
      "idea": "Forward breakout vs OI (short)",
      "description": "multiply(ts_returns(forward_price_30, 3), reverse(pcr_oi_30)) to find forward breakouts where OI is decreasing (contrarian). SUGGESTION1 used two fields; operators <=7. Confidence = 0.58.",
      "implementation": "multiply(ts_returns(forward_price_30, 3), reverse(pcr_oi_30))",
      "confidence_level": 0.58
    },
    {
      "idea": "Call breakeven median filter (winsorized)",
      "description": "winsorize(call_breakeven_30, std=4) to reduce outlier impact before ranking. SUGGESTION1 used single field; helps robustness. Confidence = 0.60.",
      "implementation": "winsorize(call_breakeven_30, 4)",
      "confidence_level": 0.6
    },
    {
      "idea": "Put breakeven vs option aggregate (zscore)",
      "description": "zscore(divide(put_breakeven_30, option_breakeven_30)) to normalize put level relative to overall option market. SUGGESTION1 used two fields. Confidence = 0.64.",
      "implementation": "zscore(divide(put_breakeven_30, option_breakeven_30))",
      "confidence_level": 0.64
    },
    {
      "idea": "Short-term PCR discord (30 vs 10)",
      "description": "subtract(pcr_oi_30, pcr_oi_10) to find mismatches between near and short-term positioning. SUGGESTION1 applied; operators minimal. Confidence = 0.62.",
      "implementation": "subtract(pcr_oi_30, pcr_oi_10)",
      "confidence_level": 0.62
    },
    {
      "idea": "Forward sudden rank change",
      "description": "ts_arg_max(forward_price_30, 5) to flag when today's forward is highest in recent window. Simple SUGGESTION1 single-field approach. Confidence = 0.60.",
      "implementation": "ts_arg_max(forward_price_30, 5)",
      "confidence_level": 0.6
    },
    {
      "idea": "PCR volatility-weighted breakeven skew",
      "description": "divide(subtract(call_breakeven_30, put_breakeven_30), pcr_vol_270) to temper skew by long-dated trading intensity. SUGGESTION1 applied; pcr_vol_270 moderate userCount. Confidence = 0.63.",
      "implementation": "divide(subtract(call_breakeven_30, put_breakeven_30), pcr_vol_270)",
      "confidence_level": 0.63
    },
    {
      "idea": "Call breakeven cluster signal (30 & 60 average)",
      "description": "divide(add(call_breakeven_30, call_breakeven_60), 2) to smooth and identify clustered moves. SUGGESTION1 used two fields; simple filter. Confidence = 0.62.",
      "implementation": "divide(add(call_breakeven_30, call_breakeven_60), 2)",
      "confidence_level": 0.62
    },
    {
      "idea": "PCR OI vs forward correlation (30d)",
      "description": "ts_corr(pcr_oi_30, forward_price_30, 30) to find names where positioning and forward move together (momentum) or diverge (mean-revert). SUGGESTION1 used two fields. Confidence = 0.69.",
      "implementation": "ts_corr(pcr_oi_30, forward_price_30, 30)",
      "confidence_level": 0.69
    },
    {
      "idea": "Put breakeven vs call breakeven ratio (90d)",
      "description": "divide(put_breakeven_90, call_breakeven_90) to measure relative downside vs upside priced in the market. SUGGESTION1 used two fields; interpretable. Confidence = 0.65.",
      "implementation": "divide(put_breakeven_90, call_breakeven_90)",
      "confidence_level": 0.65
    },
    {
      "idea": "PCR OI robustness filter (group-style boolean)",
      "description": "greater(pcr_oi_270, 1) simple threshold to pick names with significant long-dated put dominance. SUGGESTION4 exploited pcr_oi_270 high userCount. Confidence = 0.72.",
      "implementation": "greater(pcr_oi_270, 1)",
      "confidence_level": 0.72
    },
    {
      "idea": "Forward-term percentile (ts_quantile 30d)",
      "description": "ts_quantile(forward_price_30, 30) to compare forwards in cross-section robustly. SUGGESTION1 single-field; good normalization. Confidence = 0.64.",
      "implementation": "ts_quantile(forward_price_30, 30)",
      "confidence_level": 0.64
    },
    {
      "idea": "Call breakeven correlation with option aggregate",
      "description": "ts_corr(call_breakeven_30, option_breakeven_30, 30) to capture consistency between call and total option markets. SUGGESTION1 used two fields. Confidence = 0.66.",
      "implementation": "ts_corr(call_breakeven_30, option_breakeven_30, 30)",
      "confidence_level": 0.66
    },
    {
      "idea": "Put breakeven sudden accumulation (ts_count_nans proxy via ts_returns)",
      "description": "ts_returns(put_breakeven_30, 5) to detect quick increases in put-implied pricing. SUGGESTION1 single-field. Confidence = 0.60.",
      "implementation": "ts_returns(put_breakeven_30, 5)",
      "confidence_level": 0.6
    },
    {
      "idea": "PCR OI cross-maturity ratio 120/30",
      "description": "divide(pcr_oi_120, pcr_oi_30) to capture where medium-term positioning dominates short-term. SUGGESTION1 used two fields; confidence moderate. Confidence = 0.61.",
      "implementation": "divide(pcr_oi_120, pcr_oi_30)",
      "confidence_level": 0.61
    },
    {
      "idea": "Forward normalized zscore (720d)",
      "description": "zscore(forward_price_720) to find extreme long-dated forward expectations. SUGGESTION1 single-field; coverage moderate. Confidence = 0.59.",
      "implementation": "zscore(forward_price_720)",
      "confidence_level": 0.59
    },
    {
      "idea": "Breakeven term inversion alert (30 vs 270)",
      "description": "less(call_breakeven_30, call_breakeven_270) boolean flag for inversion where short < long; SUGGESTION1 used two fields keeping operators minimal. Confidence = 0.58.",
      "implementation": "less(call_breakeven_30, call_breakeven_270)",
      "confidence_level": 0.58
    },
    {
      "idea": "PCR OI and Breakeven joint zscore",
      "description": "zscore(add(zscore(pcr_oi_30), zscore(subtract(call_breakeven_30, put_breakeven_30)))) combine normalized OI and skew for balanced signal; SUGGESTION1 used two effective inputs after zscore transforms; operators <=7. Confidence = 0.71.",
      "implementation": "zscore(add(zscore(pcr_oi_30), zscore(subtract(call_breakeven_30, put_breakeven_30))))",
      "confidence_level": 0.71
    },
    {
      "idea": "Call breakeven 30d downside filter (if_else)",
      "description": "if_else(less(call_breakeven_30, ts_mean(call_breakeven_30, 60)), call_breakeven_30, NaN) to trade only when below long-term mean. SUGGESTION1 single-field; uses if_else to gate positions. Confidence = 0.59.",
      "implementation": "if_else(less(call_breakeven_30, ts_mean(call_breakeven_30, 60)), call_breakeven_30, NaN)",
      "confidence_level": 0.59
    },
    {
      "idea": "PCR OI trend vs breakeven trend (30d)",
      "description": "ts_corr(ts_returns(pcr_oi_30,5), ts_returns(call_breakeven_30,5), 20) to find aligned trends in OI and implied price. SUGGESTION1 used two fields transformed by ts_returns; operators <=7. Confidence = 0.68.",
      "implementation": "ts_corr(ts_returns(pcr_oi_30, 5), ts_returns(call_breakeven_30, 5), 20)",
      "confidence_level": 0.68
    },
    {
      "idea": "High-confidence long-dated OI momentum",
      "description": "ts_returns(pcr_oi_270, 10) focusing on long-dated OI shifts; SUGGESTION4: pcr_oi_270 high userCount gives higher confidence. Confidence = 0.77.",
      "implementation": "ts_returns(pcr_oi_270, 10)",
      "confidence_level": 0.77
    },
    {
      "idea": "Forward vs call 270d mismatch",
      "description": "subtract(forward_price_270, call_breakeven_270) to find long-dated disagreements between forward and call market. SUGGESTION1 used two fields; confidence moderate. Confidence = 0.60.",
      "implementation": "subtract(forward_price_270, call_breakeven_270)",
      "confidence_level": 0.6
    },
    {
      "idea": "PCR vol spike normalized",
      "description": "ts_zscore(pcr_vol_30, 10) to detect surges in put vs call trading activity. SUGGESTION1 single-field; pcr_vol less widely used => lower confidence. Confidence = 0.56.",
      "implementation": "ts_zscore(pcr_vol_30, 10)",
      "confidence_level": 0.56
    },
    {
      "idea": "Call breakeven normalized by long-term volatility proxy",
      "description": "divide(call_breakeven_30, ts_std_dev(call_breakeven_30, 60)) to favor high breakevens with low recent volatility. SUGGESTION1 single-field with ts_std_dev; operators <=7. Confidence = 0.62.",
      "implementation": "divide(call_breakeven_30, ts_std_dev(call_breakeven_30, 60))",
      "confidence_level": 0.62
    },
    {
      "idea": "Put-call breath (difference normalized)",
      "description": "zscore(subtract(pcr_oi_30, pcr_oi_all)) to find short-dated deviations from the aggregate market. SUGGESTION1 used two fields; pcr_oi_all helps stability per SUGGESTION4. Confidence = 0.70.",
      "implementation": "zscore(subtract(pcr_oi_30, pcr_oi_all))",
      "confidence_level": 0.7
    }
  ]
}