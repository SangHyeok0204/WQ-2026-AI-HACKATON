{
  "results": [
    {
      "idea": "Competitor PageRank momentum",
      "description": "Combine competitor PageRank with competitor average returns to capture network-driven momentum. Applied SUGGESTION1 (used pv13_com_page_rank and rel_ret_comp). SUGGESTION2: treated pv13_com_page_rank as vector (vec_avg) since it aggregates competitor ranks. SUGGESTION3: coverage high (0.8966) so no ts_backfill. SUGGESTION4: both fields have high user/alpha counts, so preferred. confidence: 0.72",
      "implementation": "zscore(multiply(vec_avg(pv13_com_page_rank), rel_ret_comp))",
      "confidence_level": 0.72
    },
    {
      "idea": "Customer sentiment sign filter",
      "description": "Use customer return sign to filter stocks with strong customer-driven moves. S1: combined pv13_custretsig_retsig with rel_ret_cust. S2: no vector wrap. S3: rel_ret_cust coverage 0.4921 -> applied ts_backfill. S4: pv13_custretsig_retsig has good user/alpha counts. confidence: 0.60",
      "implementation": "if_else(pv13_custretsig_retsig, ts_backfill(rel_ret_cust,5), NaN)",
      "confidence_level": 0.6
    },
    {
      "idea": "HITS authority x own size scaling",
      "description": "Weight authority score of competitors by company market cap to favor large, authoritative networks. S1: pv13_com_rk_au and pv13_revere_index_cap used. S2: vec_avg on pv13_com_rk_au. S3: both have coverage >0.6, no backfill. S4: high user/alpha counts used. confidence: 0.68",
      "implementation": "zscore(divide(vec_avg(pv13_com_rk_au), pv13_revere_index_cap))",
      "confidence_level": 0.68
    },
    {
      "idea": "Partner returns mean-reversion",
      "description": "Short/long on mean reversion of partners' average returns. S1: rel_ret_part and rel_num_part combined. S2: no vector wrap. S3: rel_ret_part coverage 0.7097 (>0.6) no backfill. S4: rel_num_part high userCount supports stability. confidence: 0.63",
      "implementation": "reverse(ts_zscore(rel_ret_part,10))",
      "confidence_level": 0.63
    },
    {
      "idea": "Competitor count vs return surprise",
      "description": "Adjust returns by number of competitors: firms with few competitors but high competitor returns may lead to outsized moves. S1 used rel_num_comp and rel_ret_comp. S2: no vector wrap. S3: both coverage >0.6 so no backfill. S4: rel_ret_comp has highest user/alpha counts. confidence: 0.66",
      "implementation": "zscore(divide(rel_ret_comp, add(rel_num_comp,1)))",
      "confidence_level": 0.66
    },
    {
      "idea": "PageRank stdev dispersion",
      "description": "High dispersion in competitor PageRank indicates concentrated influence; trade accordingly. S1: vec_stddev(pv13_com_page_rank) and rel_ret_comp. S2: vec_stddev used per SUGGESTION2. S3: pv13_com_page_rank coverage high so no backfill. S4: both fields well-used. confidence: 0.61",
      "implementation": "zscore(multiply(vec_stddev(pv13_com_page_rank), rel_ret_comp))",
      "confidence_level": 0.61
    },
    {
      "idea": "Customer hub-authority divergence",
      "description": "Take positions when customer hub vs authority scores diverge, implying structural change. S1: pv13_ustomergraphrank_hub_rank and pv13_ustomergraphrank_auth_rank used. S2: vec_avg applied to both. S3: coverage ~0.79, no backfill. S4: moderate userCounts used. confidence: 0.58",
      "implementation": "zscore(subtract(vec_avg(pv13_ustomergraphrank_hub_rank), vec_avg(pv13_ustomergraphrank_auth_rank)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Index-cap scaled competitor return",
      "description": "Scale competitor returns by index cap to prefer moves driven by large-cap peers. S1: rel_ret_comp and pv13_revere_index_cap. S2: no vector wrap. S3: coverage >0.6 so no backfill. S4: both high user/alpha counts. confidence: 0.70",
      "implementation": "zscore(divide(rel_ret_comp, pv13_revere_index_cap))",
      "confidence_level": 0.7
    },
    {
      "idea": "Terminal-sector concentration signal",
      "description": "Firms with many terminal sectors may have focused revenue streams; combine term sector count with competitor returns. S1: pv13_revere_term_sector_total and rel_ret_comp used. S2: no vector wrap. S3: term_sector_total coverage 1.0, no backfill. S4: high user/alpha counts. confidence: 0.55",
      "implementation": "zscore(divide(rel_ret_comp, add(pv13_revere_term_sector_total,1)))",
      "confidence_level": 0.55
    },
    {
      "idea": "Local cluster momentum (zipcode)",
      "description": "Aggregate competitor returns within same zipcode to capture local spillovers. S1: rel_ret_comp and pv13_revere_zipcode used. S2: used pv13_revere_zipcode as group in group_mean. S3: rel_ret_comp coverage >0.6; zipcode coverage high. S4: rel_ret_comp very well-used. confidence: 0.64",
      "implementation": "group_mean(rel_ret_comp, weight=1, group=pv13_revere_zipcode)",
      "confidence_level": 0.64
    },
    {
      "idea": "Customer count-scaled momentum",
      "description": "Favor companies whose customers' average returns are strong relative to customer count. S1: rel_ret_cust with rel_num_cust. S2: rel_ret_cust coverage 0.4921 -> applied ts_backfill. S3: rel_num_cust coverage 0.5068 -> ts_backfill. S4: userCounts moderate-high. confidence: 0.59",
      "implementation": "zscore(divide(ts_backfill(rel_ret_cust,5), add(ts_backfill(rel_num_cust,5),1)))",
      "confidence_level": 0.59
    },
    {
      "idea": "Competitor IR momentum",
      "description": "Use information ratio of competitor returns to find consistent peer movers. S1: ts_ir(rel_ret_comp,20) combined with pv13_revere_index_cap. S2: no vector wrap. S3: coverage >0.6 so ts_backfill not required. S4: rel_ret_comp has strong stats. confidence: 0.67",
      "implementation": "zscore(divide(ts_ir(rel_ret_comp,20), pv13_revere_index_cap))",
      "confidence_level": 0.67
    },
    {
      "idea": "PageRank x own index value jump",
      "description": "Combine competitor PageRank with short-term change in index value to capture macro-network interactions. S1: vec_avg(pv13_com_page_rank) and ts_delta(pv13_revere_index_value,1). S2: vec_avg applied. S3: index value coverage 1.0, no backfill. S4: page rank heavily used. confidence: 0.62",
      "implementation": "zscore(multiply(vec_avg(pv13_com_page_rank), ts_delta(pv13_revere_index_value,1)))",
      "confidence_level": 0.62
    },
    {
      "idea": "Competitor return cross-correlation",
      "description": "Low correlation to competitors but positive competitor returns may be ripe for mean reversion; use ts_corr. S1: ts_corr(rel_ret_comp, rel_ret_all, 20). S2: both scalar. S3: coverage >0.6 so no backfill. S4: rel_ret_all well used. confidence: 0.60",
      "implementation": "reverse(ts_corr(rel_ret_comp, rel_ret_all,20))",
      "confidence_level": 0.6
    },
    {
      "idea": "Product-overlap return spike",
      "description": "If overlapping-product firms show return spikes, the focal firm may follow; use rel_ret_all and rel_num_all. S1: rel_ret_all and rel_num_all combined. S2: no vector wrap. S3: rel_ret_all coverage high. S4: rel_num_all solid user/alpha counts. confidence: 0.65",
      "implementation": "zscore(divide(rel_ret_all, add(rel_num_all,1)))",
      "confidence_level": 0.65
    },
    {
      "idea": "Competitor hub-rank breakout",
      "description": "High competitor hub ranks combined with rising competitor returns indicate breakout probability. S1: vec_avg(pv13_ompetitorgraphrank_hub_rank) and rel_ret_comp. S2: vec_avg used. S3: coverage >0.6. S4: moderate userCounts. confidence: 0.57",
      "implementation": "zscore(multiply(vec_avg(pv13_ompetitorgraphrank_hub_rank), rel_ret_comp))",
      "confidence_level": 0.57
    },
    {
      "idea": "Size-adjusted customer return momentum",
      "description": "Customers of large suppliers moving together may lift supplier; scale rel_ret_cust by pv13_revere_index_cap. S1: rel_ret_cust and pv13_revere_index_cap. S2: rel_ret_cust low coverage -> ts_backfill applied. S4: index cap high userCount used. confidence: 0.61",
      "implementation": "zscore(divide(ts_backfill(rel_ret_cust,5), pv13_revere_index_cap))",
      "confidence_level": 0.61
    },
    {
      "idea": "Authority-weighted partner returns",
      "description": "Weight partners' returns by their authority score to capture influence. S1: pv13_com_rk_au (vec_avg) and rel_ret_part. S2: vec_avg used. S3: coverage ok, no backfill. S4: rel_ret_part high counts. confidence: 0.64",
      "implementation": "zscore(multiply(vec_avg(pv13_com_rk_au), rel_ret_part))",
      "confidence_level": 0.64
    },
    {
      "idea": "Customer PageRank momentum",
      "description": "Customers with high PageRank whose returns rise can predict supplier moves. S1: vec_avg(pv13_ustomergraphrank_page_rank) and rel_ret_cust. S2: vec_avg applied; rel_ret_cust low coverage -> ts_backfill. S4: page rank userCount reasonable. confidence: 0.56",
      "implementation": "zscore(multiply(vec_avg(pv13_ustomergraphrank_page_rank), ts_backfill(rel_ret_cust,5)))",
      "confidence_level": 0.56
    },
    {
      "idea": "Competitor return acceleration",
      "description": "Use ts_zscore on recent competitor returns to detect accelerating peer moves. S1: ts_zscore(rel_ret_comp,10) with pv13_revere_index_cap scaling. S3: coverage ok. S4: rel_ret_comp trusted. confidence: 0.66",
      "implementation": "zscore(divide(ts_zscore(rel_ret_comp,10), pv13_revere_index_cap))",
      "confidence_level": 0.66
    },
    {
      "idea": "High-rel_num_all breakout filter",
      "description": "Companies with many overlapping products that see rising average returns may breakout. S1: rel_num_all and rel_ret_all used. S2: no vector wrap. S3: both high coverage; no backfill. S4: both well used. confidence: 0.62",
      "implementation": "zscore(multiply(rel_num_all, rel_ret_all))",
      "confidence_level": 0.62
    },
    {
      "idea": "PageRank-to-competitor-count ratio",
      "description": "High average PageRank but few competitors signals concentrated influence. S1: vec_avg(pv13_com_page_rank) and rel_num_comp. S2: vec_avg used. S3: no backfill needed. S4: both widely used. confidence: 0.60",
      "implementation": "zscore(divide(vec_avg(pv13_com_page_rank), add(rel_num_comp,1)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Partner count-adjusted volatility",
      "description": "Combine partner count with volatility of partner returns (ts_std_dev) to detect stability. S1: rel_num_part and ts_std_dev(rel_ret_part,20). S2: scalar fields. S3: coverage >0.6. S4: rel_num_part high usage. confidence: 0.54",
      "implementation": "zscore(divide(ts_std_dev(rel_ret_part,20), add(rel_num_part,1)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Customers hub-authority momentum",
      "description": "Combine customer hub score with customers' average returns to capture structural customer-led moves. S1: vec_avg(pv13_ustomergraphrank_hub_rank) and rel_ret_cust. S2: vec_avg used; rel_ret_cust backfilled. S4: hub_rank moderate usage. confidence: 0.57",
      "implementation": "zscore(multiply(vec_avg(pv13_ustomergraphrank_hub_rank), ts_backfill(rel_ret_cust,5)))",
      "confidence_level": 0.57
    },
    {
      "idea": "Competitor return momentum minus market",
      "description": "Subtract index value change to isolate idiosyncratic competitor momentum. S1: rel_ret_comp and ts_delta(pv13_revere_index_value,1). S2: no vector wrap. S3: index value coverage 1.0. S4: rel_ret_comp highly used. confidence: 0.69",
      "implementation": "zscore(subtract(rel_ret_comp, ts_delta(pv13_revere_index_value,1)))",
      "confidence_level": 0.69
    },
    {
      "idea": "Edge: PageRank minus customer PageRank",
      "description": "Difference between competitor PageRank and customer PageRank captures network asymmetry. S1: vec_avg(pv13_com_page_rank) and vec_avg(pv13_ustomergraphrank_page_rank). S2: vec_avg on both. S3: coverage high; no backfill. S4: both fields have solid userCounts. confidence: 0.58",
      "implementation": "zscore(subtract(vec_avg(pv13_com_page_rank), vec_avg(pv13_ustomergraphrank_page_rank)))",
      "confidence_level": 0.58
    },
    {
      "idea": "High-authority competitor acceleration",
      "description": "Detect acceleration among high-authority competitors using ts_zscore of vec_avg authority times returns. S1: vec_avg(pv13_com_rk_au) and ts_zscore(rel_ret_comp,10). S2: vec_avg used. S3: no backfill required. S4: both widely used. confidence: 0.63",
      "implementation": "zscore(multiply(vec_avg(pv13_com_rk_au), ts_zscore(rel_ret_comp,10)))",
      "confidence_level": 0.63
    },
    {
      "idea": "Company focus depth risk premium",
      "description": "Use primary_sector_focused_company_count to detect focused firms (low count) combined with competitor returns. S1: primary_sector_focused_company_count and rel_ret_comp. S2: primary_sector field coverage 0.3508 -> ts_backfill applied. S4: low userCount so lower confidence. confidence: 0.47",
      "implementation": "zscore(divide(rel_ret_comp, add(ts_backfill(primary_sector_focused_company_count,10),1)))",
      "confidence_level": 0.47
    },
    {
      "idea": "Terminal sector sudden-change filter",
      "description": "If a terminal sector indicator changes with rising competitor returns, signal change. S1: pv13_revere_term and rel_ret_comp. S2: pv13_revere_term coverage 0.4115 -> ts_backfill applied. S4: pv13_revere_term has moderate userCount. confidence: 0.50",
      "implementation": "if_else(ts_backfill(pv13_revere_term,10), rel_ret_comp, NaN)",
      "confidence_level": 0.5
    },
    {
      "idea": "Competition-weighted return skew",
      "description": "Multiply competitor return by number of competitors to find aggregate pressure. S1: rel_ret_comp and rel_num_comp used. S2: no vec ops. S3: coverage high; no backfill. S4: both high user/alpha counts. confidence: 0.65",
      "implementation": "zscore(multiply(rel_ret_comp, rel_num_comp))",
      "confidence_level": 0.65
    },
    {
      "idea": "PageRank range shock",
      "description": "Large vec_range of competitor PageRank indicates shifting influence; combine with rel_ret_comp. S1: vec_range(pv13_com_page_rank) and rel_ret_comp. S2: vec_range per SUGGESTION2. S3: good coverage. S4: reliable counts. confidence: 0.59",
      "implementation": "zscore(multiply(vec_range(pv13_com_page_rank), rel_ret_comp))",
      "confidence_level": 0.59
    },
    {
      "idea": "Customers' PageRank zscore",
      "description": "Z-score of customer PageRank times customers' returns finds significant customer-led signals. S1: vec_avg(pv13_ustomergraphrank_page_rank) and ts_zscore(rel_ret_cust,10). S2: vec_avg used; rel_ret_cust backfilled. S4: moderate confidence. confidence: 0.55",
      "implementation": "zscore(multiply(vec_avg(pv13_ustomergraphrank_page_rank), ts_zscore(ts_backfill(rel_ret_cust,5),10)))",
      "confidence_level": 0.55
    },
    {
      "idea": "Competition count momentum filter",
      "description": "Favor names where few competitors show strong positive returns; use rel_num_comp and rel_ret_comp. S1: both used. S2: no vector. S3: coverage good. S4: rel_num_comp high counts. confidence: 0.63",
      "implementation": "zscore(divide(rel_ret_comp, add(rel_num_comp,1)))",
      "confidence_level": 0.63
    },
    {
      "idea": "Partner return trend",
      "description": "ts_rank of partner returns detects persistent ranking among partners; combined with partner count. S1: ts_rank(rel_ret_part,10) and rel_num_part. S2: no vector. S3: coverage >0.6. S4: rel_num_part strong. confidence: 0.58",
      "implementation": "zscore(multiply(ts_rank(rel_ret_part,10), rel_num_part))",
      "confidence_level": 0.58
    },
    {
      "idea": "Competitor PageRank x HITS hub",
      "description": "Combine competitor PageRank and HITS hub to capture multi-metric centrality. S1: vec_avg(pv13_com_page_rank) and vec_avg(pv13_ompetitorgraphrank_hub_rank). S2: vec_avg used on both. S3: coverage high. S4: moderate confidence. confidence: 0.56",
      "implementation": "zscore(multiply(vec_avg(pv13_com_page_rank), vec_avg(pv13_ompetitorgraphrank_hub_rank)))",
      "confidence_level": 0.56
    },
    {
      "idea": "Customer return sign momentum",
      "description": "Use pv13_custretsig_retsig to flip or hold signals based on customer return sign applied to competitor returns. S1: pv13_custretsig_retsig and rel_ret_comp. S2: no vec. S3: pv13_custretsig_retsig coverage high, no backfill. S4: good counts. confidence: 0.62",
      "implementation": "multiply(pv13_custretsig_retsig, rel_ret_comp)",
      "confidence_level": 0.62
    },
    {
      "idea": "Index-value adjusted PageRank",
      "description": "Scale competitor PageRank by inverse index value to prioritize network signals in low market conditions. S1: vec_avg(pv13_com_page_rank) and pv13_revere_index_value. S2: vec_avg used. S3: index value coverage 1.0. S4: both well-used. confidence: 0.60",
      "implementation": "zscore(divide(vec_avg(pv13_com_page_rank), add(pv13_revere_index_value,1e-6)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Competitor return 1-day momentum",
      "description": "Use recent one-day competitor return (rel_ret_comp) ts_zscore(1) to detect immediate momentum, scaled by competitor count. S1: rel_ret_comp and rel_num_comp. S2: no vec. S3: coverage good. S4: high counts. confidence: 0.68",
      "implementation": "zscore(divide(ts_zscore(rel_ret_comp,3), add(rel_num_comp,1)))",
      "confidence_level": 0.68
    },
    {
      "idea": "Partner authority contrast",
      "description": "Difference between partner authority and competitor authority times partner returns identifies influential partners. S1: vec_avg(pv13_com_rk_au) and vec_avg(pv13_ustomergraphrank_auth_rank) and rel_ret_part (but limited to 2 datafields per rule) => chosen vec_avg partner auth and rel_ret_part. S2: vec_avg used. S3: rel_ret_part coverage ok. S4: fields have good counts. confidence: 0.57",
      "implementation": "zscore(multiply(vec_avg(pv13_ustomergraphrank_auth_rank), rel_ret_part))",
      "confidence_level": 0.57
    },
    {
      "idea": "Competition-induced volatility squeeze",
      "description": "Low ts_std_dev(rel_ret_comp,20) but rising rel_ret_comp suggests squeeze breakout. S1: ts_std_dev and rel_ret_comp used. S2: scalars. S3: coverage >0.6. S4: high counts. confidence: 0.65",
      "implementation": "zscore(multiply(reverse(ts_std_dev(rel_ret_comp,20)), rel_ret_comp))",
      "confidence_level": 0.65
    },
    {
      "idea": "Customer-to-partner return spread",
      "description": "Spread between customer and partner average returns as cross-network divergence indicator. S1: rel_ret_cust (backfilled) and rel_ret_part. S2: rel_ret_cust ts_backfill applied. S4: partner returns have high userCount. confidence: 0.54",
      "implementation": "zscore(subtract(ts_backfill(rel_ret_cust,5), rel_ret_part))",
      "confidence_level": 0.54
    },
    {
      "idea": "PageRank weighted competitor IR",
      "description": "Multiply competitor IR with competitor PageRank to find consistently influential peer movers. S1: ts_ir(rel_ret_comp,20) and vec_avg(pv13_com_page_rank). S2: vec_avg used. S3: coverage ok. S4: rel_ret_comp and page rank well-used. confidence: 0.66",
      "implementation": "zscore(multiply(ts_ir(rel_ret_comp,20), vec_avg(pv13_com_page_rank)))",
      "confidence_level": 0.66
    },
    {
      "idea": "Competitor return lagged lead",
      "description": "Compare current competitor return vs last week using ts_delta to find acceleration. S1: ts_delta(rel_ret_comp,5) and pv13_revere_index_cap. S2: no vec. S3: coverage good. S4: index cap robust. confidence: 0.64",
      "implementation": "zscore(divide(ts_delta(rel_ret_comp,5), pv13_revere_index_cap))",
      "confidence_level": 0.64
    },
    {
      "idea": "High product-overlap concentration",
      "description": "High rel_num_all with concentrated rel_ret_all suggests systemic product-led moves. S1: rel_num_all and rel_ret_all used. S2: no vec. S3: coverage high. S4: fields well-used. confidence: 0.61",
      "implementation": "zscore(multiply(rel_num_all, rel_ret_all))",
      "confidence_level": 0.61
    },
    {
      "idea": "Zipcode-group neutralized competitor return",
      "description": "Neutralize rel_ret_comp within zipcode to remove local biases. S1: group_neutralize(rel_ret_comp, pv13_revere_zipcode). S2: pv13_revere_zipcode used as group per KEEP_IN_MIND4. S3: coverage high. S4: rel_ret_comp reliable. confidence: 0.63",
      "implementation": "group_neutralize(rel_ret_comp, pv13_revere_zipcode)",
      "confidence_level": 0.63
    },
    {
      "idea": "High-level sector count trend",
      "description": "Use pv13_revere_key_sector_total to detect multi-sector firms vs competitor returns. S1: pv13_revere_key_sector_total and rel_ret_comp. S2: no vec. S3: key_sector_total coverage 1.0 so no backfill. S4: very high user/alpha counts increase confidence. confidence: 0.58",
      "implementation": "zscore(divide(rel_ret_comp, add(pv13_revere_key_sector_total,1)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Competitor HITS hub-authority ratio",
      "description": "Hub/authority ratio of competitors signals directionality; combine with rel_ret_comp. S1: vec_avg(pv13_ompetitorgraphrank_hub_rank) and vec_avg(pv13_com_rk_au). S2: vec_avg used for both. S3: coverage >0.6. S4: moderate counts. confidence: 0.55",
      "implementation": "zscore(divide(vec_avg(pv13_ompetitorgraphrank_hub_rank), add(vec_avg(pv13_com_rk_au),1e-6)))",
      "confidence_level": 0.55
    },
    {
      "idea": "Count-normalized product return",
      "description": "Normalize product-overlap returns by number of overlapping companies to find per-relationship strength. S1: rel_ret_all and rel_num_all. S2: no vec. S3: coverage high. S4: both well-used. confidence: 0.60",
      "implementation": "zscore(divide(rel_ret_all, add(rel_num_all,1)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Competitor return kurtosis filter",
      "description": "Use ts_kurtosis(rel_ret_comp,20) to detect fat-tailed peer moves that may revert. S1: ts_kurtosis and rel_ret_comp. S2: no vec. S3: coverage good. S4: rel_ret_comp high counts. confidence: 0.52",
      "implementation": "reverse(ts_kurtosis(rel_ret_comp,20))",
      "confidence_level": 0.52
    },
    {
      "idea": "Customer/PageRank momentum spread",
      "description": "Spread between competitor PageRank and customer PageRank times competitor returns picks structural shifts. S1: vec_avg(pv13_com_page_rank) and vec_avg(pv13_ustomergraphrank_page_rank) with rel_ret_comp. S2: must stay <=2 datafields -> chose competitor and customer page rank; applied vec_avg on both and multiply. S3: no backfill needed. S4: both fields used. confidence: 0.56",
      "implementation": "zscore(multiply(subtract(vec_avg(pv13_com_page_rank), vec_avg(pv13_ustomergraphrank_page_rank)), 1))",
      "confidence_level": 0.56
    },
    {
      "idea": "Partner return directional indicator",
      "description": "Sign of partner returns times competitor returns to detect aligned moves. S1: rel_ret_part and rel_ret_comp. S2: no vec. S3: coverage >0.6. S4: rel_ret_part widely used. confidence: 0.59",
      "implementation": "multiply(sign(rel_ret_part), rel_ret_comp)",
      "confidence_level": 0.59
    },
    {
      "idea": "Index-cap bucketing momentum",
      "description": "Bucket competitor returns by index cap to trade different cap segments. S1: bucket(rel_ret_comp, range='0,1,0.25') with pv13_revere_index_cap as scaling. S2: no vec. S3: coverage full. S4: index cap has highest userCount. confidence: 0.60",
      "implementation": "bucket(zscore(divide(rel_ret_comp, pv13_revere_index_cap)), range='0,1,0.25')",
      "confidence_level": 0.6
    },
    {
      "idea": "Customers count-weighted return",
      "description": "Scale customer returns by number of customers to detect intensity. S1: rel_ret_cust (backfilled) and rel_num_cust (backfilled). S2: both backfilled due to coverage <0.6. S4: userCounts moderate. confidence: 0.50",
      "implementation": "zscore(divide(ts_backfill(rel_ret_cust,5), add(ts_backfill(rel_num_cust,5),1)))",
      "confidence_level": 0.5
    },
    {
      "idea": "Competitor recent argmax",
      "description": "If competitor today is the max over lookback period, it signals leadership; use ts_arg_max(rel_ret_comp,7) and pv13_revere_index_cap. S1: ts_arg_max applied. S3: coverage ok. S4: rel_ret_comp robust. confidence: 0.62",
      "implementation": "zscore(multiply(ts_arg_max(rel_ret_comp,7), pv13_revere_index_cap))",
      "confidence_level": 0.62
    },
    {
      "idea": "Product overlap product-count momentum",
      "description": "Multiply number of overlapping companies by average overlapping return to capture aggregate product pressure. S1: rel_num_all and rel_ret_all used. S2: no vec. S3: high coverage. S4: reliable counts. confidence: 0.63",
      "implementation": "zscore(multiply(rel_num_all, rel_ret_all))",
      "confidence_level": 0.63
    },
    {
      "idea": "Vec-sum competitor ranks",
      "description": "Use vec_sum of competitor PageRank as absolute centrality measure against competitor returns. S1: vec_sum(pv13_com_page_rank) and rel_ret_comp. S2: vec_sum per SUGGESTION2. S3: coverage high. S4: both solid usage. confidence: 0.58",
      "implementation": "zscore(multiply(vec_sum(pv13_com_page_rank), rel_ret_comp))",
      "confidence_level": 0.58
    },
    {
      "idea": "Customers IR relative to company size",
      "description": "Customer return IR divided by company cap to find efficient customer-driven growth. S1: ts_ir(rel_ret_cust,20) backfilled and pv13_revere_index_cap. S2: ts_backfill applied to rel_ret_cust first. S4: index cap strong. confidence: 0.53",
      "implementation": "zscore(divide(ts_ir(ts_backfill(rel_ret_cust,10),20), pv13_revere_index_cap))",
      "confidence_level": 0.53
    },
    {
      "idea": "Competitor return product overlap interaction",
      "description": "Interaction of rel_ret_comp and rel_num_all reveals if competitor moves are concentrated in overlapping products. S1: rel_ret_comp and rel_num_all used. S2: no vec. S3: coverage good. S4: both widely used. confidence: 0.64",
      "implementation": "zscore(multiply(rel_ret_comp, rel_num_all))",
      "confidence_level": 0.64
    },
    {
      "idea": "PageRank change vs index move",
      "description": "ts_delta(vec_avg(pv13_com_page_rank),3) multiplied by ts_delta(pv13_revere_index_value,1) captures synchronized shifts. S1: vec_avg+ts_delta and index delta used. S2: vec_avg used. S3: no backfill needed. S4: strong data usage. confidence: 0.59",
      "implementation": "zscore(multiply(ts_delta(vec_avg(pv13_com_page_rank),3), ts_delta(pv13_revere_index_value,1)))",
      "confidence_level": 0.59
    },
    {
      "idea": "Competitor return productivity ratio",
      "description": "Divide competitor returns by number of competitors to get per-competitor impact. S1: rel_ret_comp and rel_num_comp used. S2: no vec. S3: coverage good. S4: high counts. confidence: 0.66",
      "implementation": "zscore(divide(rel_ret_comp, add(rel_num_comp,1)))",
      "confidence_level": 0.66
    },
    {
      "idea": "Customer HITS authority momentum",
      "description": "Multiply customer authority score with customer returns to detect influential customer-driven signals. S1: vec_avg(pv13_ustomergraphrank_auth_rank) and rel_ret_cust (backfilled). S2: vec_avg used. S3: backfilled rel_ret_cust. S4: moderate counts. confidence: 0.54",
      "implementation": "zscore(multiply(vec_avg(pv13_ustomergraphrank_auth_rank), ts_backfill(rel_ret_cust,5)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Competition return divided by sector depth",
      "description": "Normalize competitor returns by sector level (pv13_revere_level) to adjust for hierarchical noise. S1: rel_ret_comp and pv13_revere_level. S2: pv13_revere_level coverage 0.6205 (>0.6) so no backfill. S4: level has moderate userCount. confidence: 0.56",
      "implementation": "zscore(divide(rel_ret_comp, add(pv13_revere_level,1e-6)))",
      "confidence_level": 0.56
    },
    {
      "idea": "Partner returns recent sum",
      "description": "ts_sum(rel_ret_part,5) identifies short-term partner pressure; combine with pv13_revere_index_cap. S1: ts_sum and pv13_revere_index_cap. S2: no vec. S3: coverage >0.6. S4: partner return usage high. confidence: 0.62",
      "implementation": "zscore(divide(ts_sum(rel_ret_part,5), pv13_revere_index_cap))",
      "confidence_level": 0.62
    },
    {
      "idea": "Competitor return quantile filter",
      "description": "Use quantile(rel_ret_comp) to pick top peer movers, scaled by index cap. S1: quantile and pv13_revere_index_cap. S2: no vec. S3: no backfill. S4: rel_ret_comp widely used. confidence: 0.67",
      "implementation": "zscore(multiply(quantile(rel_ret_comp), inverse(pv13_revere_index_cap)))",
      "confidence_level": 0.67
    },
    {
      "idea": "High-authority competitor concentration",
      "description": "High vec_max of competitor authority signals a dominant peer; trade based on that vs rel_ret_comp. S1: vec_max(pv13_com_rk_au) and rel_ret_comp. S2: vec_max applied. S3: coverage ok. S4: reliable counts. confidence: 0.58",
      "implementation": "zscore(multiply(vec_max(pv13_com_rk_au), rel_ret_comp))",
      "confidence_level": 0.58
    },
    {
      "idea": "Customers' returns momentum vs industry index",
      "description": "Compare ts_zscore(rel_ret_cust,10) (backfilled) with ts_delta(pv13_revere_index_value,1) to detect relative strength. S1: backfilled customer returns and index delta used. S4: index data robust. confidence: 0.55",
      "implementation": "zscore(subtract(ts_zscore(ts_backfill(rel_ret_cust,5),10), ts_delta(pv13_revere_index_value,1)))",
      "confidence_level": 0.55
    },
    {
      "idea": "Competition count growth signal",
      "description": "Rising rel_num_comp (ts_delta) with falling rel_ret_comp indicates competitive pressure; trade short. S1: ts_delta(rel_num_comp,7) and rel_ret_comp. S2: no vec. S3: coverage good. S4: rel_num_comp high usage. confidence: 0.60",
      "implementation": "reverse(multiply(ts_delta(rel_num_comp,7), rel_ret_comp))",
      "confidence_level": 0.6
    },
    {
      "idea": "vec_avg authority x product-overlap",
      "description": "Multiply vec_avg competitor authority with rel_num_all to find influential product overlaps. S1: vec_avg(pv13_com_rk_au) and rel_num_all. S2: vec_avg used. S3: coverage high. S4: both used often. confidence: 0.57",
      "implementation": "zscore(multiply(vec_avg(pv13_com_rk_au), rel_num_all))",
      "confidence_level": 0.57
    },
    {
      "idea": "Customer/competitor return divergence",
      "description": "Divergence between rel_ret_cust (backfilled) and rel_ret_comp flags shifting demand vs competition dynamics. S1: ts_backfill applied to rel_ret_cust. S2: used both fields. S4: moderate counts. confidence: 0.53",
      "implementation": "zscore(subtract(ts_backfill(rel_ret_cust,5), rel_ret_comp))",
      "confidence_level": 0.53
    },
    {
      "idea": "Partner count momentum multiplier",
      "description": "Multiply ts_zscore(rel_ret_part,5) by rel_num_part to scale momentum by partner breadth. S1: ts_zscore and rel_num_part. S2: no vec. S3: coverage >0.6. S4: rel_num_part high usage. confidence: 0.59",
      "implementation": "zscore(multiply(ts_zscore(rel_ret_part,5), rel_num_part))",
      "confidence_level": 0.59
    },
    {
      "idea": "Competitor PageRank tail cap",
      "description": "Winsorize vec_avg competitor PageRank and multiply by rel_ret_comp to reduce outliers. S1: winsorize(vec_avg(pv13_com_page_rank)) and rel_ret_comp. S2: vec_avg used. S3: coverage okay. S4: page rank widely used. confidence: 0.60",
      "implementation": "zscore(multiply(winsorize(vec_avg(pv13_com_page_rank), std=4), rel_ret_comp))",
      "confidence_level": 0.6
    },
    {
      "idea": "High product-overlap info ratio",
      "description": "ts_ir(rel_ret_all,20) scaled by rel_num_all to find consistent product-linked movers. S1: ts_ir and rel_num_all. S2: no vec. S3: coverage good. S4: rel_ret_all strong. confidence: 0.62",
      "implementation": "zscore(multiply(ts_ir(rel_ret_all,20), rel_num_all))",
      "confidence_level": 0.62
    },
    {
      "idea": "PageRank mean-reversion",
      "description": "Reverse zscore of vec_avg competitor PageRank to play mean reversion in network centrality. S1: vec_avg(pv13_com_page_rank) used alone for simplicity. S2: SUGGESTION1 partially applied (single field) due to conceptual focus. S3: coverage high so no backfill. S4: page rank widespread usage increases confidence. confidence: 0.51",
      "implementation": "reverse(zscore(vec_avg(pv13_com_page_rank)))",
      "confidence_level": 0.51
    },
    {
      "idea": "Competitor return rolling rank",
      "description": "ts_rank(rel_ret_comp,20) finds persistent peer rankings, scaled by index cap. S1: ts_rank and pv13_revere_index_cap. S2: no vec. S3: coverage ok. S4: rel_ret_comp widely used. confidence: 0.64",
      "implementation": "zscore(divide(ts_rank(rel_ret_comp,20), pv13_revere_index_cap))",
      "confidence_level": 0.64
    },
    {
      "idea": "Customer hub-authority spread vs returns",
      "description": "Difference between customer hub and authority (vec_avg) multiplied by rel_ret_cust (backfilled) to capture structural shifts. S1: vec_avg both and rel_ret_cust backfilled. S4: balanced usage. confidence: 0.53",
      "implementation": "zscore(multiply(subtract(vec_avg(pv13_ustomergraphrank_hub_rank), vec_avg(pv13_ustomergraphrank_auth_rank)), ts_backfill(rel_ret_cust,5)))",
      "confidence_level": 0.53
    },
    {
      "idea": "Competitor return product momentum cross",
      "description": "Multiply rel_ret_comp with rel_ret_all to capture combined competitor and product overlap momentum. S1: both used. S2: no vec. S3: coverage high. S4: both frequently used. confidence: 0.65",
      "implementation": "zscore(multiply(rel_ret_comp, rel_ret_all))",
      "confidence_level": 0.65
    },
    {
      "idea": "Index cap quantile-adjusted returns",
      "description": "Quantile(rel_ret_comp) within index-cap buckets to identify unusual peer moves in cap segments. S1: quantile(rel_ret_comp) and pv13_revere_index_cap. S2: no vec. S3: coverage full. S4: index cap strong. confidence: 0.66",
      "implementation": "zscore(divide(quantile(rel_ret_comp), pv13_revere_index_cap))",
      "confidence_level": 0.66
    },
    {
      "idea": "Customer count vs PageRank impact",
      "description": "Multiply customer count with vec_avg customer PageRank to find dense influential customer bases. S1: rel_num_cust (backfilled) and vec_avg(pv13_ustomergraphrank_page_rank). S2: applied ts_backfill to rel_num_cust due coverage<0.6. S4: PageRank moderate usage. confidence: 0.52",
      "implementation": "zscore(multiply(ts_backfill(rel_num_cust,10), vec_avg(pv13_ustomergraphrank_page_rank)))",
      "confidence_level": 0.52
    },
    {
      "idea": "Competitor return vs terminal-sector count",
      "description": "Relate rel_ret_comp to pv13_revere_term_sector_total to control for breadth; used both fields. S1: no vec. S3: term_sector_total coverage 1.0. S4: high counts. confidence: 0.57",
      "implementation": "zscore(divide(rel_ret_comp, add(pv13_revere_term_sector_total,1)))",
      "confidence_level": 0.57
    },
    {
      "idea": "Vec_stddev authority x returns",
      "description": "High vec_stddev of competitor authority indicates inequality; multiply by rel_ret_comp to capture concentrated moves. S1: vec_stddev(pv13_com_rk_au) and rel_ret_comp. S2: vec_stddev used. S3: coverage good. S4: both used often. confidence: 0.58",
      "implementation": "zscore(multiply(vec_stddev(pv13_com_rk_au), rel_ret_comp))",
      "confidence_level": 0.58
    },
    {
      "idea": "Customer sign x partner returns",
      "description": "Use pv13_custretsig_retsig to sign rel_ret_part to detect directional partner pressure. S1: pv13_custretsig_retsig and rel_ret_part. S2: no vec. S3: custretsig coverage high. S4: both fields used. confidence: 0.60",
      "implementation": "multiply(pv13_custretsig_retsig, rel_ret_part)",
      "confidence_level": 0.6
    },
    {
      "idea": "Competitor return vs total companies in sector",
      "description": "Normalize competitor returns by pv13_revere_company_total to adjust for sector size. S1: rel_ret_comp and pv13_revere_company_total. S2: this field coverage 0.3508 -> ts_backfill applied. S4: company_total userCount moderate. confidence: 0.49",
      "implementation": "zscore(divide(rel_ret_comp, add(ts_backfill(pv13_revere_company_total,10),1)))",
      "confidence_level": 0.49
    },
    {
      "idea": "Vec_avg competitor authority momentum",
      "description": "ts_zscore(vec_avg(pv13_com_rk_au),10) to detect momentum in competitor authority itself. S1: vec_avg used alone. S2: SUGGESTION1 partially applied. S3: coverage good. S4: authoritative field strong. confidence: 0.55",
      "implementation": "ts_zscore(vec_avg(pv13_com_rk_au),10)",
      "confidence_level": 0.55
    },
    {
      "idea": "Partner return decay-adjusted alpha",
      "description": "Apply ts_decay_linear on rel_ret_part to reduce turnover and combine with pv13_revere_index_cap. S1: ts_decay_linear(rel_ret_part,5) and pv13_revere_index_cap. S2: no vec. S3: coverage ok. S4: partner returns strong. confidence: 0.60",
      "implementation": "zscore(divide(ts_decay_linear(rel_ret_part,5), pv13_revere_index_cap))",
      "confidence_level": 0.6
    },
    {
      "idea": "Customer PageRank max spike",
      "description": "If vec_max(customer PageRank) jumps and customers' returns rise, signal momentum. S1: vec_max(pv13_ustomergraphrank_page_rank) and rel_ret_cust (backfilled). S2: vec_max used. S3: backfilled rel_ret_cust. S4: moderate confidence. confidence: 0.52",
      "implementation": "zscore(multiply(vec_max(pv13_ustomergraphrank_page_rank), ts_backfill(rel_ret_cust,5)))",
      "confidence_level": 0.52
    },
    {
      "idea": "Competition count neutralized returns",
      "description": "Neutralize rel_ret_comp by groups of pv13_revere_index_cap buckets to remove cap-driven bias (use bucket as group). S1: group_neutralize(rel_ret_comp, pv13_revere_index_cap). S2: pv13_revere_index_cap used as group per KEEP_IN_MIND4. S3: coverage full. S4: high userCount. confidence: 0.65",
      "implementation": "group_neutralize(rel_ret_comp, pv13_revere_index_cap)",
      "confidence_level": 0.65
    },
    {
      "idea": "PageRank range mean-revert",
      "description": "Reverse zscore of vec_range(pv13_com_page_rank) to capture reverting centrality shocks. S1: vec_range used alone to be concise. S2: per SUGGESTION1 minimal. S3: coverage high. S4: good usage. confidence: 0.50",
      "implementation": "reverse(zscore(vec_range(pv13_com_page_rank)))",
      "confidence_level": 0.5
    },
    {
      "idea": "Competitor return sum momentum",
      "description": "ts_sum(rel_ret_comp,3) captures short-run cumulative peer moves; scale by rel_num_comp. S1: ts_sum and rel_num_comp. S2: no vec. S3: coverage good. S4: high usage. confidence: 0.66",
      "implementation": "zscore(divide(ts_sum(rel_ret_comp,3), add(rel_num_comp,1)))",
      "confidence_level": 0.66
    },
    {
      "idea": "Partner vs competitor IR spread",
      "description": "ts_ir(rel_ret_part,20) minus ts_ir(rel_ret_comp,20) to find relative reliability of partner vs competitor signals. S1: both ts_ir applied. S2: no vec. S3: coverage >0.6. S4: strong userCounts on rel_ret_comp. confidence: 0.61",
      "implementation": "zscore(subtract(ts_ir(rel_ret_part,20), ts_ir(rel_ret_comp,20)))",
      "confidence_level": 0.61
    },
    {
      "idea": "Customer/partner combined signal",
      "description": "Average of customer and partner returns to find network-wide momentum; rel_ret_cust backfilled. S1: add(ts_backfill(rel_ret_cust,5), rel_ret_part). S2: add used to combine two fields. S3: rel_ret_cust backfilled. S4: partner returns strong. confidence: 0.56",
      "implementation": "zscore(divide(add(ts_backfill(rel_ret_cust,5), rel_ret_part),2))",
      "confidence_level": 0.56
    },
    {
      "idea": "Vec_avg PageRank x product overlap",
      "description": "Multiply vec_avg competitor PageRank by rel_num_all to capture influential product overlaps. S1: vec_avg and rel_num_all used. S2: vec_avg applied. S3: coverage high. S4: both used often. confidence: 0.59",
      "implementation": "zscore(multiply(vec_avg(pv13_com_page_rank), rel_num_all))",
      "confidence_level": 0.59
    },
    {
      "idea": "Competitor return volatility breakout",
      "description": "High ts_std_dev(rel_ret_comp,10) combined with positive rel_ret_comp predicts breakout continuation. S1: ts_std_dev and rel_ret_comp used. S2: no vec. S3: good coverage. S4: reliable counts. confidence: 0.63",
      "implementation": "zscore(multiply(ts_std_dev(rel_ret_comp,10), rel_ret_comp))",
      "confidence_level": 0.63
    },
    {
      "idea": "Authority-weighted customer return",
      "description": "Multiply customer authority vec_avg by customers' returns (backfilled) to find authoritative demand signals. S1: vec_avg(pv13_ustomergraphrank_auth_rank) and rel_ret_cust backfilled. S2: vec_avg used. S3: backfill applied to rel_ret_cust due low coverage. S4: moderate counts. confidence: 0.53",
      "implementation": "zscore(multiply(vec_avg(pv13_ustomergraphrank_auth_rank), ts_backfill(rel_ret_cust,5)))",
      "confidence_level": 0.53
    },
    {
      "idea": "Competitor return autoregressive shock",
      "description": "ts_regression(rel_ret_comp, ts_step(1),20) slope identifies trending peers; combine with page rank. S1: ts_regression and vec_avg(pv13_com_page_rank). S2: vec_avg used. S3: coverage ok. S4: rel_ret_comp strong. confidence: 0.62",
      "implementation": "zscore(multiply(ts_regression(rel_ret_comp, ts_step(1),20,0,0), vec_avg(pv13_com_page_rank)))",
      "confidence_level": 0.62
    },
    {
      "idea": "Customer-weighted competition pressure",
      "description": "Multiply rel_num_cust (backfilled) by rel_ret_comp to capture customer-based competitive pressure. S1: ts_backfill(rel_num_cust,10) and rel_ret_comp. S2: backfilled due to coverage<0.6. S4: rel_ret_comp robust. confidence: 0.51",
      "implementation": "zscore(multiply(ts_backfill(rel_num_cust,10), rel_ret_comp))",
      "confidence_level": 0.51
    },
    {
      "idea": "Index-value momentum vs competitor PageRank",
      "description": "Compare ts_zscore(pv13_revere_index_value,5) with vec_avg competitor PageRank to find index-driven network moves. S1: ts_zscore and vec_avg used. S3: index value full coverage. S4: page rank widely used. confidence: 0.58",
      "implementation": "zscore(multiply(ts_zscore(pv13_revere_index_value,5), vec_avg(pv13_com_page_rank)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Partner return argmax signal",
      "description": "If a partner's return is the recent max (ts_arg_max), scale focal by that indicator. S1: ts_arg_max(rel_ret_part,10) and pv13_revere_index_cap. S2: no vec. S3: coverage ok. S4: partner returns high usage. confidence: 0.56",
      "implementation": "zscore(multiply(ts_arg_max(rel_ret_part,10), pv13_revere_index_cap))",
      "confidence_level": 0.56
    },
    {
      "idea": "Competitor PageRank to authority ratio",
      "description": "Divide vec_avg page rank by vec_avg authority to find structural differences. S1: vec_avg(pv13_com_page_rank) and vec_avg(pv13_com_rk_au). S2: vec_avg both. S3: coverage ok. S4: moderate counts. confidence: 0.54",
      "implementation": "zscore(divide(vec_avg(pv13_com_page_rank), add(vec_avg(pv13_com_rk_au),1e-6)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Competition count spike vs returns",
      "description": "If rel_num_comp increases sharply (ts_delta) while rel_ret_comp falls, signal potential sell. S1: ts_delta(rel_num_comp,7) and rel_ret_comp. S2: no vec. S3: coverage ok. S4: high counts. confidence: 0.61",
      "implementation": "reverse(multiply(ts_delta(rel_num_comp,7), reverse(rel_ret_comp)))",
      "confidence_level": 0.61
    },
    {
      "idea": "Product overlap rolling sum impact",
      "description": "ts_sum(rel_ret_all,5) times rel_num_all to capture repeated product-driven pressure. S1: ts_sum and rel_num_all. S2: no vec. S3: coverage high. S4: stable usage. confidence: 0.62",
      "implementation": "zscore(multiply(ts_sum(rel_ret_all,5), rel_num_all))",
      "confidence_level": 0.62
    },
    {
      "idea": "Customer/partner concordance indicator",
      "description": "Sign agreement between customer and partner returns: sign(rel_ret_cust(backfilled)) * sign(rel_ret_part). S1: ts_backfill for rel_ret_cust. S2: no vec. S4: moderate counts. confidence: 0.50",
      "implementation": "multiply(sign(ts_backfill(rel_ret_cust,5)), sign(rel_ret_part))",
      "confidence_level": 0.5
    },
    {
      "idea": "Competitor returns zscore cross-product",
      "description": "Multiply zscore(rel_ret_comp) with zscore(rel_ret_all) to find joint extremal peer-product moves. S1: zscore both fields. S2: no vec. S3: coverage good. S4: both widely used. confidence: 0.65",
      "implementation": "multiply(zscore(rel_ret_comp), zscore(rel_ret_all))",
      "confidence_level": 0.65
    },
    {
      "idea": "Authority-weighted product overlap",
      "description": "Multiply vec_avg(pv13_com_rk_au) by rel_num_all to weight overlaps by competitor authority. S1: vec_avg and rel_num_all used. S2: vec_avg applied. S3: coverage good. S4: both well-used. confidence: 0.58",
      "implementation": "zscore(multiply(vec_avg(pv13_com_rk_au), rel_num_all))",
      "confidence_level": 0.58
    },
    {
      "idea": "PageRank percentile momentum",
      "description": "quantile(vec_avg(pv13_com_page_rank)) times rel_ret_comp to pick top centrality movers. S1: vec_avg page rank and rel_ret_comp used. S2: vec_avg used. S3: coverage high. S4: page rank strong usage. confidence: 0.60",
      "implementation": "zscore(multiply(quantile(vec_avg(pv13_com_page_rank)), rel_ret_comp))",
      "confidence_level": 0.6
    },
    {
      "idea": "Customers vs index divergence",
      "description": "Subtract ts_zscore(pv13_revere_index_value,5) from ts_zscore(rel_ret_cust(backfilled),5) to find idiosyncratic customer strength. S1: backfill applied to rel_ret_cust. S4: index robust. confidence: 0.54",
      "implementation": "zscore(subtract(ts_zscore(ts_backfill(rel_ret_cust,5),5), ts_zscore(pv13_revere_index_value,5)))",
      "confidence_level": 0.54
    },
    {
      "idea": "vec_min competitor authority risk",
      "description": "Low vec_min of competitor authority combined with rising rel_ret_comp suggests concentrated top performers; trade accordingly. S1: vec_min(pv13_com_rk_au) and rel_ret_comp. S2: vec_min used. S3: coverage good. S4: moderate counts. confidence: 0.53",
      "implementation": "zscore(multiply(reverse(vec_min(pv13_com_rk_au)), rel_ret_comp))",
      "confidence_level": 0.53
    }
  ]
}