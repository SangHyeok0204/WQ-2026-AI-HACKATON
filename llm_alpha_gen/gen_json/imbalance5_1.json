{
  "results": [
    {
      "idea": "Cross-sectional high imb5_score long / low short",
      "description": "Uses imb5_score as primary signal. Applied SUGGESTION1 (single strong datafield) and SUGGESTION4 (imb5_score has high user/alphaCount). SUGGESTION2 not applicable (no vector fields). SUGGESTION3 not applied (coverage > 0.6). Kept KEEP_IN_MINDs: used ≤2 datafields and <7 operators. Confidence: 0.70",
      "implementation": "quantile(imb5_score)",
      "confidence_level": 0.7
    },
    {
      "idea": "Score momentum (short-term) — recent change in imb5_score",
      "description": "Short-term momentum using ts_delta on imb5_score. S1 used single field; S2 not applicable; S3 not needed; S4 applied. Keep implementation short. Confidence: 0.60",
      "implementation": "ts_delta(imb5_score,5)",
      "confidence_level": 0.6
    },
    {
      "idea": "Score mean-reversion (short zscore) — prefer negative recent zscore",
      "description": "Prefer instruments with negative recent deviation in imb5_score (mean-revert). S1,S4 applied; S2,S3 not relevant. Implementation kept simple. Confidence: 0.62",
      "implementation": "reverse(ts_zscore(imb5_score,20))",
      "confidence_level": 0.62
    },
    {
      "idea": "Score volatility-adjusted signal (score divided by its volatility)",
      "description": "Stabilize by dividing imb5_score by its ts_std_dev. S1 used one field; S2,S3 not used; S4 applied. Respect operator/data limits. Confidence: 0.66",
      "implementation": "divide(imb5_score, ts_std_dev(imb5_score,20))",
      "confidence_level": 0.66
    },
    {
      "idea": "Small-cap tilt on score (favor high score & small mktcap)",
      "description": "Combine imb5_score with inverse mktcap to target small-cap high-score names. S1 used both fields; S4 used high counts. S3 not needed. Confidence: 0.68",
      "implementation": "multiply(imb5_score, inverse(imb5_mktcap))",
      "confidence_level": 0.68
    },
    {
      "idea": "Score normalized cross-sectionally (zscore)",
      "description": "Normalize imb5_score cross-sectionally to remove level bias. Used S1 and S4; others not applicable. Simple implementation. Confidence: 0.65",
      "implementation": "zscore(imb5_score)",
      "confidence_level": 0.65
    },
    {
      "idea": "Recent upswing in score scaled by market cap (momentum small-cap)",
      "description": "ts_delta(imb5_score,10) divided by imb5_mktcap to prefer recent movers in small names. Applied S1,S4. No vector; coverage OK. Confidence: 0.63",
      "implementation": "divide(ts_delta(imb5_score,10), imb5_mktcap)",
      "confidence_level": 0.63
    },
    {
      "idea": "Cross-sectional rank momentum (short vs long window)",
      "description": "Difference of short vs long ts_rank of imb5_score to capture accelerating score ranks. S1,S4 applied. Kept operator count low. Confidence: 0.61",
      "implementation": "subtract(ts_rank(imb5_score,5), ts_rank(imb5_score,20))",
      "confidence_level": 0.61
    },
    {
      "idea": "Score stability preference (prefer stable score history)",
      "description": "Use reverse of ts_std_dev of imb5_score to prefer stable scorers. Applied S1,S4. S3,S2 not needed. Confidence: 0.55",
      "implementation": "reverse(ts_std_dev(imb5_score,60))",
      "confidence_level": 0.55
    },
    {
      "idea": "Score IR (information ratio) over 60 days",
      "description": "Use ts_ir(imb5_score,60) to prefer instruments with consistent score signal. S1,S4 used. Coverage OK. Confidence: 0.64",
      "implementation": "ts_ir(imb5_score,60)",
      "confidence_level": 0.64
    },
    {
      "idea": "Score quantile time-series (recent percentile)",
      "description": "ts_quantile to find how extreme current imb5_score is within recent history. S1,S4 applied. S2,S3 not relevant. Confidence: 0.60",
      "implementation": "ts_quantile(imb5_score,20)",
      "confidence_level": 0.6
    },
    {
      "idea": "Cross-sectional score scaled by log mktcap (dampen large caps)",
      "description": "Divide quantile(imb5_score) by log(imb5_mktcap) to de-emphasize large caps. S1,S4 applied. Kept operator usage small. Confidence: 0.62",
      "implementation": "divide(quantile(imb5_score), log(imb5_mktcap))",
      "confidence_level": 0.62
    },
    {
      "idea": "Long recent increases in score but penalize high mktcap (momentum × small-cap)",
      "description": "Multiply ts_delta(imb5_score,7) by inverse mktcap. S1 used both fields; S4 used. No backfill needed. Confidence: 0.63",
      "implementation": "multiply(ts_delta(imb5_score,7), inverse(imb5_mktcap))",
      "confidence_level": 0.63
    },
    {
      "idea": "Score power transform to emphasize extremes",
      "description": "Apply signed_power to imb5_score to emphasize tails while preserving sign. S1,S4 applied. S2,S3 not relevant. Confidence: 0.50",
      "implementation": "signed_power(imb5_score,1.5)",
      "confidence_level": 0.5
    },
    {
      "idea": "Square-root dampened score (compress extremes)",
      "description": "Apply signed_power with exponent 0.5 to reduce outliers. S1,S4 used. Operators minimal. Confidence: 0.48",
      "implementation": "signed_power(imb5_score,0.5)",
      "confidence_level": 0.48
    },
    {
      "idea": "Winsorized zscore of score (limit outliers)",
      "description": "ts_zscore then winsorize to control outliers. S1,S4 applied; coverage OK (no backfill). Confidence: 0.59",
      "implementation": "winsorize(ts_zscore(imb5_score,20), std=3)",
      "confidence_level": 0.59
    },
    {
      "idea": "Score scaled in time (ts_scale) to recent range",
      "description": "Use ts_scale to map imb5_score into recent min-max range. S1,S4 applied. Simplicity ensured. Confidence: 0.56",
      "implementation": "ts_scale(imb5_score,20)",
      "confidence_level": 0.56
    },
    {
      "idea": "Score kurtosis filter (prefer low-kurtosis signals)",
      "description": "Reverse ts_kurtosis(imb5_score,60) to prefer instruments with low extreme tails. S1,S4 applied; S3 not needed. Confidence: 0.45",
      "implementation": "reverse(ts_kurtosis(imb5_score,60))",
      "confidence_level": 0.45
    },
    {
      "idea": "Score returns (percentage change) short-term",
      "description": "Use ts_returns on imb5_score to capture relative change. S1,S4 applied. Low operator count. Confidence: 0.52",
      "implementation": "ts_returns(imb5_score,5)",
      "confidence_level": 0.52
    },
    {
      "idea": "Relative score momentum vs mktcap (regressive risk adjustment)",
      "description": "Divide ts_delta(imb5_score,10) by ts_std_dev(imb5_mktcap,60) to adjust score moves by marketcap volatility. S1 used both fields; S4 applied. Confidence: 0.58",
      "implementation": "divide(ts_delta(imb5_score,10), ts_std_dev(imb5_mktcap,60))",
      "confidence_level": 0.58
    },
    {
      "idea": "Recent peak timing: prefer current local maxima in score",
      "description": "Use ts_arg_max to detect recent maximum in window and prefer instruments at peaks. S1,S4 applied. Kept operators minimal. Confidence: 0.50",
      "implementation": "reverse(ts_arg_max(imb5_score,30))",
      "confidence_level": 0.5
    },
    {
      "idea": "Recent trough timing: prefer current local minima in score",
      "description": "Use ts_arg_min to detect recent minima and long those (mean-revert). S1,S4 applied; S2/S3 irrelevant. Confidence: 0.50",
      "implementation": "ts_arg_min(imb5_score,30)",
      "confidence_level": 0.5
    },
    {
      "idea": "Score minus its recent average (deviation from mean)",
      "description": "ts_av_diff(imb5_score,20) highlights deviation from recent mean. S1,S4 applied. Simple. Confidence: 0.57",
      "implementation": "ts_av_diff(imb5_score,20)",
      "confidence_level": 0.57
    },
    {
      "idea": "Combine cross-sectional zscore and time-series momentum",
      "description": "Multiply cross-sectional zscore with short ts_delta to get names that are extreme now and gaining. Applied S1,S4. S2,S3 not used. Confidence: 0.65",
      "implementation": "multiply(zscore(imb5_score), ts_delta(imb5_score,5))",
      "confidence_level": 0.65
    },
    {
      "idea": "Score mean over month (smoother signal)",
      "description": "ts_mean(imb5_score,21) to smooth daily noise. S1,S4 applied; kept simple. Confidence: 0.54",
      "implementation": "ts_mean(imb5_score,21)",
      "confidence_level": 0.54
    },
    {
      "idea": "Score divided by log mktcap (favor high score in smaller names)",
      "description": "Divide imb5_score by log(imb5_mktcap). S1 used both fields; S4 considered. No ts_backfill needed. Confidence: 0.62",
      "implementation": "divide(imb5_score, log(imb5_mktcap))",
      "confidence_level": 0.62
    },
    {
      "idea": "Inverse marketcap weighted score (explicit small-cap weighting)",
      "description": "quantile( multiply(imb5_score, inverse(imb5_mktcap)) ) to rank high-score small caps. S1 and S4 applied. Operators kept ≤7. Confidence: 0.67",
      "implementation": "quantile(multiply(imb5_score, inverse(imb5_mktcap)))",
      "confidence_level": 0.67
    },
    {
      "idea": "Score acceleration (second derivative)",
      "description": "ts_delta(ts_delta(imb5_score,3),3) to capture accelerating score moves. S1,S4 applied. Simple chain. Confidence: 0.53",
      "implementation": "ts_delta(ts_delta(imb5_score,3),3)",
      "confidence_level": 0.53
    },
    {
      "idea": "Score divided by its rolling max draw (normalize by max)",
      "description": "divide(imb5_score, ts_max_diff(imb5_score,60)) where ts_max_diff = current - rolling max; reverse to prefer closers to highs. S1,S4 used. Confidence: 0.55",
      "implementation": "divide(imb5_score, ts_max_diff(imb5_score,60))",
      "confidence_level": 0.55
    },
    {
      "idea": "Combine score quantile and time-series zscore",
      "description": "Multiply ts_zscore(imb5_score,20) by quantile(imb5_score) to favor persistent extremes. S1,S4 applied. Confidence: 0.63",
      "implementation": "multiply(ts_zscore(imb5_score,20), quantile(imb5_score))",
      "confidence_level": 0.63
    },
    {
      "idea": "Damp score by sqrt of mktcap to reduce large-cap dominance",
      "description": "divide(imb5_score, sqrt(imb5_mktcap)) to lower influence of large caps. S1,S4 applied; S3 not needed. Confidence: 0.60",
      "implementation": "divide(imb5_score, sqrt(imb5_mktcap))",
      "confidence_level": 0.6
    },
    {
      "idea": "Score sign-based sizing (use sign to get direction only)",
      "description": "sign(imb5_score) for pure directional exposure where magnitude unreliable. S1,S4 applied. Minimal operators. Confidence: 0.42",
      "implementation": "sign(imb5_score)",
      "confidence_level": 0.42
    },
    {
      "idea": "Score scaled to booksize (scale operator)",
      "description": "Use scale to convert score into position size. S1,S4 applied. Kept to one field. Confidence: 0.58",
      "implementation": "scale(imb5_score)",
      "confidence_level": 0.58
    },
    {
      "idea": "Score short-term rank reversal (short rank negative)",
      "description": "reverse(ts_rank(imb5_score,5)) to short recent high rank (contrarian). S1,S4 applied. Confidence: 0.49",
      "implementation": "reverse(ts_rank(imb5_score,5))",
      "confidence_level": 0.49
    },
    {
      "idea": "Combine long-term average score with short-term change",
      "description": "add(ts_mean(imb5_score,60), ts_delta(imb5_score,7)) to favor strong long-term plus recent uptick. S1,S4 used. Kept operators ≤7. Confidence: 0.66",
      "implementation": "add(ts_mean(imb5_score,60), ts_delta(imb5_score,7))",
      "confidence_level": 0.66
    },
    {
      "idea": "Score divided by its short-term mean (relative strength)",
      "description": "divide(imb5_score, ts_mean(imb5_score,20)) to capture relative improvement vs recent average. S1,S4 applied. Confidence: 0.61",
      "implementation": "divide(imb5_score, ts_mean(imb5_score,20))",
      "confidence_level": 0.61
    },
    {
      "idea": "Quantile of score momentum adjusted by marketcap volatility",
      "description": "quantile(divide(ts_delta(imb5_score,5), ts_std_dev(imb5_mktcap,60))). S1 used both fields; S4 applied. Kept concise. Confidence: 0.59",
      "implementation": "quantile(divide(ts_delta(imb5_score,5), ts_std_dev(imb5_mktcap,60)))",
      "confidence_level": 0.59
    },
    {
      "idea": "Trade only when score history is sufficiently dense",
      "description": "Use trade_when to only trade if ts_count_nans is small. Applied S1,S4; S3 not needed given coverage. Confidence: 0.55",
      "implementation": "trade_when(imb5_score, less(ts_count_nans(imb5_score,30),5), NaN)",
      "confidence_level": 0.55
    },
    {
      "idea": "Prefer names where score correlation with mktcap is negative",
      "description": "Use ts_corr(imb5_score, imb5_mktcap,60) and reverse to prefer negative correlation. S1 used both fields; S4 applied. Confidence: 0.52",
      "implementation": "reverse(ts_corr(imb5_score, imb5_mktcap,60))",
      "confidence_level": 0.52
    },
    {
      "idea": "Combine normalized score and inverse volatility of score",
      "description": "multiply(normalize(imb5_score), inverse(ts_std_dev(imb5_score,30))). S1,S4 applied. Operators within limits. Confidence: 0.62",
      "implementation": "multiply(normalize(imb5_score), inverse(ts_std_dev(imb5_score,30)))",
      "confidence_level": 0.62
    },
    {
      "idea": "Damped long-term score (long-term mean zscore)",
      "description": "ts_zscore(ts_mean(imb5_score,60),60) to highlight persistent deviations. S1,S4 used. Kept short. Confidence: 0.60",
      "implementation": "ts_zscore(ts_mean(imb5_score,60),60)",
      "confidence_level": 0.6
    },
    {
      "idea": "Score momentum vs its volatility (Sharpe-like)",
      "description": "divide(ts_mean(ts_delta(imb5_score,1),10), ts_std_dev(ts_delta(imb5_score,1),10)). Implemented with available ops; S1,S4 applied. Confidence: 0.58",
      "implementation": "divide(ts_mean(ts_delta(imb5_score,1),10), ts_std_dev(ts_delta(imb5_score,1),10))",
      "confidence_level": 0.58
    },
    {
      "idea": "Isolate persistent high scores (count of days above threshold)",
      "description": "Use ts_count_nans on a boolean to approximate persistence: subtract(ts_count_nans(imb5_score,20),0) then reverse. Kept simple; S1,S4 applied. Confidence: 0.46",
      "implementation": "reverse(subtract(20, ts_count_nans(imb5_score,20)))",
      "confidence_level": 0.46
    },
    {
      "idea": "Score scaled by recent rank range (stability-adjusted)",
      "description": "divide(imb5_score, ts_rank(imb5_score,20)) to adjust by recent rank. S1,S4 applied. Operators minimal. Confidence: 0.52",
      "implementation": "divide(imb5_score, ts_rank(imb5_score,20))",
      "confidence_level": 0.52
    },
    {
      "idea": "Multiply score by a dampening hump to reduce turnover",
      "description": "hump(ts_zscore(imb5_score,10), hump=0.02) to limit large changes. S1,S4 applied. KISS implementation. Confidence: 0.60",
      "implementation": "hump(ts_zscore(imb5_score,10), hump=0.02)",
      "confidence_level": 0.6
    },
    {
      "idea": "Score percent-distance from rolling max (buy near highs)",
      "description": "divide(imb5_score, ts_max_diff(imb5_score,60)) to capture closeness to peak. S1,S4 applied. Confidence: 0.53",
      "implementation": "divide(imb5_score, ts_max_diff(imb5_score,60))",
      "confidence_level": 0.53
    },
    {
      "idea": "Combine long-term rank and short-term zscore",
      "description": "multiply(ts_rank(imb5_score,60), ts_zscore(imb5_score,5)) to favor long-term high rank with short-term momentum. S1,S4 applied. Confidence: 0.62",
      "implementation": "multiply(ts_rank(imb5_score,60), ts_zscore(imb5_score,5))",
      "confidence_level": 0.62
    },
    {
      "idea": "High score but high mktcap penalty (subtract log mktcap)",
      "description": "subtract(imb5_score, log(imb5_mktcap)) to penalize large caps. S1,S4 applied. Kept ops few. Confidence: 0.57",
      "implementation": "subtract(imb5_score, log(imb5_mktcap))",
      "confidence_level": 0.57
    },
    {
      "idea": "Favor rising score that is still below long-term mean (reversion capture)",
      "description": "subtract(ts_mean(imb5_score,60), ts_mean(imb5_score,10)) then multiply by reverse sign to find names improving but below long-term. S1,S4 applied. Confidence: 0.56",
      "implementation": "subtract(ts_mean(imb5_score,10), ts_mean(imb5_score,60))",
      "confidence_level": 0.56
    },
    {
      "idea": "Use ts_arg_max of mktcap to avoid names with recent spikes",
      "description": "reverse(ts_arg_max(imb5_mktcap,30)) to penalize names with recent mktcap spikes. Combine with score via multiply for composite in next step. S1 used both fields; S4 applied. Confidence: 0.48",
      "implementation": "multiply(imb5_score, reverse(ts_arg_max(imb5_mktcap,30)))",
      "confidence_level": 0.48
    },
    {
      "idea": "Score divided by days since last change (prefer recently changing scores)",
      "description": "divide(imb5_score, days_from_last_change(imb5_score)) to emphasize recent updates. S1,S4 applied. Handle divide-by-zero implicitly. Confidence: 0.51",
      "implementation": "divide(imb5_score, days_from_last_change(imb5_score))",
      "confidence_level": 0.51
    },
    {
      "idea": "Inverse marketcap alone as size tilt",
      "description": "Use inverse(imb5_mktcap) to tilt to small caps; combine with imb5_score elsewhere. S1 applied; S2/S3 irrelevant; S4 used. Confidence: 0.44",
      "implementation": "inverse(imb5_mktcap)",
      "confidence_level": 0.44
    },
    {
      "idea": "Combine normalized score and inverse marketcap (equalize groups)",
      "description": "multiply(zscore(imb5_score), inverse(imb5_mktcap)) to favor high-score small caps normalized cross-sectionally. S1,S4 applied. Confidence: 0.66",
      "implementation": "multiply(zscore(imb5_score), inverse(imb5_mktcap))",
      "confidence_level": 0.66
    },
    {
      "idea": "Slow-moving average minus fast-moving average of score (score MACD)",
      "description": "subtract(ts_mean(imb5_score,50), ts_mean(imb5_score,10)) to detect trend direction. S1,S4 applied. Confidence: 0.60",
      "implementation": "subtract(ts_mean(imb5_score,50), ts_mean(imb5_score,10))",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term reversal: negative of 1-day score change",
      "description": "reverse(ts_delta(imb5_score,1)) for intraday/short reversal. S1,S4 applied. Confidence: 0.47",
      "implementation": "reverse(ts_delta(imb5_score,1))",
      "confidence_level": 0.47
    },
    {
      "idea": "Score stability ratio (mean / std)",
      "description": "divide(ts_mean(imb5_score,60), ts_std_dev(imb5_score,60)) as stability indicator. S1,S4 applied. Confidence: 0.55",
      "implementation": "divide(ts_mean(imb5_score,60), ts_std_dev(imb5_score,60))",
      "confidence_level": 0.55
    },
    {
      "idea": "Composite: quantile(score) minus scaled mktcap",
      "description": "subtract(quantile(imb5_score), scale(log(imb5_mktcap))) to combine rank with size penalty. S1,S4 applied. Confidence: 0.61",
      "implementation": "subtract(quantile(imb5_score), scale(log(imb5_mktcap)))",
      "confidence_level": 0.61
    },
    {
      "idea": "High score and low recent mktcap volatility",
      "description": "multiply(quantile(imb5_score), inverse(ts_std_dev(imb5_mktcap,60))) to find stable small-cap high-score names. S1 used both fields; S4 applied. Confidence: 0.58",
      "implementation": "multiply(quantile(imb5_score), inverse(ts_std_dev(imb5_mktcap,60)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Score rank momentum (change in ts_rank)",
      "description": "ts_delta(ts_rank(imb5_score,20),5) to capture rank acceleration. S1,S4 applied. Confidence: 0.59",
      "implementation": "ts_delta(ts_rank(imb5_score,20),5)",
      "confidence_level": 0.59
    },
    {
      "idea": "Score divided by marketcap quartile (implicit bucketing via log)",
      "description": "divide(imb5_score, log(imb5_mktcap)) as alternate sizing. S1,S4 applied; kept operators minimal. Confidence: 0.56",
      "implementation": "divide(imb5_score, log(imb5_mktcap))",
      "confidence_level": 0.56
    },
    {
      "idea": "Temporal smoothing then zscore",
      "description": "ts_zscore(ts_mean(imb5_score,10),10) reduces noise then zscores. S1,S4 applied. Confidence: 0.60",
      "implementation": "ts_zscore(ts_mean(imb5_score,10),10)",
      "confidence_level": 0.6
    },
    {
      "idea": "Prefer names with persistent high score (rolling mean rank)",
      "description": "ts_rank(ts_mean(imb5_score,30),30) to extract persistent rank. S1,S4 applied. Confidence: 0.61",
      "implementation": "ts_rank(ts_mean(imb5_score,30),30)",
      "confidence_level": 0.61
    },
    {
      "idea": "Score scaled by inverse sqrt mktcap (gentle small-cap tilt)",
      "description": "divide(imb5_score, sqrt(imb5_mktcap)) for a softer small-cap bias. S1,S4 applied. Confidence: 0.59",
      "implementation": "divide(imb5_score, sqrt(imb5_mktcap))",
      "confidence_level": 0.59
    },
    {
      "idea": "Combine score zscore and mktcap zscore (subtract)",
      "description": "subtract(zscore(imb5_score), zscore(imb5_mktcap)) to favor high-score, low-mktcap. S1,S4 applied. Confidence: 0.63",
      "implementation": "subtract(zscore(imb5_score), zscore(imb5_mktcap))",
      "confidence_level": 0.63
    },
    {
      "idea": "Time-series correlation of score with its lag (autocorrelation)",
      "description": "ts_corr(imb5_score, ts_delay(imb5_score,1),30) to estimate short autocorrelation. S1,S4 applied. Confidence: 0.54",
      "implementation": "ts_corr(imb5_score, ts_delay(imb5_score,1),30)",
      "confidence_level": 0.54
    },
    {
      "idea": "Prefer names with low mktcap but high stability in score",
      "description": "multiply(inverse(imb5_mktcap), reverse(ts_std_dev(imb5_score,60))) to find stable small names. S1,S4 applied. Confidence: 0.57",
      "implementation": "multiply(inverse(imb5_mktcap), reverse(ts_std_dev(imb5_score,60)))",
      "confidence_level": 0.57
    },
    {
      "idea": "Scale score to cross-sectional percentiles then dampen changes",
      "description": "hump(quantile(imb5_score), hump=0.01) to reduce turnover on percentile signal. S1,S4 applied. Confidence: 0.62",
      "implementation": "hump(quantile(imb5_score), hump=0.01)",
      "confidence_level": 0.62
    },
    {
      "idea": "Short names with sudden mktcap increases (avoid IPO/lighting spikes)",
      "description": "multiply(imb5_score, reverse(ts_arg_max(imb5_mktcap,30))) to penalize recent mktcap spikes. S1 used both fields; S4 applied. Confidence: 0.46",
      "implementation": "multiply(imb5_score, reverse(ts_arg_max(imb5_mktcap,30)))",
      "confidence_level": 0.46
    },
    {
      "idea": "Score divided by the count of recent valid values (penalize sparse histories)",
      "description": "divide(imb5_score, add(ts_count_nans(imb5_score,60),1)) to penalize sparse score history. S1,S4 applied. Confidence: 0.50",
      "implementation": "divide(imb5_score, add(ts_count_nans(imb5_score,60),1))",
      "confidence_level": 0.5
    },
    {
      "idea": "Multiply score with its short-term rank",
      "description": "multiply(imb5_score, ts_rank(imb5_score,5)) to emphasize high score that is also short-term ranked. S1,S4 applied. Confidence: 0.60",
      "implementation": "multiply(imb5_score, ts_rank(imb5_score,5))",
      "confidence_level": 0.6
    },
    {
      "idea": "Score percent distance from recent min (momentum from lows)",
      "description": "divide(subtract(imb5_score, kth_element(imb5_score,20,1)), kth_element(imb5_score,20,1)) approximates rise from recent low. S1,S4 used. Confidence: 0.52",
      "implementation": "divide(subtract(imb5_score, kth_element(imb5_score,20,1)), kth_element(imb5_score,20,1))",
      "confidence_level": 0.52
    },
    {
      "idea": "Normalize score then limit tails (normalize + winsorize)",
      "description": "winsorize(normalize(imb5_score), std=3) for robust cross-sectional signal. S1,S4 applied. Confidence: 0.61",
      "implementation": "winsorize(normalize(imb5_score), std=3)",
      "confidence_level": 0.61
    },
    {
      "idea": "Short-term product of score moves (consensus acceleration)",
      "description": "ts_product(ts_delta(imb5_score,1),5) to detect persistent daily positive changes. S1,S4 applied. Confidence: 0.48",
      "implementation": "ts_product(ts_delta(imb5_score,1),5)",
      "confidence_level": 0.48
    },
    {
      "idea": "Score momentum scaled to mktcap percentile",
      "description": "divide(ts_delta(imb5_score,10), quantile(imb5_mktcap)) to reward momentum in smaller cap percentiles. S1 used both fields; S4 applied. Confidence: 0.55",
      "implementation": "divide(ts_delta(imb5_score,10), quantile(imb5_mktcap))",
      "confidence_level": 0.55
    },
    {
      "idea": "Combine cross-sectional score and its 20-day zscore",
      "description": "add(quantile(imb5_score), ts_zscore(imb5_score,20)) to blend cross-section and time-series extremes. S1,S4 applied. Confidence: 0.64",
      "implementation": "add(quantile(imb5_score), ts_zscore(imb5_score,20))",
      "confidence_level": 0.64
    },
    {
      "idea": "Prefer names with low mktcap and recent positive score zscore",
      "description": "multiply(inverse(imb5_mktcap), ts_zscore(imb5_score,10)) to find emerging small winners. S1,S4 applied. Confidence: 0.65",
      "implementation": "multiply(inverse(imb5_mktcap), ts_zscore(imb5_score,10))",
      "confidence_level": 0.65
    },
    {
      "idea": "Reverse-score momentum when mktcap volatility is high",
      "description": "if_else(greater(ts_std_dev(imb5_mktcap,30), ts_std_dev(imb5_mktcap,60)), reverse(ts_delta(imb5_score,5)), ts_delta(imb5_score,5)). Uses conditional logic to flip during volatility. S1,S4 applied. Confidence: 0.49",
      "implementation": "if_else(greater(ts_std_dev(imb5_mktcap,30), ts_std_dev(imb5_mktcap,60)), reverse(ts_delta(imb5_score,5)), ts_delta(imb5_score,5))",
      "confidence_level": 0.49
    },
    {
      "idea": "Score acceleration normalized by mktcap",
      "description": "divide(ts_delta(ts_delta(imb5_score,3),3), imb5_mktcap) to find accelerating score in small names. S1,S4 applied. Confidence: 0.53",
      "implementation": "divide(ts_delta(ts_delta(imb5_score,3),3), imb5_mktcap)",
      "confidence_level": 0.53
    },
    {
      "idea": "Prefer names where score is high but mktcap has low recent change",
      "description": "multiply(quantile(imb5_score), reverse(ts_std_dev(imb5_mktcap,30))). S1 used both fields; S4 applied. Confidence: 0.56",
      "implementation": "multiply(quantile(imb5_score), reverse(ts_std_dev(imb5_mktcap,30)))",
      "confidence_level": 0.56
    },
    {
      "idea": "Time-smoothed score scaled by inverse log-mktcap",
      "description": "divide(ts_mean(imb5_score,10), log(imb5_mktcap)) to favor smoothed score in smaller names. S1,S4 applied. Confidence: 0.58",
      "implementation": "divide(ts_mean(imb5_score,10), log(imb5_mktcap))",
      "confidence_level": 0.58
    },
    {
      "idea": "Score sign times inverse volatility to get directional stable bets",
      "description": "multiply(sign(imb5_score), inverse(ts_std_dev(imb5_score,30))). S1,S4 applied. Simple and low operator count. Confidence: 0.50",
      "implementation": "multiply(sign(imb5_score), inverse(ts_std_dev(imb5_score,30)))",
      "confidence_level": 0.5
    },
    {
      "idea": "Use ts_max_diff of mktcap to penalize names far above their max",
      "description": "reverse(ts_max_diff(imb5_mktcap,60)) multiplied by imb5_score penalizes names that have moved far from max cap. S1 used both fields; S4 applied. Confidence: 0.45",
      "implementation": "multiply(imb5_score, reverse(ts_max_diff(imb5_mktcap,60)))",
      "confidence_level": 0.45
    },
    {
      "idea": "Score divided by its rolling quantile",
      "description": "divide(imb5_score, ts_quantile(imb5_score,20)) to standardize current vs recent distribution. S1,S4 applied. Confidence: 0.57",
      "implementation": "divide(imb5_score, ts_quantile(imb5_score,20))",
      "confidence_level": 0.57
    },
    {
      "idea": "Short names where score has high recent kurtosis (avoid extreme tails)",
      "description": "reverse(ts_kurtosis(imb5_score,30)) multiplied with inverse mktcap to avoid extremes in small caps. S1,S4 applied. Confidence: 0.44",
      "implementation": "multiply(inverse(imb5_mktcap), reverse(ts_kurtosis(imb5_score,30)))",
      "confidence_level": 0.44
    },
    {
      "idea": "Score momentum normalized by mean absolute deviation (via ts_std_dev)",
      "description": "divide(ts_delta(imb5_score,7), ts_std_dev(imb5_score,20)) for robust momentum. S1,S4 applied. Confidence: 0.59",
      "implementation": "divide(ts_delta(imb5_score,7), ts_std_dev(imb5_score,20))",
      "confidence_level": 0.59
    },
    {
      "idea": "Combine inverse mktcap and normalized recent rank",
      "description": "multiply(inverse(imb5_mktcap), ts_rank(imb5_score,10)) to favor small names with recent rank. S1,S4 applied. Confidence: 0.60",
      "implementation": "multiply(inverse(imb5_mktcap), ts_rank(imb5_score,10))",
      "confidence_level": 0.6
    },
    {
      "idea": "Score minus short-term zscore (contrarian to temporary spikes)",
      "description": "subtract(imb5_score, ts_zscore(imb5_score,5)) to reduce weight on very short spikes. S1,S4 applied. Confidence: 0.53",
      "implementation": "subtract(imb5_score, ts_zscore(imb5_score,5))",
      "confidence_level": 0.53
    },
    {
      "idea": "Use ts_regression slope of score vs time as trend indicator",
      "description": "ts_regression(imb5_score, ts_step(1), 60, lag=0, rettype=0) to extract slope (trend). S1,S4 applied. Kept to allowed ops. Confidence: 0.58",
      "implementation": "ts_regression(imb5_score, ts_step(1),60,0,0)",
      "confidence_level": 0.58
    },
    {
      "idea": "Scale combined score and small-cap tilt to booksize",
      "description": "scale(multiply(quantile(imb5_score), inverse(imb5_mktcap))) to produce tradable weights. S1,S4 applied. Confidence: 0.65",
      "implementation": "scale(multiply(quantile(imb5_score), inverse(imb5_mktcap)))",
      "confidence_level": 0.65
    },
    {
      "idea": "Prefer instruments with decreasing mktcap volatility and rising score",
      "description": "multiply(subtract(ts_mean(imb5_score,10), ts_mean(imb5_score,30)), reverse(ts_std_dev(imb5_mktcap,30))). S1 used both fields; S4 applied. Confidence: 0.54",
      "implementation": "multiply(subtract(ts_mean(imb5_score,10), ts_mean(imb5_score,30)), reverse(ts_std_dev(imb5_mktcap,30)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Trade when score is extreme and mktcap is below median",
      "description": "if_else(greater(ts_zscore(imb5_score,20),1), if_else(less(imb5_mktcap, ts_mean(imb5_mktcap,252)), imb5_score, NaN), NaN). Uses nested if_else to gate trades. S1,S4 applied. Confidence: 0.51",
      "implementation": "if_else(greater(ts_zscore(imb5_score,20),1), if_else(less(imb5_mktcap, ts_mean(imb5_mktcap,252)), imb5_score, NaN), NaN)",
      "confidence_level": 0.51
    },
    {
      "idea": "Multiply score with scaled inverse mktcap (aggressive small-cap tilt)",
      "description": "multiply(imb5_score, scale(inverse(imb5_mktcap))) to amplify small-cap weights after scaling. S1,S4 applied. Confidence: 0.66",
      "implementation": "multiply(imb5_score, scale(inverse(imb5_mktcap)))",
      "confidence_level": 0.66
    },
    {
      "idea": "De-emphasize names with recent large mktcap jumps using ts_arg_max",
      "description": "multiply(imb5_score, reverse(ts_arg_max(imb5_mktcap,90))) to penalize recent max index. S1 used both fields; S4 applied. Confidence: 0.47",
      "implementation": "multiply(imb5_score, reverse(ts_arg_max(imb5_mktcap,90)))",
      "confidence_level": 0.47
    },
    {
      "idea": "Score seasonal pattern detection (lagged rank)",
      "description": "ts_corr(imb5_score, ts_delay(imb5_score,252), 252) to detect yearly autocorrelation. S1,S4 applied. Confidence: 0.50",
      "implementation": "ts_corr(imb5_score, ts_delay(imb5_score,252),252)",
      "confidence_level": 0.5
    },
    {
      "idea": "Composite: normalize score and subtract normalized mktcap",
      "description": "subtract(normalize(imb5_score), normalize(log(imb5_mktcap))) to combine normalized signals. S1,S4 applied. Confidence: 0.63",
      "implementation": "subtract(normalize(imb5_score), normalize(log(imb5_mktcap)))",
      "confidence_level": 0.63
    },
    {
      "idea": "Prefer names with low ts_count_nans in score history and high score",
      "description": "multiply(imb5_score, divide(1, add(ts_count_nans(imb5_score,60),1))) to weight well-observed names. S1,S4 applied. Confidence: 0.49",
      "implementation": "multiply(imb5_score, divide(1, add(ts_count_nans(imb5_score,60),1)))",
      "confidence_level": 0.49
    },
    {
      "idea": "Short-term composite: zscore of score × inverse mktcap",
      "description": "multiply(zscore(imb5_score), inverse(imb5_mktcap)) to favor normalized high-score small caps. S1,S4 applied. Confidence: 0.66",
      "implementation": "multiply(zscore(imb5_score), inverse(imb5_mktcap))",
      "confidence_level": 0.66
    },
    {
      "idea": "Prefer names with rising score but falling market cap (value momentum)",
      "description": "multiply(ts_delta(imb5_score,10), reverse(ts_delta(imb5_mktcap,10))) to find improving score while mktcap contracts. S1 used both fields; S4 applied. Confidence: 0.54",
      "implementation": "multiply(ts_delta(imb5_score,10), reverse(ts_delta(imb5_mktcap,10)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Use ts_av_diff of score normalized cross-sectionally",
      "description": "normalize(ts_av_diff(imb5_score,20)) to get cross-sectional deviations from the local mean. S1,S4 applied. Confidence: 0.58",
      "implementation": "normalize(ts_av_diff(imb5_score,20))",
      "confidence_level": 0.58
    },
    {
      "idea": "Short only names with very high mktcap but low score",
      "description": "if_else(greater(imb5_mktcap, ts_quantile(imb5_mktcap,252)), reverse(imb5_score), NaN) to short large caps with poor score. S1 used both fields; S4 applied. Confidence: 0.46",
      "implementation": "if_else(greater(imb5_mktcap, ts_quantile(imb5_mktcap,252)), reverse(imb5_score), NaN)",
      "confidence_level": 0.46
    },
    {
      "idea": "Score trend strength: slope divided by residual std",
      "description": "divide(ts_regression(imb5_score, ts_step(1),60,0,0), ts_std_dev(imb5_score,60)) to get signal-to-noise of trend. S1,S4 applied. Confidence: 0.57",
      "implementation": "divide(ts_regression(imb5_score, ts_step(1),60,0,0), ts_std_dev(imb5_score,60))",
      "confidence_level": 0.57
    },
    {
      "idea": "Multiply quantile(score) with reverse log mktcap to create size-tilted rank",
      "description": "multiply(quantile(imb5_score), reverse(log(imb5_mktcap))) uses reverse to penalize large log mktcap. S1,S4 applied. Confidence: 0.62",
      "implementation": "multiply(quantile(imb5_score), reverse(log(imb5_mktcap)))",
      "confidence_level": 0.62
    },
    {
      "idea": "Use ts_av_diff of score multiplied by inverse mktcap",
      "description": "multiply(ts_av_diff(imb5_score,20), inverse(imb5_mktcap)) to prefer recent positive deviations in small names. S1,S4 applied. Confidence: 0.60",
      "implementation": "multiply(ts_av_diff(imb5_score,20), inverse(imb5_mktcap))",
      "confidence_level": 0.6
    },
    {
      "idea": "Score volatility breakout: prefer names where score volatility falls then rises",
      "description": "subtract(ts_std_dev(imb5_score,10), ts_std_dev(imb5_score,30)) to detect volatility shift. S1,S4 applied. Confidence: 0.47",
      "implementation": "subtract(ts_std_dev(imb5_score,10), ts_std_dev(imb5_score,30))",
      "confidence_level": 0.47
    },
    {
      "idea": "Normalized score * (1 / mktcap) with winsorization",
      "description": "winsorize(multiply(normalize(imb5_score), inverse(imb5_mktcap)), std=3) to robustly combine signals. S1,S4 applied. Confidence: 0.64",
      "implementation": "winsorize(multiply(normalize(imb5_score), inverse(imb5_mktcap)), std=3)",
      "confidence_level": 0.64
    },
    {
      "idea": "Prefer names with high 10-day mean score but low 60-day mean (recent improvement)",
      "description": "subtract(ts_mean(imb5_score,60), ts_mean(imb5_score,10)) reversed to find recent improvement. S1,S4 applied. Confidence: 0.58",
      "implementation": "reverse(subtract(ts_mean(imb5_score,60), ts_mean(imb5_score,10)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Aggregate: add normalized score and inverse mktcap rank",
      "description": "add(normalize(imb5_score), inverse(imb5_mktcap)) to blend normalized score with size tilt. S1,S4 applied. Confidence: 0.65",
      "implementation": "add(normalize(imb5_score), inverse(imb5_mktcap))",
      "confidence_level": 0.65
    }
  ]
}