{
  "results": [
    {
      "idea": "Short-term momentum (5d) z-scored",
      "description": "Uses rsk62_1_return (high userCount/alphaCount) to capture short-term momentum. Applied SUGGESTION1 by using a return field only (simple, strong signal); SUGGESTION2 not applicable (not a vector); SUGGESTION3 not needed (coverage=1.0); SUGGESTION4 applied (high user/alpha counts). Confidence: 0.80",
      "implementation": "ts_zscore(ts_returns(rsk62_1_return,5),20)",
      "confidence_level": 0.8
    },
    {
      "idea": "Long-term momentum (20d) z-scored",
      "description": "Uses rsk62_5_return to capture longer momentum. SUGGESTION1 used (selecting a different return timescale); SUGGESTION2 not applicable; coverage=1.0 so no ts_backfill. High userCount supports signal. Confidence: 0.78",
      "implementation": "ts_zscore(ts_returns(rsk62_5_return,20),60)",
      "confidence_level": 0.78
    },
    {
      "idea": "Mean-reversion on factor (factor zscore reverse)",
      "description": "Mean-revert factor rsk62_factor_1_100_val42 by reversing its ts_zscore. SUGGESTION1 used single high-quality factor; SUGGESTION2 not used; coverage=1.0 no backfill. Confidence: 0.65",
      "implementation": "reverse(ts_zscore(rsk62_factor_1_100_val42,30))",
      "confidence_level": 0.65
    },
    {
      "idea": "Volatility-adjusted short momentum",
      "description": "Short momentum on rsk62_1_return scaled by inverse volatility (rsk62_risk_volatility). Applied SUGGESTION1 (combine returns + vol), SUGGESTION4 (both fields have high userCount/alphaCount). Coverage high so no backfill. Confidence: 0.77",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_risk_volatility)",
      "confidence_level": 0.77
    },
    {
      "idea": "Industry vs stock relative momentum",
      "description": "Compare short returns of stock vs industry via zscore difference: rsk62_1_return minus industry retseries (rsk62_retseries_industry_1_100_val1). SUGGESTION1 used (two fields), SUGGESTION2 applied for retseries vector via vec_avg; coverage=1.0 so no backfill. Confidence: 0.72",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,5),20), ts_zscore(ts_returns(vec_avg(rsk62_retseries_industry_1_100_val1),5),20))",
      "confidence_level": 0.72
    },
    {
      "idea": "Factor pair spread (zscore spread)",
      "description": "Take zscore spread between two factors to capture relative factor strength (rsk62_factor_1_100_val42 vs rsk62_factor_5_100_val55). SUGGESTION1 used multiple fields; both coverage=1.0. SUGGESTION4 partially applied (moderate userCounts). Confidence: 0.66",
      "implementation": "subtract(ts_zscore(rsk62_factor_1_100_val42,30), ts_zscore(rsk62_factor_5_100_val55,30))",
      "confidence_level": 0.66
    },
    {
      "idea": "Low-volatility premium (inverse vol zscore)",
      "description": "Rank inverse of rsk62_risk_volatility to prefer low-vol stocks. SUGGESTION1 single high-quality risk field used; coverage high so no backfill; SUGGESTION4 applied (high userCount). Confidence: 0.74",
      "implementation": "zscore(inverse(rsk62_risk_volatility))",
      "confidence_level": 0.74
    },
    {
      "idea": "Earnings momentum (EPS change)",
      "description": "Momentum of earnings per share using rsk62_risk_spe via ts_delta then zscore. SUGGESTION1 used SPE; SUGGESTION3 not needed (coverage ~0.9611); SUGGESTION4 applied (good userCount). Confidence: 0.63",
      "implementation": "ts_zscore(ts_delta(rsk62_risk_spe,60),120)",
      "confidence_level": 0.63
    },
    {
      "idea": "Book value (PB) mean reversion",
      "description": "Contrarian on book-value measure rsk62_risk_pb by using reverse(zscore). SUGGESTION1 used one high-coverage accounting field; coverage high; SUGGESTION4 applied (many users). Confidence: 0.68",
      "implementation": "reverse(ts_zscore(rsk62_risk_pb,60))",
      "confidence_level": 0.68
    },
    {
      "idea": "Liquidity-adjusted momentum (adv20)",
      "description": "Short momentum on returns scaled by logADV20 beta proxy (rsk62_beta_5_100_logadv20). SUGGESTION1 used two fields; both have strong user counts so applied SUGGESTION4. Coverage=1.0. Confidence: 0.71",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_beta_5_100_logadv20)",
      "confidence_level": 0.71
    },
    {
      "idea": "Net income per employee trend",
      "description": "Trend in net income per employee rsk62_risk_nipe via ts_delta + zscore. SUGGESTION1 used single risk field; coverage high; SUGGESTION4 high userCount supports signal. Confidence: 0.66",
      "implementation": "ts_zscore(ts_delta(rsk62_risk_nipe,90),180)",
      "confidence_level": 0.66
    },
    {
      "idea": "Dividend trend (dividend momentum)",
      "description": "Momentum of dividend (rsk62_risk_dividend) using ts_returns then ts_zscore. SUGGESTION1 used one fundamental field; coverage high; SUGGESTION4 applied. Confidence: 0.64",
      "implementation": "ts_zscore(ts_returns(rsk62_risk_dividend,20),60)",
      "confidence_level": 0.64
    },
    {
      "idea": "Current ratio improvement signal",
      "description": "Buy improvement in current ratio (rsk62_risk_curratio) via ts_delta then zscore. Coverage high (no backfill). SUGGESTION1/4 applied. Confidence: 0.62",
      "implementation": "ts_zscore(ts_delta(rsk62_risk_curratio,60),120)",
      "confidence_level": 0.62
    },
    {
      "idea": "Growth recovery (eps growth backfilled)",
      "description": "Use rsk62_risk_backfill_growth (coverage ~0.9672) as backfilled eps growth; apply short-term zscore momentum. SUGGESTION1 used backfilled field; SUGGESTION3 acknowledged but coverage>0.6 so ts_backfill not necessary. Confidence: 0.60",
      "implementation": "ts_zscore(ts_returns(rsk62_risk_backfill_growth,20),60)",
      "confidence_level": 0.6
    },
    {
      "idea": "Specific risk dampening (ksrs inverse)",
      "description": "Prefer low specific risk (rsk62_5_100_ksrs) by inverse then zscore. SUGGESTION1 used risk-specific metric; coverage high (0.9877) so no backfill. Confidence: 0.67",
      "implementation": "zscore(inverse(rsk62_5_100_ksrs))",
      "confidence_level": 0.67
    },
    {
      "idea": "Factor momentum using vector averaged factor retseries",
      "description": "Apply vec_avg on retseries factor rsk62_retseries_factor_5_100_val4 then ts_zscore of its ts_returns. SUGGESTION2 applied (vector->vec_avg); SUGGESTION1 used multiple operators; coverage=1.0. Confidence: 0.70",
      "implementation": "ts_zscore(ts_returns(vec_avg(rsk62_retseries_factor_5_100_val4),5),20)",
      "confidence_level": 0.7
    },
    {
      "idea": "Industry momentum via vector averaged industry retseries",
      "description": "Use vec_avg on rsk62_retseries_industry_5_100_val1 then ts_zscore(momentum). SUGGESTION2 applied; coverage=1.0. Confidence: 0.69",
      "implementation": "ts_zscore(ts_returns(vec_avg(rsk62_retseries_industry_5_100_val1),10),40)",
      "confidence_level": 0.69
    },
    {
      "idea": "Cross-sectional zscore of intercept (market residual)",
      "description": "Use rsk62_1_100_intercept to capture idiosyncratic intercept signals with cross-sectional zscore. SUGGESTION1 used high-user intercept; coverage=1.0. Confidence: 0.61",
      "implementation": "zscore(rsk62_1_100_intercept)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum turning point (days since last mtl change)",
      "description": "Use days_from_last_change on rsk62_id_mtl: short days -> recent change is signal. SUGGESTION1 used id field; SUGGESTION2 not applicable; coverage=1.0. Confidence: 0.58",
      "implementation": "reverse(days_from_last_change(rsk62_id_mtl))",
      "confidence_level": 0.58
    },
    {
      "idea": "Beta-adjusted factor zscore (beta * factor)",
      "description": "Multiply industry beta factor rsk62_beta_factor_5_100_logcap with factor rsk62_factor_5_100_val55 to form beta-adjusted factor strength. SUGGESTION1 used 2 fields; both have strong userCounts; coverage=1.0. Confidence: 0.65",
      "implementation": "multiply(rsk62_beta_factor_5_100_logcap, rsk62_factor_5_100_val55)",
      "confidence_level": 0.65
    },
    {
      "idea": "Correlation to industry (low-corr contrarian)",
      "description": "Compute ts_corr between stock returns and industry returns (rsk62_1_return vs rsk62_industry_1_100_val100); low correlation implies stock-specific alpha (reverse). SUGGESTION1 used two fields; coverage high. Confidence: 0.59",
      "implementation": "reverse(ts_corr(rsk62_1_return, rsk62_industry_1_100_val100,20))",
      "confidence_level": 0.59
    },
    {
      "idea": "Short-term reversal via negative recent returns",
      "description": "Reverse short-term returns on rsk62_1_return (mean reversion). SUGGESTION1 simple one-field application; coverage=1.0; SUGGESTION4 used (very high usage). Confidence: 0.70",
      "implementation": "reverse(ts_zscore(ts_returns(rsk62_1_return,3),14))",
      "confidence_level": 0.7
    },
    {
      "idea": "Volume/liquidity shock (logadv20 zscore)",
      "description": "Use rsk62_risk_logadv20 to detect liquidity shocks: zscore of log adv20 changes. SUGGESTION1 used high-userCount liquidity metric; coverage ~0.906 so reliable. Confidence: 0.66",
      "implementation": "ts_zscore(ts_delta(rsk62_risk_logadv20,20),60)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum normalized by intercept",
      "description": "Normalize short momentum by intercept (ts_zscore of returns divided by rsk62_1_100_intercept). SUGGESTION1 used two high-coverage fields; SUGGESTION4 used (intercept very popular). Confidence: 0.68",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_1_100_intercept)",
      "confidence_level": 0.68
    },
    {
      "idea": "Net income per employee cross-sectional zscore",
      "description": "Cross-sectional zscore of rsk62_risk_nipe to capture relative profitability per employee. SUGGESTION1 used high userCount field; coverage ~0.9637. Confidence: 0.64",
      "implementation": "zscore(rsk62_risk_nipe)",
      "confidence_level": 0.64
    },
    {
      "idea": "Price-to-book contrarian",
      "description": "Reverse zscore of rsk62_beta_1_100_pb (book value beta) to express value tilt. SUGGESTION1 used pb beta with high userCount; coverage=1.0. Confidence: 0.67",
      "implementation": "reverse(ts_zscore(rsk62_beta_1_100_pb,60))",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum vs factor (relative)",
      "description": "Difference between stock short returns and factor returns (rsk62_1_return vs rsk62_factor_1_100_val42) via zscore spread. SUGGESTION1 used two fields; coverage=1.0. Confidence: 0.63",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,10),40), ts_zscore(ts_returns(rsk62_factor_1_100_val42,10),40))",
      "confidence_level": 0.63
    },
    {
      "idea": "Growth surprise (backfilled earnings growth)",
      "description": "Use backfilled growth rsk62_risk_backfill_growth (coverage ~0.9672) and take ts_zscore of its change to capture earning surprises. SUGGESTION3 considered but not needed; SUGGESTION4 used. Confidence: 0.61",
      "implementation": "ts_zscore(ts_delta(rsk62_risk_backfill_growth,30),90)",
      "confidence_level": 0.61
    },
    {
      "idea": "Industry beta extreme (industry beta zscore)",
      "description": "High industry beta (rsk62_beta_1_100_mtl) cross-sectional zscore to detect exposure extremes. SUGGESTION1 used beta field; coverage=1.0 and high userCount. Confidence: 0.60",
      "implementation": "zscore(rsk62_beta_1_100_mtl)",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term id momentum (id_mts days since change)",
      "description": "Use days_from_last_change on rsk62_id_mts (short-term momentum index) to capture recency. SUGGESTION1 applied; coverage=1.0. Confidence: 0.57",
      "implementation": "reverse(days_from_last_change(rsk62_id_mts))",
      "confidence_level": 0.57
    },
    {
      "idea": "Mean-reversion on risk-backfilled volatility",
      "description": "Reverse ts_zscore of rsk62_risk_backfill_volatility to favor volatility mean-reversion. SUGGESTION3 noted but coverage ~0.968 so backfill already high quality. Confidence: 0.62",
      "implementation": "reverse(ts_zscore(rsk62_risk_backfill_volatility,30))",
      "confidence_level": 0.62
    },
    {
      "idea": "Cross-sectional zscore of intercept (5_100)",
      "description": "Use rsk62_5_100_intercept cross-sectional zscore to capture intermediate intercept variations. SUGGESTION1 applied (intercept high userCount). Confidence: 0.60",
      "implementation": "zscore(rsk62_5_100_intercept)",
      "confidence_level": 0.6
    },
    {
      "idea": "Factor volatility timing (ts_ir of factor)",
      "description": "Use ts_ir on factor rsk62_factor_1_100_val42 to measure factor information ratio over 60 days. SUGGESTION1 used single factor; coverage=1.0. Confidence: 0.58",
      "implementation": "ts_ir(rsk62_factor_1_100_val42,60)",
      "confidence_level": 0.58
    },
    {
      "idea": "Cash/current ratio cross-sectional",
      "description": "Cross-sectional zscore on rsk62_curratio_di (date index of current ratio) to capture relative liquidity positioning. SUGGESTION1 used date-index field; coverage=1.0. Confidence: 0.55",
      "implementation": "zscore(rsk62_curratio_di)",
      "confidence_level": 0.55
    },
    {
      "idea": "Backfilled PB momentum",
      "description": "Use rsk62_risk_backfill_pb and take ts_zscore of its returns to capture book-value momentum. SUGGESTION3 acknowledged but coverage~0.9672 so stable. Confidence: 0.59",
      "implementation": "ts_zscore(ts_returns(rsk62_risk_backfill_pb,20),60)",
      "confidence_level": 0.59
    },
    {
      "idea": "CAP (logcap) reversal",
      "description": "Reverse ts_zscore on rsk62_risk_logcap to capture small-cap reversal. SUGGESTION1 used logcap; coverage high (~0.9635). Confidence: 0.63",
      "implementation": "reverse(ts_zscore(rsk62_risk_logcap,120))",
      "confidence_level": 0.63
    },
    {
      "idea": "Return momentum scaled by intercept",
      "description": "Scale short returns by rsk62_1_100_intercept to downweight intercept-dominated names. SUGGESTION1 used two fields with high userCount. Confidence: 0.66",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_1_100_intercept)",
      "confidence_level": 0.66
    },
    {
      "idea": "Relative factor rotation (vec_avg retseries factor)",
      "description": "Use vec_avg on rsk62_retseries_factor_1_100_val1 to summarize factor day signal then ts_zscore. SUGGESTION2 applied; coverage=1.0. Confidence: 0.68",
      "implementation": "ts_zscore(vec_avg(rsk62_retseries_factor_1_100_val1),40)",
      "confidence_level": 0.68
    },
    {
      "idea": "Industry mean reversion (industry retseries)",
      "description": "Reverse ts_zscore of vec_avg(rsk62_retseries_industry_5_100_val1) to exploit industry reversals. SUGGESTION2 used vector average; coverage=1.0. Confidence: 0.66",
      "implementation": "reverse(ts_zscore(vec_avg(rsk62_retseries_industry_5_100_val1),40))",
      "confidence_level": 0.66
    },
    {
      "idea": "Trading days since logcap change (id)",
      "description": "Reverse days_from_last_change on rsk62_logcap_di to favor recent cap changes. SUGGESTION1 used date-index; coverage=1.0. Confidence: 0.54",
      "implementation": "reverse(days_from_last_change(rsk62_logcap_di))",
      "confidence_level": 0.54
    },
    {
      "idea": "Momentum vs long-term momentum beta",
      "description": "Difference between short stock returns and long-term momentum beta proxy rsk62_beta_1_100_mtl (zscore spread). SUGGESTION1 used two fields; coverage=1.0. Confidence: 0.60",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,10),40), zscore(rsk62_beta_1_100_mtl))",
      "confidence_level": 0.6
    },
    {
      "idea": "Growth zscore (retseries vector average)",
      "description": "Vec_avg of rsk62_retseries_factor_5_100_val4 then cross-sectional zscore to capture factor-driven growth anomalies. SUGGESTION2 applied. Confidence: 0.62",
      "implementation": "zscore(vec_avg(rsk62_retseries_factor_5_100_val4))",
      "confidence_level": 0.62
    },
    {
      "idea": "Return momentum isolated by ksrs",
      "description": "Downweight momentum by specific risk rsk62_5_100_ksrs via divide of ts_zscore momentum by ksrs. SUGGESTION1 used two fields; ksrs coverage high. Confidence: 0.69",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_5_100_ksrs)",
      "confidence_level": 0.69
    },
    {
      "idea": "Beta to mining industry momentum",
      "description": "Use rsk62_beta_1_100_mining multiplied by factor rsk62_factor_1_100_val42 to express mining-beta driven factor. SUGGESTION1 used 2 fields; mining beta coverage high >0.72. Confidence: 0.58",
      "implementation": "multiply(rsk62_beta_1_100_mining, rsk62_factor_1_100_val42)",
      "confidence_level": 0.58
    },
    {
      "idea": "Short-term factor reversal using retseries",
      "description": "Reverse ts_zscore of vec_avg(rsk62_retseries_factor_1_100_val3) short returns to capture quick mean reversion. SUGGESTION2 applied for vector field. Confidence: 0.61",
      "implementation": "reverse(ts_zscore(ts_returns(vec_avg(rsk62_retseries_factor_1_100_val3),3),14))",
      "confidence_level": 0.61
    },
    {
      "idea": "Industry beta divergence (oil & gas)",
      "description": "Compute ts_zscore of rsk62_beta_industry_constr_1_100_oil_gas to detect industry beta extremes; favor mean reversion. Coverage ~0.6669, >0.6 so ts_backfill not used. Confidence: 0.56",
      "implementation": "reverse(ts_zscore(rsk62_beta_industry_constr_1_100_oil_gas,60))",
      "confidence_level": 0.56
    },
    {
      "idea": "Dividend yield vs dividend beta divergence",
      "description": "Subtract zscore of dividend beta rsk62_beta_5_100_dividend from ts_zscore of rsk62_risk_dividend to find mispricings. SUGGESTION1 used two fields; both coverage high. Confidence: 0.60",
      "implementation": "subtract(ts_zscore(rsk62_risk_dividend,40), zscore(rsk62_beta_5_100_dividend))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum stability (ts_std_dev of returns)",
      "description": "Use ts_std_dev(ts_returns(rsk62_1_return,5),20) low values indicate stable momentum; cross-sectional zscore. SUGGESTION1 used timeseries operators. Confidence: 0.59",
      "implementation": "zscore(ts_std_dev(ts_returns(rsk62_1_return,5),20))",
      "confidence_level": 0.59
    },
    {
      "idea": "Vectorized factor momentum (vec_sum retseries)",
      "description": "Apply vec_sum to rsk62_retseries_factor_5_100_val4 then ts_zscore to capture cumulative factor day signal. SUGGESTION2 applied. Confidence: 0.60",
      "implementation": "ts_zscore(vec_sum(rsk62_retseries_factor_5_100_val4),40)",
      "confidence_level": 0.6
    },
    {
      "idea": "Backfilled industry beta (low coverage fix)",
      "description": "Use rsk62_beta_industry_constr_5_100_reits (coverage ~0.602) â€” coverage slightly >0.6 so no ts_backfill required; take ts_zscore to detect extremes. SUGGESTION3 considered but not applied. Confidence: 0.55",
      "implementation": "ts_zscore(rsk62_beta_industry_constr_5_100_reits,60)",
      "confidence_level": 0.55
    },
    {
      "idea": "Short-term return kurtosis (anomaly detector)",
      "description": "Use ts_kurtosis(ts_returns(rsk62_1_return,5),20) high kurtosis signals extreme move continuation; coverage high. SUGGESTION1 used timeseries operator; SUGGESTION4 used popular return field. Confidence: 0.53",
      "implementation": "ts_kurtosis(ts_returns(rsk62_1_return,5),20)",
      "confidence_level": 0.53
    },
    {
      "idea": "Momentum zscore neutralized by sector intercept",
      "description": "Neutralize short momentum ts_zscore(ts_returns(rsk62_1_return,5),20) by group intercept via group_neutralize using rsk62_1_100_intercept as group proxy (treated as constant). KEEP_IN_MIND: group operator requires group param; here we neutralize vs intercept. SUGGESTION1 used both fields with high userCount. Confidence: 0.62",
      "implementation": "group_neutralize(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_1_100_intercept)",
      "confidence_level": 0.62
    },
    {
      "idea": "Price momentum vs logcap (size tilt)",
      "description": "Subtract zscore(logcap) from short momentum to favor momentum in small caps: ts_zscore(ts_returns(rsk62_1_return,5),20) - zscore(rsk62_risk_logcap). SUGGESTION1/4 applied. Confidence: 0.65",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,5),20), zscore(rsk62_risk_logcap))",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum turnover dampening (hump)",
      "description": "Apply hump to short momentum to reduce turnover: hump(ts_zscore(ts_returns(rsk62_1_return,5),20)). SUGGESTION1 used; hump reduces turnover per KEEP_IN_MIND. Confidence: 0.60",
      "implementation": "hump(ts_zscore(ts_returns(rsk62_1_return,5),20), hump=0.01)",
      "confidence_level": 0.6
    },
    {
      "idea": "Reversal following high information ratio",
      "description": "Reverse ts_ir on rsk62_factor_1_100_val42 (high IR indicates factor stability) to capture mean-reversion in extremes. SUGGESTION1 used factor IR. Confidence: 0.52",
      "implementation": "reverse(ts_ir(rsk62_factor_1_100_val42,60))",
      "confidence_level": 0.52
    },
    {
      "idea": "Return acceleration (delta of returns)",
      "description": "Use ts_delta(ts_returns(rsk62_1_return,5),5) then ts_zscore to capture accelerating returns. SUGGESTION1 used timeseries nesting. Confidence: 0.58",
      "implementation": "ts_zscore(ts_delta(ts_returns(rsk62_1_return,5),5),30)",
      "confidence_level": 0.58
    },
    {
      "idea": "Book-to-price momentum (beta-weighted)",
      "description": "Multiply book-value beta rsk62_beta_1_100_pb with ts_zscore of pb to find beta-weighted PB signal. SUGGESTION1 used 2 fields, both high coverage. Confidence: 0.61",
      "implementation": "multiply(rsk62_beta_1_100_pb, ts_zscore(rsk62_risk_pb,60))",
      "confidence_level": 0.61
    },
    {
      "idea": "Sector expected return divergence",
      "description": "Subtract sector expected industry returns (rsk62_beta_5_100_electric) from industry actual retseries vec_avg to find mispricings. SUGGESTION1 used two fields; beta coverage ~0.6469. Confidence: 0.56",
      "implementation": "subtract(ts_zscore(vec_avg(rsk62_retseries_industry_5_100_val1),20), zscore(rsk62_beta_5_100_electric))",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum scaled by net-income-per-employee growth",
      "description": "Divide short momentum by rsk62_risk_backfill_nipe to favor momentum with improving NIPE. SUGGESTION1 used two fields; backfill coverage ~0.968 so reliable. Confidence: 0.63",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_risk_backfill_nipe)",
      "confidence_level": 0.63
    },
    {
      "idea": "Relative momentum across factor families (pair)",
      "description": "Take difference of ts_zscore of two factor retseries averaged vectors (vec_avg of two different retseries). SUGGESTION2 applied to both retseries vectors; SUGGESTION4 moderate. Confidence: 0.60",
      "implementation": "subtract(ts_zscore(vec_avg(rsk62_retseries_factor_5_100_val4),30), ts_zscore(vec_avg(rsk62_retseries_factor_5_100_val10),30))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum scaled by market-cap intercept",
      "description": "Divide ts_zscore short returns by rsk62_5_100_intercept to adjust for intercept size effects. SUGGESTION1 used two high-usage fields. Confidence: 0.62",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_5_100_intercept)",
      "confidence_level": 0.62
    },
    {
      "idea": "Short-term return quantile signal",
      "description": "Use ts_quantile(ts_returns(rsk62_1_return,5),7) to map short returns into gaussian quantiles. SUGGESTION1 used high-quality return field. Confidence: 0.64",
      "implementation": "ts_quantile(ts_returns(rsk62_1_return,5),7)",
      "confidence_level": 0.64
    },
    {
      "idea": "Factor zscore momentum (long-term)",
      "description": "ts_zscore of rsk62_factor_5_100_val55 over longer lookback to capture persistent factor trends. SUGGESTION1 used factor; coverage=1.0. Confidence: 0.62",
      "implementation": "ts_zscore(ts_returns(rsk62_factor_5_100_val55,20),80)",
      "confidence_level": 0.62
    },
    {
      "idea": "Short-term return rank within time series",
      "description": "Use ts_rank(ts_returns(rsk62_1_return,10),10) to identify relative position in recent history. SUGGESTION1 used return field; operator limited and robust. Confidence: 0.61",
      "implementation": "ts_rank(ts_returns(rsk62_1_return,10),10)",
      "confidence_level": 0.61
    },
    {
      "idea": "Return cross-sectional quantile neutralization",
      "description": "Quantile(ts_returns(rsk62_1_return,5)) to create cross-sectional quantile signal. SUGGESTION1 applied; simple robust transformation. Confidence: 0.63",
      "implementation": "quantile(ts_returns(rsk62_1_return,5))",
      "confidence_level": 0.63
    },
    {
      "idea": "EPS backfill surge detection",
      "description": "Use ts_backfill on rsk62_risk_backfill_spe if necessary (coverage ~0.9652) then ts_delta to detect EPS surges. SUGGESTION3 considered but coverage high so direct ts_delta used. Confidence: 0.58",
      "implementation": "ts_zscore(ts_delta(rsk62_risk_backfill_spe,30),90)",
      "confidence_level": 0.58
    },
    {
      "idea": "Industry momentum divergence (cross series)",
      "description": "Subtract vec_avg of industry retseries and vec_avg of factor retseries to detect industry-factor divergences. SUGGESTION2 used for both vectors. Confidence: 0.57",
      "implementation": "subtract(vec_avg(rsk62_retseries_industry_5_100_val1), vec_avg(rsk62_retseries_factor_5_100_val4))",
      "confidence_level": 0.57
    },
    {
      "idea": "Price reversal after high kurtosis",
      "description": "If ts_kurtosis(ts_returns(rsk62_1_return,10),30) is high, apply reverse momentum via trade_when. SUGGESTION1 used kurtosis metric; implementation keeps logic simple. Confidence: 0.52",
      "implementation": "trade_when(ts_zscore(ts_returns(rsk62_1_return,5),20), greater(ts_kurtosis(ts_returns(rsk62_1_return,10),30),2), reverse(ts_zscore(ts_returns(rsk62_1_return,5),20)))",
      "confidence_level": 0.52
    },
    {
      "idea": "Momentum persistence via ts_arg_max",
      "description": "Use ts_arg_max(ts_returns(rsk62_1_return,10),10) small index (0) implies recent peak -> continuation. SUGGESTION1 applied. Confidence: 0.54",
      "implementation": "reverse(ts_arg_max(ts_returns(rsk62_1_return,10),10))",
      "confidence_level": 0.54
    },
    {
      "idea": "Turnover-targeted smoothing of alpha",
      "description": "Apply ts_target_tvr_hump to short momentum to reach target turnover; simple way to control trading cost. SUGGESTION1 used the momentum input; KEEP_IN_MIND ensures operators small. Confidence: 0.60",
      "implementation": "ts_target_tvr_hump(ts_zscore(ts_returns(rsk62_1_return,5),20), target_tvr=0.1)",
      "confidence_level": 0.6
    },
    {
      "idea": "Return vs factor covariance signal",
      "description": "Use ts_covariance(ts_returns(rsk62_1_return,20), ts_returns(rsk62_factor_1_100_val42,20),20) to detect changing covariance; high covariance with factor -> apply reverse. SUGGESTION1 used two fields. Confidence: 0.50",
      "implementation": "reverse(ts_covariance(ts_returns(rsk62_1_return,20), ts_returns(rsk62_factor_1_100_val42,20),20))",
      "confidence_level": 0.5
    },
    {
      "idea": "Cross-sectional winsorized momentum",
      "description": "Winsorize ts_zscore short returns to cap outliers: winsorize(ts_zscore(ts_returns(rsk62_1_return,5),20), std=3). SUGGESTION1 applied for stability. Confidence: 0.65",
      "implementation": "winsorize(ts_zscore(ts_returns(rsk62_1_return,5),20), std=3)",
      "confidence_level": 0.65
    },
    {
      "idea": "Factor IR momentum (ts_ir on retseries avg)",
      "description": "Compute ts_ir on vec_avg(rsk62_retseries_factor_5_100_val4) to capture factor information ratio and use zscore. SUGGESTION2 applied for vector. Confidence: 0.57",
      "implementation": "ts_ir(vec_avg(rsk62_retseries_factor_5_100_val4),60)",
      "confidence_level": 0.57
    },
    {
      "idea": "Return minus industry expected returns",
      "description": "Subtract industry expected returns beta (rsk62_beta_5_100_banks) from stock short momentum to detect bank-specific alpha. SUGGESTION1 used two fields; beta coverage moderate (~0.5504). SUGGESTION3 not applied. Confidence: 0.55",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,10),40), rsk62_beta_5_100_banks)",
      "confidence_level": 0.55
    },
    {
      "idea": "Short-term momentum magnitude (ts_sum of returns)",
      "description": "Use ts_sum(ts_returns(rsk62_1_return,1),5) as short-run cumulative return then zscore. SUGGESTION1 applied with minimal ops. Confidence: 0.62",
      "implementation": "ts_zscore(ts_sum(ts_returns(rsk62_1_return,1),5),20)",
      "confidence_level": 0.62
    },
    {
      "idea": "Beta-weighted momentum for semiconductors",
      "description": "Multiply semiconductor beta rsk62_beta_1_100_semiconductors with short factor momentum to express sector-specific tilt. SUGGESTION1 used two fields; beta coverage ~0.5731. Confidence: 0.54",
      "implementation": "multiply(rsk62_beta_1_100_semiconductors, ts_zscore(ts_returns(rsk62_factor_1_100_val42,5),20))",
      "confidence_level": 0.54
    },
    {
      "idea": "Return zscore neutralized by industry intercept",
      "description": "Use group_neutralize to remove industry intercept effect: group_neutralize(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_industry_constr_1_100_intercept). SUGGESTION1 used to improve cross-sectional purity. Confidence: 0.63",
      "implementation": "group_neutralize(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_industry_constr_1_100_intercept)",
      "confidence_level": 0.63
    },
    {
      "idea": "Short-term factor spike detector (arg_max)",
      "description": "ts_arg_max on factor retseries vec_avg to find recent maxima and reverse. SUGGESTION2 applied for vector fields. Confidence: 0.56",
      "implementation": "reverse(ts_arg_max(vec_avg(rsk62_retseries_factor_5_100_val4),10))",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum correlation decay (ts_decay_linear)",
      "description": "Apply ts_decay_linear to recent returns to produce decayed momentum: ts_decay_linear(ts_returns(rsk62_1_return,5),10). SUGGESTION1 used to smooth signal. Confidence: 0.59",
      "implementation": "ts_decay_linear(ts_returns(rsk62_1_return,5),10)",
      "confidence_level": 0.59
    },
    {
      "idea": "High NIPE growth rotation",
      "description": "Rank net income per employee growth using rsk62_growth_di and zscore; rotate into high NIPE growth names. SUGGESTION1 used date-index growth field with high userCount. Confidence: 0.58",
      "implementation": "zscore(rsk62_growth_di)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum vs expected industry return (electronics)",
      "description": "Subtract expected electronics industry returns rsk62_beta_5_100_electronics from stock momentum to find idiosyncratic alpha. SUGGESTION1 applied; beta coverage lower (~0.3315) so confidence lower. Confidence: 0.50",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,10),40), rsk62_beta_5_100_electronics)",
      "confidence_level": 0.5
    },
    {
      "idea": "Return stability (ts_ir of returns)",
      "description": "Use ts_ir(ts_returns(rsk62_1_return,10),60) to prefer stocks with stable return/risk profile. SUGGESTION1 used ts_ir on returns. Confidence: 0.61",
      "implementation": "ts_ir(ts_returns(rsk62_1_return,10),60)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum normalized by book (pb)",
      "description": "Divide short momentum by book-related beta rsk62_beta_1_100_pb to emphasize momentum in low pb-beta names. SUGGESTION1 used two fields with high usage. Confidence: 0.64",
      "implementation": "divide(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_beta_1_100_pb)",
      "confidence_level": 0.64
    },
    {
      "idea": "Vectorized industry factor difference",
      "description": "Subtract vec_avg of two industry retseries to capture relative industry rotations. SUGGESTION2 applied; both vectors coverage=1.0. Confidence: 0.58",
      "implementation": "subtract(vec_avg(rsk62_retseries_industry_5_100_val1), vec_avg(rsk62_retseries_industry_5_100_val2))",
      "confidence_level": 0.58
    },
    {
      "idea": "Cross-sectional winsorized PB signal",
      "description": "Winsorize zscore of book value rsk62_risk_pb to reduce outliers before ranking. SUGGESTION1 used risk pb and winsorize for robustness. Confidence: 0.60",
      "implementation": "winsorize(zscore(rsk62_risk_pb), std=4)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum vs long-term factor (mtl)",
      "description": "Subtract long-term momentum beta rsk62_beta_1_100_mtl from short returns to find names with short momentum but low long-term momentum exposure. SUGGESTION1 used two fields; both high coverage. Confidence: 0.62",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_beta_1_100_mtl)",
      "confidence_level": 0.62
    },
    {
      "idea": "Return residuals via pasteurize",
      "description": "Apply pasteurize to ts_zscore(ts_returns(rsk62_1_return,5),20) to remove infinities and out-of-universe values for robustness. SUGGESTION1 used and pasteurize helps outliers per KEEP_IN_MIND. Confidence: 0.63",
      "implementation": "pasteurize(ts_zscore(ts_returns(rsk62_1_return,5),20))",
      "confidence_level": 0.63
    },
    {
      "idea": "Short-term factor momentum with winsorize",
      "description": "Apply winsorize to ts_zscore(ts_returns(rsk62_factor_5_100_val55,5),20) to reduce extreme factor spikes. SUGGESTION1 and winsorize used for robustness. Confidence: 0.59",
      "implementation": "winsorize(ts_zscore(ts_returns(rsk62_factor_5_100_val55,5),20), std=3)",
      "confidence_level": 0.59
    },
    {
      "idea": "Re-rate using group_mean intercept",
      "description": "Replace alpha values with group_mean of ts_zscore returns within group intercept rsk62_industry_constr_1_100_intercept to enforce equal weighting within group. SUGGESTION1 used two fields; group operator used per KEEP_IN_MIND4. Confidence: 0.60",
      "implementation": "group_mean(ts_zscore(ts_returns(rsk62_1_return,5),20), weight=1, group=rsk62_industry_constr_1_100_intercept)",
      "confidence_level": 0.6
    },
    {
      "idea": "Factor cross-variance signal",
      "description": "ts_std_dev of factor returns rsk62_factor_1_100_val42 over 60 days to capture factor turbulence (zscore). SUGGESTION1 used factor field with coverage=1.0. Confidence: 0.54",
      "implementation": "zscore(ts_std_dev(rsk62_factor_1_100_val42,60))",
      "confidence_level": 0.54
    },
    {
      "idea": "Momentum signal with tail trimming",
      "description": "Apply tail to ts_zscore short returns to cap values between lower/upper thresholds, limiting extreme bets. SUGGESTION1 used trimming for robustness. Confidence: 0.61",
      "implementation": "tail(ts_zscore(ts_returns(rsk62_1_return,5),20), lower=-3, upper=3, newval=0)",
      "confidence_level": 0.61
    },
    {
      "idea": "Long-short factor rotation (two factors)",
      "description": "Long factor rsk62_factor_5_100_val55 while short rsk62_factor_1_100_val42 via zscore spread to capture rotation. SUGGESTION1 used two factors with coverage=1.0. Confidence: 0.60",
      "implementation": "subtract(ts_zscore(rsk62_factor_5_100_val55,60), ts_zscore(rsk62_factor_1_100_val42,60))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum filtered by turnover target (ts_target_tvr_decay)",
      "description": "Use ts_target_tvr_decay on short momentum to enforce a turnover target and smooth decay. SUGGESTION1 applied to improve tradeability. Confidence: 0.59",
      "implementation": "ts_target_tvr_decay(ts_zscore(ts_returns(rsk62_1_return,5),20), target_tvr=0.1)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum vs liquidity beta spread",
      "description": "Subtract liquidity beta rsk62_beta_5_100_logadv20 from short momentum to prioritize liquid momentum. SUGGESTION1 used both fields with high userCount. Confidence: 0.66",
      "implementation": "subtract(ts_zscore(ts_returns(rsk62_1_return,5),20), rsk62_beta_5_100_logadv20)",
      "confidence_level": 0.66
    },
    {
      "idea": "Short-term reversal on factor retseries avg",
      "description": "Reverse ts_zscore of vec_avg(rsk62_retseries_factor_5_100_val4) short returns to exploit quick reversals. SUGGESTION2 applied. Confidence: 0.60",
      "implementation": "reverse(ts_zscore(ts_returns(vec_avg(rsk62_retseries_factor_5_100_val4),3),14))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum correlation to factor (ts_corr)",
      "description": "ts_corr between short stock returns and factor returns rsk62_factor_1_100_val42 over 20 days; favor low/high correlation depending on strategy via reverse. SUGGESTION1 used two fields; coverage high. Confidence: 0.56",
      "implementation": "reverse(ts_corr(ts_returns(rsk62_1_return,5), ts_returns(rsk62_factor_1_100_val42,5),20))",
      "confidence_level": 0.56
    },
    {
      "idea": "Return trend zscore (ts_av_diff)",
      "description": "Use ts_av_diff(ts_returns(rsk62_1_return,5),20) to measure deviation from recent mean then zscore. SUGGESTION1 applied for trend detection. Confidence: 0.60",
      "implementation": "ts_zscore(ts_av_diff(ts_returns(rsk62_1_return,5),20),40)",
      "confidence_level": 0.6
    },
    {
      "idea": "Backfill low-coverage beta (food) with ts_backfill",
      "description": "rsk62_beta_5_100_food coverage ~0.5646 (<0.6) so apply ts_backfill(rsk62_beta_5_100_food,30) then ts_zscore to recover signal. SUGGESTION3 explicitly applied. Confidence: 0.52",
      "implementation": "ts_zscore(ts_backfill(rsk62_beta_5_100_food,30),60)",
      "confidence_level": 0.52
    }
  ]
}