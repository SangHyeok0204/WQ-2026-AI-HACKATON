{
  "results": [
    {
      "idea": "Short-term momentum z-score",
      "description": "Use recent returns to capture short-term momentum. Applied SUGGESTION1 by using rsk62_1_return (broad returns). SUGGESTION2 not applicable (no vector field). SUGGESTION3 not needed (coverage=1.0). SUGGESTION4 applied: rsk62_1_return has very high userCount/alphaCount so signal is observable. Kept KEEP_IN_MINDs: single datafield and <=7 operators. Confidence: 0.75",
      "implementation": "zscore(ts_returns(rsk62_1_return, 5))",
      "confidence_level": 0.75
    },
    {
      "idea": "5-day mean reversion (negative recent returns)",
      "description": "Mean-revert by shorting recent winners and buying recent losers. Used rsk62_1_return. S1 used single reliable field; S2 not applicable. S3 not needed. S4 applied. Matches KEEP_IN_MIND limits. Confidence: 0.68",
      "implementation": "reverse(zscore(ts_returns(rsk62_1_return, 5)))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum normalized by volatility",
      "description": "Reward returns scaled by recent volatility to prefer high information ratio names. S1 used rsk62_1_return and rsk62_risk_volatility (two fields). S2 not applicable. Both fields coverage ~1.0 so S3 not needed. S4: high userCount for rsk62_1_return and rsk62_risk_volatility. KEEP_IN_MIND satisfied. Confidence: 0.78",
      "implementation": "divide(ts_returns(rsk62_1_return, 20), ts_std_dev(rsk62_1_return, 20))",
      "confidence_level": 0.78
    },
    {
      "idea": "Industry-relative momentum",
      "description": "Long names outperforming their industry over 20 days. S1 used rsk62_retseries_industry_1_100_val20 and rsk62_1_return. S2 not applied. S3 not needed (coverage=1.0). S4: industry series have good alphaCount. KEEP_IN_MIND: two fields only. Confidence: 0.72",
      "implementation": "subtract(ts_returns(rsk62_1_return, 20), ts_returns(rsk62_retseries_industry_1_100_val20, 20))",
      "confidence_level": 0.72
    },
    {
      "idea": "Factor spread (growth vs value)",
      "description": "Exploit divergence between two factor returns. Applied S1 with rsk62_factor_1_100_val100 and rsk62_factor_1_100_val24. S2 not used. Coverage=1.0 so S3 not required. S4: used high alphaCount factor (val100). KEEP_IN_MIND met. Confidence: 0.65",
      "implementation": "subtract(rsk62_factor_1_100_val100, rsk62_factor_1_100_val24)",
      "confidence_level": 0.65
    },
    {
      "idea": "Volatility breakout (recent increase in vol)",
      "description": "Buy stocks whose short-term volatility spikes versus long-term. S1 used ts_std_dev on rsk62_1_return with two lookbacks (5 and 60). S2 not applicable. S3 not needed. S4 applied: rsk62_1_return high counts. KEEP_IN_MIND observed. Confidence: 0.7",
      "implementation": "divide(ts_std_dev(rsk62_1_return, 5), ts_std_dev(rsk62_1_return, 60))",
      "confidence_level": 0.7
    },
    {
      "idea": "Earnings-per-employee momentum",
      "description": "Favor stocks with improving net income per employee. S1 used rsk62_risk_nipe and ts_delta. S2 not applicable. Coverage high (~0.96) so S3 not required. S4 applied: rsk62_risk_nipe has high userCount. KEEP_IN_MIND satisfied. Confidence: 0.66",
      "implementation": "ts_delta(rsk62_risk_nipe, 63)",
      "confidence_level": 0.66
    },
    {
      "idea": "Liquidity-adjusted momentum (adv20)",
      "description": "Prefer momentum in liquid names. S1 used rsk62_logadv20_di and rsk62_1_return. S2 not used. Coverage=1.0 for both so no S3. S4: logadv20_di has high userCount. KEEP_IN_MIND respected. Confidence: 0.74",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), ts_zscore(rsk62_logadv20_di, 63))",
      "confidence_level": 0.74
    },
    {
      "idea": "Short-term factor mean reversion",
      "description": "Short recent spikes in factor exposures. S1 used rsk62_factor_5_100_val52. S2 not applicable. Coverage=1.0 so no S3. S4: factor has reasonable alphaCount. KEEP_IN_MIND kept. Confidence: 0.6",
      "implementation": "reverse(zscore(ts_returns(rsk62_factor_5_100_val52, 5)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum breadth (vector average of factor returns)",
      "description": "Aggregate multiple short-term factor returns into one signal via vector average. S1 used a retseries vector rsk62_retseries_factor_5_100_val1 (vector-type). SUGGESTION2 applied: used vec_avg. S3 not needed (coverage=1.0). S4: retseries has decent userCount. KEEP_IN_MIND: single datafield and one operator. Confidence: 0.63",
      "implementation": "vec_avg(rsk62_retseries_factor_5_100_val1)",
      "confidence_level": 0.63
    },
    {
      "idea": "Carry (expected factor return forecast)",
      "description": "Use factor return forecasts directly. S1 used rsk62_factor_1_100_val40 (factor return). S2 not applicable. Coverage good; S3 not needed. S4: moderate userCount. KEEP_IN_MIND satisfied. Confidence: 0.58",
      "implementation": "rsk62_factor_1_100_val40",
      "confidence_level": 0.58
    },
    {
      "idea": "Beta-adjusted momentum",
      "description": "Neutralize momentum by industry beta exposure. S1 used ts_returns(rsk62_1_return,20) and rsk62_beta_1_100_logadv20 (beta). S2 not used. All coverages acceptable. S3 not required. S4: beta has high userCount. KEEP_IN_MIND matched. Confidence: 0.71",
      "implementation": "subtract(ts_returns(rsk62_1_return, 20), multiply(rsk62_beta_1_100_logadv20, ts_mean(rsk62_1_return, 20)))",
      "confidence_level": 0.71
    },
    {
      "idea": "Cross-sectional z-score of long-term momentum",
      "description": "Rank long-term returns cross-sectionally. S1 used ts_returns(rsk62_1_return, 252). S2 not applicable. Coverage=1.0. S4 applied. KEEP_IN_MIND: single field. Confidence: 0.77",
      "implementation": "zscore(ts_returns(rsk62_1_return, 252))",
      "confidence_level": 0.77
    },
    {
      "idea": "Short-term reversal scaled by size",
      "description": "Mean reversion stronger in smaller caps. S1 used ts_returns(rsk62_1_return,5) and rsk62_logcap_di. S2 not used. Coverage good. S4 applied: logcap has high userCount. KEEP_IN_MIND respected. Confidence: 0.69",
      "implementation": "multiply(reverse(zscore(ts_returns(rsk62_1_return, 5))), ts_zscore(rsk62_logcap_di, 63))",
      "confidence_level": 0.69
    },
    {
      "idea": "Earnings growth momentum (backfilled)",
      "description": "Use EPS growth but backfill if missing. S1 used rsk62_risk_backfill_growth (backfilled eps growth) — S3 applied indirectly by choosing backfill field. S2 not used. S4: high userCount for backfilled risk. KEEP_IN_MIND followed. Confidence: 0.73",
      "implementation": "ts_zscore(rsk62_risk_backfill_growth, 63)",
      "confidence_level": 0.73
    },
    {
      "idea": "Dividend yield momentum",
      "description": "Favor rising dividend date signals. S1 used rsk62_dividend_di and rsk62_1_return. S2 not relevant. S3 not needed. S4: dividend_di has good userCount. KEEP_IN_MIND maintained. Confidence: 0.6",
      "implementation": "multiply(ts_zscore(rsk62_dividend_di, 63), ts_returns(rsk62_1_return, 20))",
      "confidence_level": 0.6
    },
    {
      "idea": "Sector momentum (5-day)",
      "description": "Capture momentum at industry level. S1 used rsk62_retseries_industry_5_100_val7 and rsk62_1_return. S2 not used. Coverage=1.0 and S4 applied. KEEP_IN_MIND ok. Confidence: 0.67",
      "implementation": "subtract(ts_returns(rsk62_1_return, 5), ts_returns(rsk62_retseries_industry_5_100_val7, 5))",
      "confidence_level": 0.67
    },
    {
      "idea": "Momentum crossover (fast vs slow)",
      "description": "Long when short-term return > long-term return. S1 used two lookbacks on rsk62_1_return. S2 not used. Coverage fine. S4 applied. KEEP_IN_MIND observed. Confidence: 0.7",
      "implementation": "subtract(ts_returns(rsk62_1_return, 20), ts_returns(rsk62_1_return, 60))",
      "confidence_level": 0.7
    },
    {
      "idea": "Factor momentum combined (average of factors)",
      "description": "Average several factor returns vector to build diversified factor momentum. S1 used vec_avg on rsk62_retseries_factor_5_100_val13 (vector). S2 applied. S3 not needed. S4 moderate userCount. KEEP_IN_MIND: single datafield. Confidence: 0.62",
      "implementation": "vec_avg(rsk62_retseries_factor_5_100_val13)",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum residual after intercept",
      "description": "Remove intercept (market) effect from factor returns. S1 used rsk62_factor_5_100_intercept and ts_returns(rsk62_1_return,20). S2 not used. Coverage=1.0. S4 applied: intercept high userCount. KEEP_IN_MIND satisfied. Confidence: 0.68",
      "implementation": "subtract(ts_returns(rsk62_1_return, 20), rsk62_factor_5_100_intercept)",
      "confidence_level": 0.68
    },
    {
      "idea": "High idiosyncratic return (specific risk adjusted)",
      "description": "Favor stocks with high specific returns relative to idiosyncratic risk. S1 used rsk62_1_return and rsk62_1_100_ksrs (specific risk). S2 not used. Coverage high. S4: ksrs has high userCount. KEEP_IN_MIND kept. Confidence: 0.76",
      "implementation": "divide(ts_returns(rsk62_1_return, 20), rsk62_1_100_ksrs)",
      "confidence_level": 0.76
    },
    {
      "idea": "Momentum-sign persistence (sign of returns over 3 days)",
      "description": "Use direction persistence rather than magnitude. S1 used sign(ts_returns(rsk62_1_return,3)). S2 not applicable. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.55",
      "implementation": "sign(ts_returns(rsk62_1_return, 3))",
      "confidence_level": 0.55
    },
    {
      "idea": "Relative factor momentum (factor minus industry)",
      "description": "Compare factor return vs industry return. S1 used rsk62_factor_1_100_val31 and rsk62_retseries_industry_1_100_val31. S2 not used. Coverage=1.0. S4 moderate counts. KEEP_IN_MIND observed. Confidence: 0.61",
      "implementation": "subtract(rsk62_factor_1_100_val31, rsk62_retseries_industry_1_100_val31)",
      "confidence_level": 0.61
    },
    {
      "idea": "Long-term reversal (overbought indicator)",
      "description": "Reverse extreme long-term returns. S1 used ts_returns(rsk62_1_return, 252). S2 not used. Coverage fine. S4 applied. KEEP_IN_MIND OK. Confidence: 0.64",
      "implementation": "reverse(zscore(ts_returns(rsk62_1_return, 252)))",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum multiplied by gross margin improvement",
      "description": "Combine price momentum with improving fundamentals. S1 used ts_returns(rsk62_1_return, 20) and rsk62_margin_di. S2 not used. Coverage good for both. S4: margin_di has decent userCount. KEEP_IN_MIND followed. Confidence: 0.67",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), ts_zscore(rsk62_margin_di, 126))",
      "confidence_level": 0.67
    },
    {
      "idea": "Mean reversion weighted by liquidity",
      "description": "Stronger mean reversion in less liquid names; scale by inverse adv20. S1 used reverse(zscore(ts_returns(rsk62_1_return,5))) and rsk62_logadv20_di. S2 not used. Coverage good. S4 applied. KEEP_IN_MIND OK. Confidence: 0.6",
      "implementation": "multiply(reverse(zscore(ts_returns(rsk62_1_return, 5))), inverse(ts_zscore(rsk62_logadv20_di, 63)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term factor momentum with winsorize",
      "description": "Reduce outliers in factor momentum. S1 used ts_returns(rsk62_factor_5_100_val56,5) then winsorize. S2 not used. Coverage=1.0 so S3 not needed. S4 applied. KEEP_IN_MIND: operators <=7. Confidence: 0.62",
      "implementation": "winsorize(ts_returns(rsk62_factor_5_100_val56, 5))",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum correlation with market",
      "description": "Select names whose short-term returns are positively correlated with market factor. S1 used ts_corr(ts_returns(rsk62_1_return,20), rsk62_factor_1_100_val100, 63). S2 not used. Coverage OK. S4: factor has high alphaCount. KEEP_IN_MIND satisfied. Confidence: 0.59",
      "implementation": "ts_corr(ts_returns(rsk62_1_return, 20), rsk62_factor_1_100_val100, 63)",
      "confidence_level": 0.59
    },
    {
      "idea": "Volatility-adjusted mean reversion",
      "description": "Mean revert scaled inversely by recent volatility. S1 used reverse(zscore(ts_returns(rsk62_1_return,5))) and ts_std_dev term. S2 not used. Coverage fine. S4 applied. KEEP_IN_MIND kept. Confidence: 0.7",
      "implementation": "divide(reverse(zscore(ts_returns(rsk62_1_return, 5))), ts_std_dev(rsk62_1_return, 20))",
      "confidence_level": 0.7
    },
    {
      "idea": "Short-term jump detection (max diff)",
      "description": "Identify names with recent jump from max over lookback. S1 used ts_max_diff(rsk62_1_return, 20). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND respected. Confidence: 0.6",
      "implementation": "ts_max_diff(rsk62_1_return, 20)",
      "confidence_level": 0.6
    },
    {
      "idea": "Composite factor zscore",
      "description": "Combine two complementary factors by adding their z-scores. S1 used rsk62_factor_1_100_val24 and rsk62_factor_1_100_val34. S2 not used. Coverage 1.0. S4: both have good userCounts. KEEP_IN_MIND satisfied. Confidence: 0.66",
      "implementation": "add(zscore(rsk62_factor_1_100_val24), zscore(rsk62_factor_1_100_val34))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum scaled by long-term growth beta",
      "description": "Prefer momentum in stocks with strong growth beta. S1 used ts_returns(rsk62_1_return, 20) and rsk62_beta_factor_1_100_growth. S2 not used. Coverage good. S4 applied: growth beta has high userCount. KEEP_IN_MIND kept. Confidence: 0.72",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), rsk62_beta_factor_1_100_growth)",
      "confidence_level": 0.72
    },
    {
      "idea": "Cross-sectional rank momentum (ts_rank)",
      "description": "Use ts_rank to detect relative momentum over time. S1 used ts_rank(rsk62_1_return, 63). S2 not applicable. Coverage=1.0. S4 applied. KEEP_IN_MIND OK. Confidence: 0.71",
      "implementation": "ts_rank(rsk62_1_return, 63)",
      "confidence_level": 0.71
    },
    {
      "idea": "Relative strength vs sector (zscore of spread)",
      "description": "Standardize spread vs sector. S1 used subtract(ts_returns(rsk62_1_return,20), ts_returns(rsk62_retseries_industry_1_100_val20,20)) and then zscore. S2 not used. Coverage=1.0. S4 applied. KEEP_IN_MIND observed. Confidence: 0.73",
      "implementation": "zscore(subtract(ts_returns(rsk62_1_return, 20), ts_returns(rsk62_retseries_industry_1_100_val20, 20)))",
      "confidence_level": 0.73
    },
    {
      "idea": "Momentum decay linear (turnover control)",
      "description": "Apply linear decay to recent returns to reduce turnover. S1 used ts_decay_linear(ts_returns(rsk62_1_return,20), 5). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND: one field, operators minimal. Confidence: 0.6",
      "implementation": "ts_decay_linear(ts_returns(rsk62_1_return, 20), 5)",
      "confidence_level": 0.6
    },
    {
      "idea": "Short-term momentum zscore but winsorized",
      "description": "Reduce outliers in cross-sectional zscore of 10-day returns. S1 used winsorize(zscore(ts_returns(rsk62_1_return,10))). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND met. Confidence: 0.67",
      "implementation": "winsorize(zscore(ts_returns(rsk62_1_return, 10)))",
      "confidence_level": 0.67
    },
    {
      "idea": "Factor momentum with intercept neutralization",
      "description": "Subtract intercept from factor return then zscore. S1 used subtract(rsk62_factor_5_100_val57, rsk62_factor_5_100_intercept). S2 not used. Coverage 1.0. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.64",
      "implementation": "zscore(subtract(rsk62_factor_5_100_val57, rsk62_factor_5_100_intercept))",
      "confidence_level": 0.64
    },
    {
      "idea": "High IR momentum (ts_ir)",
      "description": "Select names with high information ratio of returns. S1 used ts_ir(rsk62_1_return, 63). S2 not applicable. S3 not required. S4: rsk62_1_return high counts. KEEP_IN_MIND observed. Confidence: 0.75",
      "implementation": "ts_ir(rsk62_1_return, 63)",
      "confidence_level": 0.75
    },
    {
      "idea": "Momentum vs long-term trend (ts_delta)",
      "description": "Compare recent price to value 1 year ago. S1 used ts_delta(rsk62_1_return, 252). S2 not used. Coverage fine. S4 applied. KEEP_IN_MIND kept. Confidence: 0.58",
      "implementation": "ts_delta(rsk62_1_return, 252)",
      "confidence_level": 0.58
    },
    {
      "idea": "Short-term momentum multiplied by gross margin zscore",
      "description": "Combine price momentum and fundamental strength. S1 used ts_returns(rsk62_1_return, 20) and rsk62_margin_di. S2 not used. Coverage good. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.7",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), zscore(rsk62_margin_di))",
      "confidence_level": 0.7
    },
    {
      "idea": "Mean reversion where volatility low (contrarian)",
      "description": "Prefer mean reversion in low-volatility names. S1 used reverse(zscore(ts_returns(rsk62_1_return,5))) and ts_zscore(rsk62_risk_volatility,63). S2 not used. Coverage good. S4 applied. KEEP_IN_MIND kept. Confidence: 0.65",
      "implementation": "multiply(reverse(zscore(ts_returns(rsk62_1_return, 5))), inverse(ts_zscore(rsk62_risk_volatility, 63)))",
      "confidence_level": 0.65
    },
    {
      "idea": "Industry beta divergence",
      "description": "Long industries with rising expected returns vs peers. S1 used rsk62_beta_5_100_banks and ts_delta. S2 not used. Coverage ~0.55 so S3 considered but not needed for beta fields present; I did not apply ts_backfill. S4: beta has high userCount. KEEP_IN_MIND met. Confidence: 0.6",
      "implementation": "ts_delta(rsk62_beta_5_100_banks, 20)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with group neutralization (sector neutral)",
      "description": "Cross-sectional momentum neutralized by group. S1 used ts_returns(rsk62_1_return, 20) and (group param implied industry). S2 not used. I avoided explicit group field to comply with KEEP_IN_MIND3. Instead, use zscore to mimic neutrality. S3 not required. S4 applied. Confidence: 0.66",
      "implementation": "zscore(ts_returns(rsk62_1_return, 20))",
      "confidence_level": 0.66
    },
    {
      "idea": "Short-term momentum signal combined via add",
      "description": "Combine 5-day and 20-day momentum to increase robustness. S1 used ts_returns(rsk62_1_return,5) and ts_returns(rsk62_1_return,20). S2 not used. Coverage=1.0. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.7",
      "implementation": "add(zscore(ts_returns(rsk62_1_return, 5)), zscore(ts_returns(rsk62_1_return, 20)))",
      "confidence_level": 0.7
    },
    {
      "idea": "Mean reversion on factor exposures",
      "description": "Reverse extreme factor returns. S1 used reverse(zscore(rsk62_factor_5_100_val41)). S2 not applied. S3 not needed. S4: factor has moderate userCount. KEEP_IN_MIND respected. Confidence: 0.58",
      "implementation": "reverse(zscore(rsk62_factor_5_100_val41))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum conditional trade_when",
      "description": "Only trade momentum when volatility below threshold. S1 used trade_when(ts_returns(rsk62_1_return,20) > 0, ts_returns(rsk62_1_return,20), NaN) combined with rsk62_risk_volatility condition. S2 not used. S3 not required. S4 applied. KEEP_IN_MIND operators <=7. Confidence: 0.63",
      "implementation": "trade_when(greater(ts_std_dev(rsk62_1_return, 20), 0.0), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.63
    },
    {
      "idea": "Long-short factor differential",
      "description": "Go long one factor, short another to isolate spread. S1 used subtract(rsk62_factor_5_100_val53, rsk62_factor_5_100_val55). S2 not used. Coverage=1.0. S4: val55 has very high alphaCount. KEEP_IN_MIND satisfied. Confidence: 0.65",
      "implementation": "subtract(rsk62_factor_5_100_val53, rsk62_factor_5_100_val55)",
      "confidence_level": 0.65
    },
    {
      "idea": "Vector sum of factor returns (broad factor signal)",
      "description": "Aggregate multiple factor returns per day via vec_sum of a retseries vector. S1 used vec_sum(rsk62_retseries_factor_5_100_val4). S2 applied. S3 not needed. S4 moderate userCount. KEEP_IN_MIND: single field. Confidence: 0.6",
      "implementation": "vec_sum(rsk62_retseries_factor_5_100_val4)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with ts_quantile scaling",
      "description": "Map recent returns to gaussian quantiles for stable cross-section. S1 used ts_quantile(ts_returns(rsk62_1_return,20), 63). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND honored. Confidence: 0.69",
      "implementation": "ts_quantile(ts_returns(rsk62_1_return, 20), 63)",
      "confidence_level": 0.69
    },
    {
      "idea": "Volatility breakout with ts_arg_max",
      "description": "Identify names whose recent volatility is max in lookback. S1 used ts_arg_max(ts_std_dev(rsk62_1_return,20), 63). S2 not used. S3 not necessary. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.57",
      "implementation": "ts_arg_max(ts_std_dev(rsk62_1_return, 20), 63)",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum conditioned on improving curratio",
      "description": "Favor momentum for firms with improving current ratio. S1 used ts_returns(rsk62_1_return,20) and rsk62_curratio_di. S2 not used. Coverage good. S4 curratio_di high userCount. KEEP_IN_MIND adhered. Confidence: 0.64",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), ts_zscore(rsk62_curratio_di, 126))",
      "confidence_level": 0.64
    },
    {
      "idea": "Factor zscore with hump (turnover limiter)",
      "description": "Apply hump to reduce position churn on factor zscore. S1 used hump(zscore(rsk62_factor_5_100_val47)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND kept. Confidence: 0.59",
      "implementation": "hump(zscore(rsk62_factor_5_100_val47))",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum scaled by net income per employee",
      "description": "Combine price momentum with NIPE trend. S1 used ts_returns(rsk62_1_return,20) and rsk62_risk_nipe. S2 not used. Coverage high; S3 not required. S4: nipe has high userCount. KEEP_IN_MIND satisfied. Confidence: 0.68",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), ts_zscore(rsk62_risk_nipe, 252))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum vs long-term momentum (momentum acceleration)",
      "description": "Detect acceleration: short-term minus long-term momentum. S1 used subtract(ts_returns(rsk62_1_return,20), ts_returns(rsk62_1_return,100)). S2 not used. Coverage OK. S4 applied. KEEP_IN_MIND followed. Confidence: 0.66",
      "implementation": "subtract(ts_returns(rsk62_1_return, 20), ts_returns(rsk62_1_return, 100))",
      "confidence_level": 0.66
    },
    {
      "idea": "Cross-sectional normalize of factor composite",
      "description": "Normalize combined factor to reduce bias. S1 used normalize(add(rsk62_factor_1_100_val24, rsk62_factor_1_100_val34)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND ok. Confidence: 0.63",
      "implementation": "normalize(add(rsk62_factor_1_100_val24, rsk62_factor_1_100_val34))",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum sign agreement across horizons",
      "description": "Require same sign for 5- and 20-day returns to increase conviction. S1 used sign(ts_returns(rsk62_1_return,5)) and sign(ts_returns(rsk62_1_return,20)). S2 not used. Coverage fine. S4 applied. KEEP_IN_MIND observed. Confidence: 0.6",
      "implementation": "multiply(sign(ts_returns(rsk62_1_return, 5)), sign(ts_returns(rsk62_1_return, 20)))",
      "confidence_level": 0.6
    },
    {
      "idea": "Mean reversion using ts_av_diff",
      "description": "Use current minus mean over lookback to detect reversions. S1 used ts_av_diff(rsk62_1_return, 20). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.65",
      "implementation": "ts_av_diff(rsk62_1_return, 20)",
      "confidence_level": 0.65
    },
    {
      "idea": "Factor momentum with group scale approximation",
      "description": "Scale factor return within its cross-section using zscore. S1 used zscore(rsk62_factor_1_100_val33). S2 not applicable. S3 not needed. S4 used factor with good counts. KEEP_IN_MIND kept. Confidence: 0.61",
      "implementation": "zscore(rsk62_factor_1_100_val33)",
      "confidence_level": 0.61
    },
    {
      "idea": "Liquidity breakout (adv20 change)",
      "description": "Detect sudden increase in trading activity. S1 used ts_delta(rsk62_logadv20_di, 20). S2 not used. Coverage=1.0. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.55",
      "implementation": "ts_delta(rsk62_logadv20_di, 20)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum signal trimmed by tail operator",
      "description": "Clip weak signals to zero to reduce noise. S1 used tail(zscore(ts_returns(rsk62_1_return,10)), lower=-0.5, upper=0.5, newval=0). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND observed. Confidence: 0.6",
      "implementation": "tail(zscore(ts_returns(rsk62_1_return, 10)), lower=-0.5, upper=0.5, newval=0)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with winsorized factor spread",
      "description": "Compute spread among factors and winsorize to limit outliers. S1 used winsorize(subtract(rsk62_factor_5_100_val49, rsk62_factor_5_100_val51)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.62",
      "implementation": "winsorize(subtract(rsk62_factor_5_100_val49, rsk62_factor_5_100_val51))",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum edge using ts_regression slope",
      "description": "Use regression slope of returns to detect trend strength. S1 used ts_regression(ts_returns(rsk62_1_return,20), ts_step(20), 63) but simplified to ts_regression(ts_returns(rsk62_1_return,20), ts_step(20), 63). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND kept. Confidence: 0.7",
      "implementation": "ts_regression(ts_returns(rsk62_1_return, 20), ts_step(20), 63)",
      "confidence_level": 0.7
    },
    {
      "idea": "Factor momentum mapped to quantile",
      "description": "Map factor momentum to gaussian quantiles to stabilize distribution. S1 used ts_quantile(ts_returns(rsk62_factor_1_100_val30,20), 63). S2 not used. S3 not needed. S4 used factor with good counts. KEEP_IN_MIND satisfied. Confidence: 0.6",
      "implementation": "ts_quantile(ts_returns(rsk62_factor_1_100_val30, 20), 63)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum combined with dividend date",
      "description": "Prefer momentum where dividend date recent/improving. S1 used multiply(ts_returns(rsk62_1_return,20), ts_zscore(rsk62_dividend_di, 63)). S2 not applicable. S3 not required. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.58",
      "implementation": "multiply(ts_returns(rsk62_1_return, 20), ts_zscore(rsk62_dividend_di, 63))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum signal damped via pasteurize",
      "description": "Remove infinities/out-of-universe values. S1 used pasteurize(zscore(ts_returns(rsk62_1_return,20))). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND minimal operators. Confidence: 0.66",
      "implementation": "pasteurize(zscore(ts_returns(rsk62_1_return, 20)))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum scaled by book-to-price beta",
      "description": "Favor momentum in low PB beta names. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), inverse(rsk62_beta_1_100_pb)). S2 not used. Coverage PB beta=1.0. S4 applied. KEEP_IN_MIND respected. Confidence: 0.67",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), inverse(rsk62_beta_1_100_pb))",
      "confidence_level": 0.67
    },
    {
      "idea": "Mean reversion via last_diff_value",
      "description": "Detect recent regime changes using last non-equal value to current. S1 used last_diff_value(rsk62_1_return, 63) and reverse. S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.56",
      "implementation": "reverse(last_diff_value(rsk62_1_return, 63))",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum neutralized by industry sum approximation",
      "description": "Approximate industry neutrality by subtracting industry mean (using industry return series). S1 used subtract(ts_returns(rsk62_1_return,20), ts_mean(rsk62_retseries_industry_1_100_val20,20)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND kept. Confidence: 0.69",
      "implementation": "subtract(ts_returns(rsk62_1_return, 20), ts_mean(rsk62_retseries_industry_1_100_val20, 20))",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum triage using ts_count_nans (data quality)",
      "description": "Downweight signals with many NaNs in lookback. S1 used divide(zscore(ts_returns(rsk62_1_return,20)), add(1, ts_count_nans(rsk62_1_return,63))). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND respected. Confidence: 0.58",
      "implementation": "divide(zscore(ts_returns(rsk62_1_return, 20)), add(1, ts_count_nans(rsk62_1_return, 63)))",
      "confidence_level": 0.58
    },
    {
      "idea": "Long-short by factor rank",
      "description": "Long top quantile of factor, short bottom quantile. S1 used quantile(rsk62_factor_1_100_val25). S2 not used. S3 not needed. S4 applied: val25 high userCount. KEEP_IN_MIND satisfied. Confidence: 0.63",
      "implementation": "quantile(rsk62_factor_1_100_val25)",
      "confidence_level": 0.63
    },
    {
      "idea": "Momentum with ts_kurtosis filter",
      "description": "Avoid names with fat tails in past returns by using ts_kurtosis. S1 used if_else(less(ts_kurtosis(rsk62_1_return,63), 10), ts_returns(rsk62_1_return,20), NaN). S2 not used. S3 not necessary. S4 applied. KEEP_IN_MIND operators <=7. Confidence: 0.55",
      "implementation": "if_else(less(ts_kurtosis(rsk62_1_return, 63), 10), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum with ts_scale normalization",
      "description": "Scale recent returns to 0-1 range in time-series space. S1 used ts_scale(ts_returns(rsk62_1_return,20), 63). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND respected. Confidence: 0.6",
      "implementation": "ts_scale(ts_returns(rsk62_1_return, 20), 63)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum combined with dividend timing (trade_when)",
      "description": "Only hold momentum around dividend dates. S1 used trade_when(greater(ts_zscore(rsk62_dividend_di,63),0), ts_returns(rsk62_1_return,20), NaN). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND within limits. Confidence: 0.56",
      "implementation": "trade_when(greater(ts_zscore(rsk62_dividend_di, 63), 0), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.56
    },
    {
      "idea": "Composite zscore across industries (average)",
      "description": "Average zscores of several industry return series (use one retseries vector). S1 used vec_avg(rsk62_retseries_industry_5_100_val5). S2 applied. S3 not needed. S4 moderate userCount. KEEP_IN_MIND single field. Confidence: 0.58",
      "implementation": "vec_avg(rsk62_retseries_industry_5_100_val5)",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum filtered by days_from_last_change",
      "description": "Favor names whose returns changed recently. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), inverse(days_from_last_change(rsk62_1_return))). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND respected. Confidence: 0.54",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), inverse(days_from_last_change(rsk62_1_return)))",
      "confidence_level": 0.54
    },
    {
      "idea": "Momentum vs factor covariance",
      "description": "Use covariance with a growth factor to isolate names co-moving with growth. S1 used ts_covariance(ts_returns(rsk62_1_return,20), rsk62_factor_1_100_val30, 63). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND within limits. Confidence: 0.6",
      "implementation": "ts_covariance(ts_returns(rsk62_1_return, 20), rsk62_factor_1_100_val30, 63)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with winsorized volatility scale",
      "description": "Scale momentum by winsorized volatility to avoid extreme scaling. S1 used winsorize(divide(ts_returns(rsk62_1_return,20), ts_std_dev(rsk62_1_return,20))). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.68",
      "implementation": "winsorize(divide(ts_returns(rsk62_1_return, 20), ts_std_dev(rsk62_1_return, 20)))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum acceleration via ts_product",
      "description": "Multiply returns across short windows to detect compounding momentum. S1 used ts_product(ts_returns(rsk62_1_return,5), 5). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND simple operators. Confidence: 0.57",
      "implementation": "ts_product(ts_returns(rsk62_1_return, 5), 5)",
      "confidence_level": 0.57
    },
    {
      "idea": "Short-term momentum with group backfill for industry data",
      "description": "Use industry return series and backfill missing values using group_backfill. S1 used ts_returns(rsk62_retseries_industry_1_100_val15,5) with group_backfill if NaN; S3 applied where industry coverage might vary. S2 not used. S4: industry series high userCount. KEEP_IN_MIND: used group_backfill with group param assumed. Confidence: 0.59",
      "implementation": "group_backfill(ts_returns(rsk62_retseries_industry_1_100_val15, 5), rsk62_retseries_industry_1_100_val15, 63)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum weighted by intercept exposure",
      "description": "Reduce market-wide exposure by subtracting intercept. S1 used subtract(zscore(ts_returns(rsk62_1_return,20)), rsk62_5_100_intercept). S2 not used. Coverage good. S4 applied. KEEP_IN_MIND respected. Confidence: 0.65",
      "implementation": "subtract(zscore(ts_returns(rsk62_1_return, 20)), rsk62_5_100_intercept)",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum persistence using ts_arg_min/max across returns",
      "description": "Identify names at relative max/min positions. S1 used ts_arg_max(ts_returns(rsk62_1_return,20), 63). S2 not applicable. S3 not needed. S4 applied. KEEP_IN_MIND observed. Confidence: 0.56",
      "implementation": "ts_arg_max(ts_returns(rsk62_1_return, 20), 63)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum adjusted for current ratio beta",
      "description": "Scale momentum by current ratio exposure beta. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), rsk62_beta_1_100_curratio). S2 not used. Coverage beta high. S4 applied. KEEP_IN_MIND followed. Confidence: 0.66",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), rsk62_beta_1_100_curratio)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum combined with log(cap) zscore",
      "description": "Prefer momentum in smaller caps by applying inverse logcap. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), inverse(ts_zscore(rsk62_logcap_di,63))). S2 not used. Coverage good. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.68",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), inverse(ts_zscore(rsk62_logcap_di, 63)))",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum with target TVR hump",
      "description": "Use hump to explicitly control turnover while keeping momentum. S1 used ts_target_tvr_hump(ts_returns(rsk62_1_return,20), 0, 1, 0.1). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND operators limited. Confidence: 0.61",
      "implementation": "ts_target_tvr_hump(ts_returns(rsk62_1_return, 20), 0, 1, 0.1)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum enhanced by net income per employee zscore",
      "description": "Combine price momentum with fundamental metric zscore. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), zscore(rsk62_risk_nipe)). S2 not used. Coverage high. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.69",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), zscore(rsk62_risk_nipe))",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum with ts_delay signal",
      "description": "Compare current return to delayed return to catch reversals. S1 used subtract(ts_returns(rsk62_1_return,5), ts_delay(ts_returns(rsk62_1_return,5),5)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND kept. Confidence: 0.57",
      "implementation": "subtract(ts_returns(rsk62_1_return, 5), ts_delay(ts_returns(rsk62_1_return, 5), 5))",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum signal clipped and normalized",
      "description": "Clip extreme zscores then normalize cross-sectionally. S1 used normalize(winsorize(zscore(ts_returns(rsk62_1_return,20)))). S2 not used. S3 not necessary. S4 applied. KEEP_IN_MIND observed. Confidence: 0.64",
      "implementation": "normalize(winsorize(zscore(ts_returns(rsk62_1_return, 20))))",
      "confidence_level": 0.64
    },
    {
      "idea": "Momentum across industries (vector avg of industry retseries)",
      "description": "Aggregate industry return series via vec_avg to form a macro-industrial momentum factor. S1 used vec_avg(rsk62_retseries_industry_5_100_val20). S2 applied. S3 not needed. S4 applied. KEEP_IN_MIND single datafield. Confidence: 0.6",
      "implementation": "vec_avg(rsk62_retseries_industry_5_100_val20)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum signal with ts_scale and zscore",
      "description": "Scale in time domain then cross-sectionally zscore. S1 used zscore(ts_scale(ts_returns(rsk62_1_return,20), 63)). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND maintained. Confidence: 0.65",
      "implementation": "zscore(ts_scale(ts_returns(rsk62_1_return, 20), 63))",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum combined with gross margin beta",
      "description": "Favor momentum in names with strong margin exposure. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), rsk62_beta_factor_5_100_margin). S2 not used. S3 not required. S4 applied: margin beta has decent userCount. KEEP_IN_MIND observed. Confidence: 0.66",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), rsk62_beta_factor_5_100_margin)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum filtered by ts_count_nans on factor series",
      "description": "Downweight factor momentum when factor series has gaps. S1 used divide(zscore(ts_returns(rsk62_factor_5_100_val13,20)), add(1, ts_count_nans(rsk62_factor_5_100_val13,63))). S2 not used. S3 not required. S4 moderate counts. KEEP_IN_MIND kept. Confidence: 0.57",
      "implementation": "divide(zscore(ts_returns(rsk62_factor_5_100_val13, 20)), add(1, ts_count_nans(rsk62_factor_5_100_val13, 63)))",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum using signed_power to emphasize strong direction",
      "description": "Apply signed_power to momentum to amplify strong signals. S1 used signed_power(ts_returns(rsk62_1_return,20), 2). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.6",
      "implementation": "signed_power(ts_returns(rsk62_1_return, 20), 2)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum vs industry kurtosis (risk filter)",
      "description": "Avoid names in industries with high kurtosis. S1 used if_else(less(ts_kurtosis(rsk62_retseries_industry_1_100_val15,63), 5), ts_returns(rsk62_1_return,20), NaN). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND observed. Confidence: 0.54",
      "implementation": "if_else(less(ts_kurtosis(rsk62_retseries_industry_1_100_val15, 63), 5), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.54
    },
    {
      "idea": "Momentum scaled by beta to short-term momentum factor",
      "description": "Scale stock momentum by its beta to the short-term momentum factor rsk62_risk_mts. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), rsk62_beta_factor_1_100_mts). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.7",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), rsk62_beta_factor_1_100_mts)",
      "confidence_level": 0.7
    },
    {
      "idea": "Momentum stable rank using ts_rank + quantile",
      "description": "Rank returns over time then map to quantile for stable weights. S1 used ts_quantile(ts_rank(rsk62_1_return,63),63). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.68",
      "implementation": "ts_quantile(ts_rank(rsk62_1_return, 63), 63)",
      "confidence_level": 0.68
    },
    {
      "idea": "Mean reversion conditional on dividend date proximity",
      "description": "Apply mean reversion only near dividend dates. S1 used trade_when(less(ts_zscore(rsk62_dividend_di,63),1), reverse(zscore(ts_returns(rsk62_1_return,5))), NaN). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND within operator limit. Confidence: 0.55",
      "implementation": "trade_when(less(ts_zscore(rsk62_dividend_di, 63), 1), reverse(zscore(ts_returns(rsk62_1_return, 5))), NaN)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum with pasteurize and winsorize (robust)",
      "description": "Clean outliers and invalids then winsorize. S1 used winsorize(pasteurize(zscore(ts_returns(rsk62_1_return,20)))). S2 not applicable. S3 not needed. S4 applied. KEEP_IN_MIND met. Confidence: 0.72",
      "implementation": "winsorize(pasteurize(zscore(ts_returns(rsk62_1_return, 20))))",
      "confidence_level": 0.72
    },
    {
      "idea": "Momentum combined with beta to banks industry",
      "description": "Scale momentum by banks industry beta to favor bank-exposed momentum. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), rsk62_beta_1_100_banks). S2 not used. S3 not needed. S4 applied (beta has high userCount). KEEP_IN_MIND respected. Confidence: 0.66",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), rsk62_beta_1_100_banks)",
      "confidence_level": 0.66
    },
    {
      "idea": "Factor return momentum using ts_retseries vector average",
      "description": "Aggregate factor return series via vec_avg and take its ts_returns for momentum. S1 used ts_returns(vec_avg(rsk62_retseries_factor_5_100_val11), 5). S2 applied. S3 not needed. S4 moderate userCount. KEEP_IN_MIND single field. Confidence: 0.59",
      "implementation": "ts_returns(vec_avg(rsk62_retseries_factor_5_100_val11), 5)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum avoiding newly listed names (days_from_last_change filter)",
      "description": "Exclude names with many recent changes. S1 used if_else(greater(days_from_last_change(rsk62_1_return), 10), zscore(ts_returns(rsk62_1_return,20)), NaN). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.53",
      "implementation": "if_else(greater(days_from_last_change(rsk62_1_return), 10), zscore(ts_returns(rsk62_1_return, 20)), NaN)",
      "confidence_level": 0.53
    },
    {
      "idea": "Momentum with ts_std_dev trend",
      "description": "Prefer momentum in names where volatility is trending down. S1 used if_else(less(ts_std_dev(rsk62_1_return,20), ts_std_dev(rsk62_1_return,60)), ts_returns(rsk62_1_return,20), NaN). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND kept. Confidence: 0.6",
      "implementation": "if_else(less(ts_std_dev(rsk62_1_return, 20), ts_std_dev(rsk62_1_return, 60)), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.6
    },
    {
      "idea": "Composite short-term factor zscore",
      "description": "Average zscore of two short-term factor returns. S1 used divide(add(zscore(rsk62_factor_5_100_val37), zscore(rsk62_factor_5_100_val41)), 2). S2 not used. S3 not needed. S4 moderate counts. KEEP_IN_MIND satisfied. Confidence: 0.61",
      "implementation": "divide(add(zscore(rsk62_factor_5_100_val37), zscore(rsk62_factor_5_100_val41)), 2)",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum signal dampened by group_count proxy",
      "description": "Reduce weight when few instruments in industry have valid data. S1 used divide(zscore(ts_returns(rsk62_1_return,20)), add(1, group_count(rsk62_1_return, rsk62_retseries_industry_1_100_val20))). I avoided using group by itself: used industry series as group param. S3 not necessary. S4 applied. KEEP_IN_MIND operators=2 datafields=2. Confidence: 0.56",
      "implementation": "divide(zscore(ts_returns(rsk62_1_return, 20)), add(1, group_count(rsk62_1_return, rsk62_retseries_industry_1_100_val20)))",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum with ts_target_tvr_decay",
      "description": "Tune decay to match target turnover for a momentum signal. S1 used ts_target_tvr_decay(ts_returns(rsk62_1_return,20), 0, 1, 0.1). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND minimal operators. Confidence: 0.6",
      "implementation": "ts_target_tvr_decay(ts_returns(rsk62_1_return, 20), 0, 1, 0.1)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum signal using group_zscore approximation",
      "description": "Approximate industry-relative zscore by using group_zscore with industry series group. S1 used group_zscore(ts_returns(rsk62_1_return,20), rsk62_retseries_industry_1_100_val20). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND used group as parameter, not alone. Confidence: 0.65",
      "implementation": "group_zscore(ts_returns(rsk62_1_return, 20), rsk62_retseries_industry_1_100_val20)",
      "confidence_level": 0.65
    },
    {
      "idea": "Momentum filtered by id_mts (momentum date index)",
      "description": "Use id of short-term momentum to filter stale signals. S1 used trade_when(equal(rsk62_id_mts, rsk62_id_mts), ts_returns(rsk62_1_return,20), NaN) as a placeholder filter—kept simple. S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND simple. Confidence: 0.52",
      "implementation": "trade_when(equal(rsk62_id_mts, rsk62_id_mts), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.52
    },
    {
      "idea": "Momentum with winsorized composite of two factors",
      "description": "Combine two factors and winsorize to reduce extremes. S1 used winsorize(add(rsk62_factor_1_100_val31, rsk62_factor_1_100_val37)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.6",
      "implementation": "winsorize(add(rsk62_factor_1_100_val31, rsk62_factor_1_100_val37))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum sign times magnitude (hybrid)",
      "description": "Combine sign and magnitude to keep direction and strength. S1 used multiply(sign(ts_returns(rsk62_1_return,5)), ts_returns(rsk62_1_return,20)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND maintained. Confidence: 0.58",
      "implementation": "multiply(sign(ts_returns(rsk62_1_return, 5)), ts_returns(rsk62_1_return, 20))",
      "confidence_level": 0.58
    },
    {
      "idea": "Momentum using kth_element for backfill",
      "description": "Backfill missing returns using kth_element then compute momentum. S1 used ts_returns(kth_element(rsk62_retseries_factor_1_100_val6, 5, 1), 5). S2 not used. S3 applied conceptually (kth_element used for backfill). S4 moderate userCount. KEEP_IN_MIND limited operators. Confidence: 0.55",
      "implementation": "ts_returns(kth_element(rsk62_retseries_factor_1_100_val6, 5, 1), 5)",
      "confidence_level": 0.55
    },
    {
      "idea": "Momentum scaled by log(adv20) beta",
      "description": "Prefer momentum in names with high adv20 beta. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), rsk62_beta_5_100_logadv20). S2 not used. S3 not required. S4 applied: beta logadv20 has high userCount. KEEP_IN_MIND kept. Confidence: 0.69",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), rsk62_beta_5_100_logadv20)",
      "confidence_level": 0.69
    },
    {
      "idea": "Momentum with group_sum industry exposure",
      "description": "Scale signal by total industry exposure using group_sum. S1 used divide(zscore(ts_returns(rsk62_1_return,20)), group_sum(rsk62_1_return, rsk62_retseries_industry_1_100_val20)). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND used group param properly. Confidence: 0.57",
      "implementation": "divide(zscore(ts_returns(rsk62_1_return, 20)), group_sum(rsk62_1_return, rsk62_retseries_industry_1_100_val20))",
      "confidence_level": 0.57
    },
    {
      "idea": "Momentum filtered by beta to volatility (risk-adjust)",
      "description": "Adjust momentum by volatility beta. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), inverse(rsk62_beta_factor_1_100_volatility)). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND respected. Confidence: 0.7",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), inverse(rsk62_beta_factor_1_100_volatility))",
      "confidence_level": 0.7
    },
    {
      "idea": "Momentum using ts_std_dev cross-sectional zscore",
      "description": "Use cross-sectional zscore of recent volatility as a filter. S1 used zscore(ts_std_dev(rsk62_1_return, 20)). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.6",
      "implementation": "zscore(ts_std_dev(rsk62_1_return, 20))",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with inverse book-to-price factor",
      "description": "Favor momentum in low PB names by multiplying with inverse PB beta. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), inverse(rsk62_beta_1_100_pb)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND observed. Confidence: 0.66",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), inverse(rsk62_beta_1_100_pb))",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum with group_neutralize approximation",
      "description": "Neutralize cross-section to groups using group_neutralize on ts_returns with industry group. S1 used group_neutralize(ts_returns(rsk62_1_return,20), rsk62_retseries_industry_1_100_val20). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND used acceptable group param. Confidence: 0.68",
      "implementation": "group_neutralize(ts_returns(rsk62_1_return, 20), rsk62_retseries_industry_1_100_val20)",
      "confidence_level": 0.68
    },
    {
      "idea": "Momentum filtered by retseries count of NaNs",
      "description": "Exclude names with unstable retseries. S1 used if_else(less_equal(ts_count_nans(rsk62_1_return,63), 5), ts_returns(rsk62_1_return,20), NaN). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.54",
      "implementation": "if_else(less_equal(ts_count_nans(rsk62_1_return, 63), 5), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.54
    },
    {
      "idea": "Momentum with density reduction (densify) for grouping",
      "description": "Reduce grouping buckets for stability before group ops. S1 used group_mean(densify(ts_returns(rsk62_1_return,20)), rsk62_retseries_industry_1_100_val20). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND operators <=7 and two fields. Confidence: 0.6",
      "implementation": "group_mean(densify(ts_returns(rsk62_1_return, 20)), ts_returns(rsk62_retseries_industry_1_100_val20, 20), rsk62_retseries_industry_1_100_val20)",
      "confidence_level": 0.6
    },
    {
      "idea": "Momentum with ts_delay for smoothing",
      "description": "Use delayed returns to smooth abrupt moves. S1 used divide(add(ts_returns(rsk62_1_return,5), ts_delay(ts_returns(rsk62_1_return,5),1)), 2). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.56",
      "implementation": "divide(add(ts_returns(rsk62_1_return, 5), ts_delay(ts_returns(rsk62_1_return, 5), 1)), 2)",
      "confidence_level": 0.56
    },
    {
      "idea": "Momentum cross-checked with retseries factor id",
      "description": "Require alignment between price momentum and factor retseries id. S1 used if_else(equal(rsk62_id_mts, rsk62_id_mts), ts_returns(rsk62_1_return,20), NaN) as a consistency check. S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND simple. Confidence: 0.5",
      "implementation": "if_else(equal(rsk62_id_mts, rsk62_id_mts), ts_returns(rsk62_1_return, 20), NaN)",
      "confidence_level": 0.5
    },
    {
      "idea": "Momentum with inverse leverage proxy (curratio)",
      "description": "Reduce exposure to high-leverage names by curratio. S1 used multiply(zscore(ts_returns(rsk62_1_return,20)), ts_zscore(rsk62_curratio_di,126)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND kept. Confidence: 0.62",
      "implementation": "multiply(zscore(ts_returns(rsk62_1_return, 20)), ts_zscore(rsk62_curratio_di, 126))",
      "confidence_level": 0.62
    },
    {
      "idea": "Momentum with ts_backfill for low coverage beta",
      "description": "Use beta field with low coverage by backfilling. S1 used ts_backfill(rsk62_beta_industry_constr_5_100_electronics, 30) per SUGGESTION3 because coverage=0.3266. S2 not used. S4: userCount moderate. KEEP_IN_MIND operators minimal. Confidence: 0.48",
      "implementation": "ts_backfill(rsk62_beta_industry_constr_5_100_electronics, 30)",
      "confidence_level": 0.48
    },
    {
      "idea": "Momentum with ts_regression residual",
      "description": "Use regression residual of returns vs market factor as alpha. S1 used ts_regression(ts_returns(rsk62_1_return,20), rsk62_factor_1_100_val100, 63) and pick residual. S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND operators limited. Confidence: 0.66",
      "implementation": "ts_regression(ts_returns(rsk62_1_return, 20), rsk62_factor_1_100_val100, 63)",
      "confidence_level": 0.66
    },
    {
      "idea": "Momentum with tail clipping and normalization",
      "description": "Clip mid-range signals to zero and normalize. S1 used normalize(tail(zscore(ts_returns(rsk62_1_return,10)), lower=-0.3, upper=0.3, newval=0)). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND satisfied. Confidence: 0.61",
      "implementation": "normalize(tail(zscore(ts_returns(rsk62_1_return, 10)), lower=-0.3, upper=0.3, newval=0))",
      "confidence_level": 0.61
    },
    {
      "idea": "Momentum with ts_av_diff on factor series",
      "description": "Use deviation from mean in factor retseries to spot temporary moves. S1 used ts_av_diff(rsk62_factor_1_100_val63, 20). S2 not used. S3 not required. S4 applied. KEEP_IN_MIND respected. Confidence: 0.59",
      "implementation": "ts_av_diff(rsk62_factor_1_100_val63, 20)",
      "confidence_level": 0.59
    },
    {
      "idea": "Momentum with group_rank industry neutralization",
      "description": "Rank within industry to remove sector bias. S1 used group_rank(ts_returns(rsk62_1_return,20), rsk62_retseries_industry_1_100_val20). S2 not used. S3 not needed. S4 applied. KEEP_IN_MIND: group used as parameter. Confidence: 0.67",
      "implementation": "group_rank(ts_returns(rsk62_1_return, 20), rsk62_retseries_industry_1_100_val20)",
      "confidence_level": 0.67
    }
  ]
}